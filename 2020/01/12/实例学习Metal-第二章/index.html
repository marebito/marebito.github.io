<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="实例学习Metal-第二章 设置舞台并清除屏幕"><meta name="keywords" content="iOS/Mac,图形学,Metal"><meta name="author" content="Boyka·Yuri"><meta name="copyright" content="Boyka·Yuri"><title>实例学习Metal-第二章 设置舞台并清除屏幕 | 博伊卡の楼閣</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter2-第二章"><span class="toc-number">1.</span> <span class="toc-text">Chapter2 (第二章)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Setting-the-Stage-and-Clearing-the-Screen-设置舞台和清除屏幕"><span class="toc-number">1.1.</span> <span class="toc-text">Setting the Stage and Clearing the Screen(设置舞台和清除屏幕)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Creating-a-New-Project-创建一个新项目"><span class="toc-number">1.1.1.</span> <span class="toc-text">Creating a New Project(创建一个新项目)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interfacing-with-UIKit-与UIKit接口"><span class="toc-number">1.1.2.</span> <span class="toc-text">Interfacing with UIKit(与UIKit接口)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protocols-协议"><span class="toc-number">1.1.3.</span> <span class="toc-text">Protocols(协议)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Devices-设备"><span class="toc-number">1.1.4.</span> <span class="toc-text">Devices(设备)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-redraw-method-重绘方法"><span class="toc-number">1.1.5.</span> <span class="toc-text">The redraw method(重绘方法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Textures-and-Drawables-纹理和绘图"><span class="toc-number">1.1.6.</span> <span class="toc-text">Textures and Drawables(纹理和绘图)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Render-Passes-渲染通道"><span class="toc-number">1.1.7.</span> <span class="toc-text">Render Passes(渲染通道)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queues-Buffers-and-Encoders-队列，缓冲区和编码器"><span class="toc-number">1.1.8.</span> <span class="toc-text">Queues, Buffers, and Encoders(队列，缓冲区和编码器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Sample-App-示例项目"><span class="toc-number">1.1.9.</span> <span class="toc-text">The Sample App(示例项目)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conclusion-总结"><span class="toc-number">1.1.10.</span> <span class="toc-text">Conclusion(总结)</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Boyka·Yuri</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/marebito">关 注</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">35</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">17</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">学习链接</div><a class="author-info-links__name text-center" href="https://data.biancheng.net">数 据 结 构 与 算 法 &gt;&gt;</a><a class="author-info-links__name text-center" href="https://catlikecoding.com/unity/tutorials">U n i t y 学 习 指 南 &gt;&gt;</a><a class="author-info-links__name text-center" href="https://gameprogrammingpatterns.com/">游 戏 设 计 模 式 &gt;&gt;</a><a class="author-info-links__name text-center" href="http://neuralnetworksanddeeplearning.com/">神 经 网 络 与 深 度 学 习 &gt;&gt;</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://zhaolilong.com/AtlantisNebula.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">博伊卡の楼閣</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">实例学习Metal-第二章 设置舞台并清除屏幕</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-12</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 8 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本章介绍了在Metal中将屏幕清除为纯色所需的最低限度。即使这种简单的操作也需要金属框架所暴露的许多概念。以下章节将以此材料为基础，演示如何进行3D渲染等。</p>
<a id="more"></a>

<h1 id="Chapter2-第二章"><a href="#Chapter2-第二章" class="headerlink" title="Chapter2 (第二章)"></a>Chapter2 (第二章)</h1><h2 id="Setting-the-Stage-and-Clearing-the-Screen-设置舞台和清除屏幕"><a href="#Setting-the-Stage-and-Clearing-the-Screen-设置舞台和清除屏幕" class="headerlink" title="Setting the Stage and Clearing the Screen(设置舞台和清除屏幕)"></a>Setting the Stage and Clearing the Screen(设置舞台和清除屏幕)</h2><p>本章介绍了在Metal中将屏幕清除为纯色所需的最低限度。即使这种简单的操作也需要金属框架所暴露的许多概念。以下章节将以此材料为基础，演示如何进行3D渲染等。</p>
<h3 id="Creating-a-New-Project-创建一个新项目"><a href="#Creating-a-New-Project-创建一个新项目" class="headerlink" title="Creating a New Project(创建一个新项目)"></a>Creating a New Project(创建一个新项目)</h3><p>让我们在Xcode中创建一个新项目。我们更喜欢从单视图模板开始，因为它创建了一个视图控制器并将它连接到我们的窗口。</p>
<p><img src="/2020/01/12/实例学习Metal-第二章/1584062478.png" alt=""></p>
<center>图2.1：在Xcode中创建一个新的单视图项目</center>

<h3 id="Interfacing-with-UIKit-与UIKit接口"><a href="#Interfacing-with-UIKit-与UIKit接口" class="headerlink" title="Interfacing with UIKit(与UIKit接口)"></a>Interfacing with UIKit(与UIKit接口)</h3><p>iOS上的每个UIView都使用Core Animation层作为其后备存储。换句话说，视图的图层包含在屏幕上绘制的实际内容。我们说这样的视图由CALayer实例支持。</p>
<p>您可以通过覆盖UIView子类上的<code>+layerClass</code>方法，告诉UIView更改它实例化为其后备层的图层类型。</p>
<p>您可以使用Xcode中的“File•New•File …”菜单在您自己的项目中进行操作，并生成一个新的Cocoa Touch类，它是UIView的子类。我们称之为<code>MBEMetalView</code>。</p>
<p><img src="/2020/01/12/实例学习Metal-第二章/1584062555.png" alt=""></p>
<center>图2.2：在Xcode中添加一个新的UIView子类</center>

<p>CAMetalLayer不是由Metal框架提供，而是由Core Animation提供。 CAMetalLayer是将UIKit和Metal绑定在一起的粘合剂，它提供了一些我们很快就会看到的非常好的功能。</p>
<p>让我们在UIView子类中实现+ layerClass，这样它就知道我们需要一个Metal层而不是一个CALayer。以下是完整的MBEMetalView实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation MBEMetalView</span><br><span class="line"></span><br><span class="line">+ (id)layerClass </span><br><span class="line">&#123;</span><br><span class="line">    return [CAMetalLayer class]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>将主故事板文件中的视图的自定义类更改为<code>MBEMetalView</code>。这将导致在加载故事板时实例化子类。这反过来为我们提供了一个适当的Metal层支持视图。</p>
<p><img src="/2020/01/12/实例学习Metal-第二章/1584062589.png" alt=""></p>
<center>图2.3：为视图控制器的根视图设置自定义类</center>

<p>为方便起见，您可以添加一个属性到您的视图类，它是一个CAMetalLayer类型的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">CAMetalLayer</span> *metalLayer;</span><br></pre></td></tr></table></figure>

<p>这可以防止您不得不重复从图层属性（即<code>CALayer</code>）的类型转换为实际的子类（<code>CAMetalLayer</code>），因为<code>CAMetalLayer</code>提供了一些在<code>CALayer</code>上找不到的方法。您可以按如下方式实现此属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CAMetalLayer</span> *)metalLayer </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">CAMetalLayer</span> *)<span class="keyword">self</span>.layer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您在设备上构建并运行此项目，您将只看到纯白色屏幕。要实际进行任何绘图，我们需要了解Metal设备以及它们帮助我们创建的所有其他对象。首先，关于在Metal中使用协议的一个词。</p>
<h3 id="Protocols-协议"><a href="#Protocols-协议" class="headerlink" title="Protocols(协议)"></a>Protocols(协议)</h3><p>Metal API中的一个共同主题是使用协议而不是具体类来公开Metal功能。许多Metal API返回符合特定协议的对象，具体类型是次要的。这样做的好处是您无需关心实现该功能的确切类。</p>
<p>声明符合协议MTLDevice的对象的语法如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> &lt;<span class="built_in">MTLDevice</span>&gt; device;</span><br></pre></td></tr></table></figure>

<p>现在，我们来看看如何检索和使用设备。</p>
<h3 id="Devices-设备"><a href="#Devices-设备" class="headerlink" title="Devices(设备)"></a>Devices(设备)</h3><p>设备是GPU的抽象。它提供了创建命令队列，渲染状态和库等对象的方法。我们将很快查看其中的每一个。</p>
<p>Metal提供了一个C函数<code>MTLCreateSystemDefaultDevice</code>，它可以创建并返回一个满足我们需求的设备。此函数不带参数，因为没有可指定的设备属性。</p>
<p>我们的Metal层需要知道哪个设备将被渲染到其中。我们还需要在图层上配置像素格式，以便每个人都对其颜色组件的大小和顺序达成一致。 <code>MTLPixelFormatBGRA8Unorm</code>是一个不错的选择。使用此像素格式，每个像素将由蓝色，绿色，红色和alpha分量组成，每个分量将是一个8位无符号整数（介于0和255之间）。</p>
<p>在视图子类上创建设备属性很有帮助，因为我们需要设备在代码的其余部分为我们创建各种资源：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MBEMetalView</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;<span class="built_in">MTLDevice</span>&gt; device; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在我们使用Metal的函数之前，我们需要使用以下行导入Metal模块：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> Metal;</span><br></pre></td></tr></table></figure>

<p>以下是<code>-init</code>的完整实现，显示了所有必要的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder </span><br><span class="line">&#123;</span><br><span class="line">    if ((self = [super initWithCoder:aDecoder])) </span><br><span class="line">    &#123;</span><br><span class="line">        _metalLayer = (CAMetalLayer *)[self layer];</span><br><span class="line">        _device = MTLCreateSystemDefaultDevice(); _metalLayer.device = _device; </span><br><span class="line">        _metalLayer.pixelFormat = MTLPixelFormatBGRA8Unorm;</span><br><span class="line">    &#125;</span><br><span class="line">    return self; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，我们覆盖<code>initWithCoder:</code>因为我们知道我们正在从故事板加载我们的视图。为了完整起见，我们还应该包含一个<code>init</code>的重写，以便我们可以以编程方式实例化该类。</p>
<h3 id="The-redraw-method-重绘方法"><a href="#The-redraw-method-重绘方法" class="headerlink" title="The redraw method(重绘方法)"></a>The redraw method(重绘方法)</h3><p>在接下来的章节中，我们将绘图的责任委托给一个单独的类。目前，我们的视图类中的<code>-redraw</code>方法是我们发出绘图命令的地方。此外，我们不会重复重绘屏幕，只需将其清除一次为纯色。因此，只需调用<code>-redraw</code>就足够了。我们可以通过覆盖<code>-didMoveToWindow</code>方法来调用它，因为这个方法将在应用程序启动时调用一次。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didMoveToWindow </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> redraw]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重绘方法本身将完成清除屏幕所需的所有工作。本章其余部分的所有代码都包含在此方法中。</p>
<h3 id="Textures-and-Drawables-纹理和绘图"><a href="#Textures-and-Drawables-纹理和绘图" class="headerlink" title="Textures and Drawables(纹理和绘图)"></a>Textures and Drawables(纹理和绘图)</h3><p>Metal中的纹理是图像的容器。您可能习惯将纹理视为单个图像，但Metal中的纹理更抽象。 Metal还允许单个纹理对象表示图像<code>阵列</code>，每个图像称为<code>切片</code>。纹理中的每个图像都具有特定的大小和像素格式。纹理可以是1D，2D或3D。</p>
<p>我们现在不需要任何这些奇特的纹理。相反，我们将使用单个2D纹理作为我们的渲染缓冲区（即，实际像素被写入的位置）。此文本将与我们的应用程序运行设备的屏幕具有相同的分辨率。我们通过使用Core Animation提供的功能之一获得对此纹理的引用：<code>CAMetalDrawable</code>协议。</p>
<p>可绘制物(drawable)是由Metal层提供的物体，可以为我们提供可渲染的纹理。每次绘制时，我们都会向Metal图层请求一个可绘制对象，我们可以从中提取一个充当我们帧缓冲区的纹理。代码非常简单：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span>&lt;<span class="built_in">CAMetalDrawable</span>&gt; drawable = [<span class="keyword">self</span>.metalLayer nextDrawable]; </span><br><span class="line"><span class="keyword">id</span>&lt;<span class="built_in">MTLTexture</span>&gt; texture = drawable.texture;</span><br></pre></td></tr></table></figure>

<p>当我们完成渲染到纹理时，我们还将使用drawable向核心动画发信号，因此它可以在屏幕上显示。要实际清除帧缓冲区的纹理，我们需要设置一个渲染通道描述符来描述每帧采取的操作。</p>
<h3 id="Render-Passes-渲染通道"><a href="#Render-Passes-渲染通道" class="headerlink" title="Render Passes(渲染通道)"></a>Render Passes(渲染通道)</h3><p><code>渲染过程描述符</code>告诉Metal在渲染图像时要执行的操作。在渲染过程开始时，<code>loadAction</code>确定是否清除或保留纹理的先前内容。 <code>storeAction</code>确定了什么<br>渲染对纹理的影响：结果可以存储或丢弃。由于我们希望我们的像素在屏幕上结束，因此我们选择我们的商店操作为<code>MTLStoreActionStore</code>。</p>
<p>传递描述符也是我们选择在绘制任何几何图形之前屏幕将被清除的颜色的位置。在下面的情况中，我们选择不透明的红色（red= 1，green= 0，blue= 0，alpha = 1）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MTLRenderPassDescriptor</span> *passDescriptor = [<span class="built_in">MTLRenderPassDescriptor</span> renderPassDescriptor];</span><br><span class="line">passDescriptor.colorAttachments[<span class="number">0</span>].texture = texture; </span><br><span class="line">passDescriptor.colorAttachments[<span class="number">0</span>].loadAction = <span class="built_in">MTLLoadActionClear</span>; </span><br><span class="line">passDescriptor.colorAttachments[<span class="number">0</span>].storeAction = <span class="built_in">MTLStoreActionStore</span>; </span><br><span class="line">passDescriptor.colorAttachments[<span class="number">0</span>].clearColor = <span class="built_in">MTLClearColorMake</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>下面将使用渲染过程描述符来创建用于执行渲染命令的命令编码器。我们有时会将命令编码器本身称为<code>渲染过程</code>。</p>
<h3 id="Queues-Buffers-and-Encoders-队列，缓冲区和编码器"><a href="#Queues-Buffers-and-Encoders-队列，缓冲区和编码器" class="headerlink" title="Queues, Buffers, and Encoders(队列，缓冲区和编码器)"></a>Queues, Buffers, and Encoders(队列，缓冲区和编码器)</h3><p><code>命令队列</code>是一个对象，用于保存要执行的渲染命令缓冲区列表。我们只需询问设备即可获得一个。通常，命令队列是一个长期存在的对象，因此在更高级的场景中，我们将保留为多个帧创建的队列。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span>&lt;<span class="built_in">MTLCommandQueue</span>&gt; commandQueue = [<span class="keyword">self</span>.device newCommandQueue];</span><br></pre></td></tr></table></figure>

<p><code>命令缓冲区</code>表示要作为一个单元执行的渲染命令的集合。每个命令缓冲区都与一个队列相关联：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span>&lt;<span class="built_in">MTLCommandBuffer</span>&gt; commandBuffer = [commandQueue commandBuffer];</span><br></pre></td></tr></table></figure>

<p>命令编码器是一个对象，用于告诉Metal我们实际想要做什么的绘图。它负责将这些高级命令（设置这些着色器参数，绘制这些三角形等）转换为低级指令，然后将这些指令写入相应的命令缓冲区。一旦我们发出了所有的绘制调用（我们将在下一章讨论），我们将endEncoding消息发送到命令编码器，以便它有机会完成其编码。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> &lt;<span class="built_in">MTLRenderCommandEncoder</span>&gt; commandEncoder = [commandBuffer renderCommandEncoderWithDescriptor:passDescriptor];</span><br><span class="line">[commandEncoder endEncoding];</span><br></pre></td></tr></table></figure>

<p>作为最后一个操作，命令缓冲区将发出信号，一旦所有前面的命令完成，其drawable将准备好显示在屏幕上。然后，我们调用commit来指示此命令缓冲区已完成并准备好放入命令队列以便在GPU上执行。反过来，这将导致我们的帧缓冲区填充我们选择的清晰颜色，红色。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[commandBuffer presentDrawable:drawable]; </span><br><span class="line">[commandBuffer commit];</span><br></pre></td></tr></table></figure>

<h3 id="The-Sample-App-示例项目"><a href="#The-Sample-App-示例项目" class="headerlink" title="The Sample App(示例项目)"></a>The Sample App(示例项目)</h3><p>本章的示例代码位于02-ClearScreen目录中。</p>
<p><img src="/2020/01/12/实例学习Metal-第二章/1584062640.png" alt=""></p>
<center>图2.4：将屏幕清除为纯红色的结果</center>

<h3 id="Conclusion-总结"><a href="#Conclusion-总结" class="headerlink" title="Conclusion(总结)"></a>Conclusion(总结)</h3><p>本章为更多令人兴奋的主题奠定了基础，例如3D渲染。希望你现在对使用Metal时会看到的一些对象有所了解。在下一章中，我们将介绍2D中的绘图几何。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Boyka·Yuri</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhaolilong.com/2020/01/12/实例学习Metal-第二章/">https://zhaolilong.com/2020/01/12/实例学习Metal-第二章/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhaolilong.com">博伊卡の楼閣</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS-Mac/">iOS/Mac</a><a class="post-meta__tags" href="/tags/图形学/">图形学</a><a class="post-meta__tags" href="/tags/Metal/">Metal</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://zhaolilong.com/alipay.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://zhaolilong.com/wx.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/01/19/实例学习Metal-第三章/"><i class="fa fa-chevron-left">  </i><span>实例学习Metal-第三章 2D绘制</span></a></div><div class="next-post pull-right"><a href="/2020/01/05/实例学习Metal-第一章/"><span>实例学习Metal-第一章 欢迎</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://zhaolilong.com/AtlantisNebula.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2011 - 2020 By Boyka·Yuri</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>