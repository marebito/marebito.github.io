<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博伊卡の楼閣</title>
  
  <subtitle>逆水行舟，不进则退</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhaolilong.com/"/>
  <updated>2020-09-03T03:46:56.049Z</updated>
  <id>https://zhaolilong.com/</id>
  
  <author>
    <name>Boyka·Yuri</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Modbus寄存器种类说明</title>
    <link href="https://zhaolilong.com/2020/09/03/Modbus%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%8D%E7%B1%BB%E8%AF%B4%E6%98%8E/"/>
    <id>https://zhaolilong.com/2020/09/03/Modbus寄存器种类说明/</id>
    <published>2020-09-03T03:43:53.000Z</published>
    <updated>2020-09-03T03:46:56.049Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>寄存器种类</th><th>说明</th><th>PLC类比</th><th>举例说明</th></tr></thead><tbody><tr><td>线圈状态</td><td>输出端口。可设定端口的输出状态，也可以读取该位的输出状态。可分为两种不同的执行状态，例如保持型或边沿触发型。</td><td>DO数字量输出</td><td>电磁阀输出，MOSFET输出，LED显示等。</td></tr><tr><td>离散输入状态</td><td>输入端口。通过外部设定改变输入状态，可读但不可写。</td><td>DI数字量输入</td><td>拨码开关，接近开关等。</td></tr><tr><td>保持寄存器</td><td>输出参数或保持参数，控制器运行时被设定的某些参数。可读可写。</td><td>AO模拟量输出</td><td>模拟量输出设定值，PID运行参数，变量阀输出大小，传感器报警上限下限。</td></tr><tr><td>输入寄存器</td><td>输入参数。控制器运行时从外部设备获得的参数。可读但不可写。</td><td>AI模拟量输入</td><td>模拟量输入</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;寄存器种类&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;PLC类比&lt;/th&gt;
&lt;th&gt;举例说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;线圈状态&lt;/td&gt;
&lt;td&gt;输出端口。可设定端口的输出状态，也可
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ModbusTCP报文格式说明</title>
    <link href="https://zhaolilong.com/2020/09/03/ModbusTCP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/"/>
    <id>https://zhaolilong.com/2020/09/03/ModbusTCP报文格式说明/</id>
    <published>2020-09-03T02:20:07.000Z</published>
    <updated>2020-09-03T06:07:09.487Z</updated>
    
    <content type="html"><![CDATA[<p>modbus tcp数据报文结构</p><p>请求：00 00 00 00 00 06 09 03 00 00 00 01</p><p>响应：00 00 00 00 00 05 09 03 02 12 34</p><p>　　一次modbus tcp读取保持寄存器的通信分析(省略了ip/tcp头)：从左向右分析该数据报文：</p><p>请求：</p><p>00 00为此次通信事务处理标识符，一般每次通信之后将被要求加1以区别不同的通信数据报文;</p><p>00 00表示协议标识符，00 00为modbus协议;</p><p>00 06为数据长度，用来指示接下来数据的长度，单位字节;</p><p>09为设备地址，用以标识连接在串行线或者网络上的远程服务端的地址。以上七个字节也被称为modbus报文头；</p><p>03为功能码，此时代码03为读取保持寄存器数据；</p><p>00 00为起始地址；</p><p>00 01为寄存器数量，（word数量）。</p><p>响应：</p><p>00 00为此次通信事务处理标识符，应答报文要求与先前对应的请求保持一致;</p><p>00 00为协议标识符，与先前对应的请求保持一致;</p><p>00 05为数据长度，用来指示接下来数据的长度，单位字节;</p><p>09为设备地址，应答报文要求与先前对应的请求保持一致；</p><p>03为功能码，正常情况下应答报文要求与先前对应的请求保持一致，如果出错则返回80h+先前的功能码；</p><p>02指示接下来数据的字节长度;</p><p>12 34为被读取的保持寄存器中的数据值，即要求被读取的地址为00 00的保持寄存器中的数值为1234h。</p><p>参考资料：<a href="https://www.cnblogs.com/ioufev/articles/10830028.html" target="_blank" rel="noopener">https://www.cnblogs.com/ioufev/articles/10830028.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;modbus tcp数据报文结构&lt;/p&gt;
&lt;p&gt;请求：00 00 00 00 00 06 09 03 00 00 00 01&lt;/p&gt;
&lt;p&gt;响应：00 00 00 00 00 05 09 03 02 12 34&lt;/p&gt;
&lt;p&gt;　　一次modbus tcp读取保持寄存器的通信
      
    
    </summary>
    
    
      <category term="ModbusTCP" scheme="https://zhaolilong.com/tags/ModbusTCP/"/>
    
  </entry>
  
  <entry>
    <title>Modbus常用功能码备查</title>
    <link href="https://zhaolilong.com/2020/09/03/Modbus%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E7%A0%81%E5%A4%87%E6%9F%A5/"/>
    <id>https://zhaolilong.com/2020/09/03/Modbus常用功能码备查/</id>
    <published>2020-09-03T01:48:13.000Z</published>
    <updated>2020-09-03T03:42:50.327Z</updated>
    
    <content type="html"><![CDATA[<p>Modbus功能码</p><table><thead><tr><th>功能码</th><th>名称</th><th>寄存器PLC地址</th><th>位操作/字操作</th><th>作用</th><th>操作数量</th></tr></thead><tbody><tr><td>01</td><td>读线圈状态</td><td>00001-09999</td><td>位</td><td>取得一组逻辑线圈的当前状态（ON/OFF）</td><td>单个或多个</td></tr><tr><td>02</td><td>读离散输入状态</td><td>10001-19999</td><td>位</td><td>取得一组开关输入的当前状态（ON/OFF）</td><td>单个或多个</td></tr><tr><td>03</td><td>读保持寄存器</td><td>40001-49999</td><td>整型、字符型、状态字、浮点型</td><td>在一个或多个保持寄存器中取得当前的二进制值</td><td>单个或多个</td></tr><tr><td>04</td><td>读输入寄存器</td><td>30001-39999</td><td>整型、状态字、浮点型</td><td>在一个或多个输入寄存器中取得当前的二进制值</td><td>单个或多个</td></tr><tr><td>05</td><td>写单个线圈</td><td>00001-09999</td><td>位</td><td>强置一个逻辑线圈的通断状态</td><td>单个</td></tr><tr><td>06</td><td>写单个寄存器</td><td>40001-49999</td><td>整型、字符型、状态字、浮点型</td><td>把二进制值装入一个保持寄存器</td><td>单个</td></tr><tr><td>15</td><td>写多个线圈</td><td>00001-09999</td><td>位</td><td>强置一串连续逻辑线圈的通断</td><td>多个</td></tr><tr><td>16</td><td>写多个保持寄存器</td><td>40001-49999</td><td>整型、字符型、状态字、浮点型</td><td>把具体的二进制值装入一串连续的保持寄存器</td><td>多个</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Modbus功能码&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能码&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;寄存器PLC地址&lt;/th&gt;
&lt;th&gt;位操作/字操作&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;操作数量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Modbus" scheme="https://zhaolilong.com/tags/Modbus/"/>
    
  </entry>
  
  <entry>
    <title>Modbus寄存器地址规则</title>
    <link href="https://zhaolilong.com/2020/09/03/Modbus%E5%AF%84%E5%AD%98%E5%99%A8%E5%9C%B0%E5%9D%80%E8%A7%84%E5%88%99/"/>
    <id>https://zhaolilong.com/2020/09/03/Modbus寄存器地址规则/</id>
    <published>2020-09-03T01:45:04.000Z</published>
    <updated>2020-09-03T01:45:52.220Z</updated>
    
    <content type="html"><![CDATA[<p>Modbus协议定义的寄存器地址是5位十进制地址，即：</p><p>线圈（DO）地址：00000~09999</p><p>触点（DI）地址：10000~19999</p><p>输入寄存器（AI）地址：30000~39999</p><p>输出寄存器（AO）地址：40000~49999</p><p>由于上述各类地址是唯一对应的，因此有些资料就以其第一个数字区分各类地址，即：0x代表线圈（DO）类地址，1x代表触点（DI）类地址、 3x代表输入寄存器（AI）类地址、4x代表输出寄存器（AO）类地址。</p><p>在实际编程中，由于前缀的区分作用，所以只需说明后4位数，而且需转换为4位十六进制地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Modbus协议定义的寄存器地址是5位十进制地址，即：&lt;/p&gt;
&lt;p&gt;线圈（DO）地址：00000~09999&lt;/p&gt;
&lt;p&gt;触点（DI）地址：10000~19999&lt;/p&gt;
&lt;p&gt;输入寄存器（AI）地址：30000~39999&lt;/p&gt;
&lt;p&gt;输出寄存器（AO）地址：400
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Arduino中字符串常见操作</title>
    <link href="https://zhaolilong.com/2020/06/11/Arduino%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
    <id>https://zhaolilong.com/2020/06/11/Arduino中字符串常见操作/</id>
    <published>2020-06-11T03:12:37.000Z</published>
    <updated>2020-06-11T03:21:46.464Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">isAlphaNumeric()  // 判断是否为字母数字</span><br><span class="line"></span><br><span class="line">isAlpha()        // 判断是否为字母</span><br><span class="line"></span><br><span class="line">isAscii()        // 判断是否为 ASCII 码</span><br><span class="line"></span><br><span class="line">isWhitespace()    // 判断是否为空格符</span><br><span class="line"></span><br><span class="line">isControl()          // 判断是否为控制字符</span><br><span class="line"></span><br><span class="line">isDigit()              // 判断是否为数字</span><br><span class="line"></span><br><span class="line">isGraph()            // 判断是否为可打印的字符，不是空格</span><br><span class="line"></span><br><span class="line">isLowerCase()       // 判断是否为小写</span><br><span class="line"></span><br><span class="line">isPrintable()        // 判断是否为可打印的字符</span><br><span class="line"></span><br><span class="line">isPunct()            // 判断是否为标点符号</span><br><span class="line"></span><br><span class="line">isSpace()            // 判断是否为空格</span><br><span class="line"></span><br><span class="line">isUpperCase()     // 判断是否为大写</span><br><span class="line"></span><br><span class="line">isHexadecimalDigit()  // 判断是否为十六进制数字(i.e. 0 - 9, a - F, or A - F)</span><br></pre></td></tr></table></figure><ol><li>字符串转char *</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello&quot;;</span><br><span class="line">int str_len = str() + 1; </span><br><span class="line">char str_char[str_len];</span><br><span class="line">str.toCharArray(str_char, str_len);</span><br></pre></td></tr></table></figure><ol start="2"><li>字符串转整型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;65535&quot;;</span><br><span class="line">int intValue = str.toInt();</span><br></pre></td></tr></table></figure><ol start="3"><li>字符串切割</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, World&quot;;</span><br><span class="line">int str_len = str() + 1; </span><br><span class="line">char str_char[str_len];</span><br><span class="line">strcpy(str_char, str());</span><br><span class="line">const char split_token[2] = &quot;.&quot;;</span><br><span class="line">int charArray[str_len];</span><br><span class="line">int i = 0;</span><br><span class="line">char *charValue = strtok(str_char, split_token);                 </span><br><span class="line">while( charValue != NULL ) &#123;</span><br><span class="line">    charArray[i++] = charValue;</span><br><span class="line">    charValue = strtok(NULL, split_token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考连接: <a href="https://www.jianshu.com/p/5d4c5f318b73" target="_blank" rel="noopener">https://www.jianshu.com/p/5d4c5f318b73</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jenkins更新新版本速度慢</title>
    <link href="https://zhaolilong.com/2020/06/04/jenkins%E6%9B%B4%E6%96%B0%E6%96%B0%E7%89%88%E6%9C%AC%E9%80%9F%E5%BA%A6%E6%85%A2/"/>
    <id>https://zhaolilong.com/2020/06/04/jenkins更新新版本速度慢/</id>
    <published>2020-06-04T01:53:53.000Z</published>
    <updated>2020-06-04T01:55:44.895Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Linux<br>cd /root/.jenkins/updates/</p></li><li><p>OSX<br>cd /Users/Shared/Jenkins/Home/updates<br>cd ~/.jenkins/updates</p></li></ul><p>sed -i ‘s/http://updates.jenkins-ci.org/download/https://mirrors.tuna.tsinghua.edu.cn/jenkins/g’ default.json &amp;&amp; sed -i ‘s/http://<a href="http://www.google.com/https:\/\/www.baidu.com/g&#39;" target="_blank" rel="noopener">www.google.com/https:\/\/www.baidu.com/g&#39;</a> default.json</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linux&lt;br&gt;cd /root/.jenkins/updates/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OSX&lt;br&gt;cd /Users/Shared/Jenkins/Home/updates&lt;br&gt;cd ~/.jenkins/updates&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux下查看ssh的用户登录日志</title>
    <link href="https://zhaolilong.com/2020/05/29/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8Bssh%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%97%A5%E5%BF%97/"/>
    <id>https://zhaolilong.com/2020/05/29/Linux下查看ssh的用户登录日志/</id>
    <published>2020-05-29T03:12:33.000Z</published>
    <updated>2020-05-29T03:13:12.830Z</updated>
    
    <content type="html"><![CDATA[<p>linux查看日志： </p><h1 id="cd-var-log"><a href="#cd-var-log" class="headerlink" title="cd /var/log"></a>cd /var/log</h1><h1 id="less-secure"><a href="#less-secure" class="headerlink" title="less secure"></a>less secure</h1><p>或者 </p><h1 id="less-messages"><a href="#less-messages" class="headerlink" title="less messages"></a>less messages</h1><p>最近登录的日志： </p><h1 id="last"><a href="#last" class="headerlink" title="last"></a>last</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;linux查看日志： &lt;/p&gt;
&lt;h1 id=&quot;cd-var-log&quot;&gt;&lt;a href=&quot;#cd-var-log&quot; class=&quot;headerlink&quot; title=&quot;cd /var/log&quot;&gt;&lt;/a&gt;cd /var/log&lt;/h1&gt;&lt;h1 id=&quot;less-secure&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>是谁没事儿尝试来我家开锁？</title>
    <link href="https://zhaolilong.com/2020/05/28/%E6%98%AF%E8%B0%81%E6%B2%A1%E4%BA%8B%E5%84%BF%E5%B0%9D%E8%AF%95%E6%9D%A5%E6%88%91%E5%AE%B6%E5%BC%80%E9%94%81%EF%BC%9F/"/>
    <id>https://zhaolilong.com/2020/05/28/是谁没事儿尝试来我家开锁？/</id>
    <published>2020-05-28T02:23:41.000Z</published>
    <updated>2020-05-29T03:13:46.789Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Failed password for invalid user&quot; /var/log/secure | awk &apos;&#123;print $13&#125;&apos; | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>U8G2详解</title>
    <link href="https://zhaolilong.com/2020/05/09/U8G2%E8%AF%A6%E8%A7%A3/"/>
    <id>https://zhaolilong.com/2020/05/09/U8G2详解/</id>
    <published>2020-05-09T02:09:48.000Z</published>
    <updated>2020-05-09T07:21:47.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="U8g2简介"><a href="#U8g2简介" class="headerlink" title="U8g2简介"></a>U8g2简介</h2><p>U8g2是嵌入式设备的单色图形库，一句话简单明了。主要应用于嵌入式设备，包括我们常见的单片机。    </p><a id="more"></a><h2 id="U8g2支持的显示控制器"><a href="#U8g2支持的显示控制器" class="headerlink" title="U8g2支持的显示控制器"></a>U8g2支持的显示控制器</h2><p>    U8g2支持单色OLED和LCD，包括以下控制器：SSD1305，SSD1306，SSD1309，SSD1322，SSD1325，SSD1327，SSD1329，SSD1606，SSD1607，SH1106，SH1107，SH1108，SH1122，T6963，RA8835，LC7981，PCD8544，PCF8812，HX1230 ，UC1601，UC1604，UC1608，UC1610，UC1611，UC1701，ST7565，ST7567，ST7588，ST75256，NT7534，IST3020，ST7920，LD7032，KS0108，SED1520，SBN1661，IL3820，MAX7219（有关完整列表，请参见 此处）。<br>    可以说，基本上主流的显示控制器都支持，比如我们常见的SSD1306 12864，读者在使用该库之前请查阅自己的OLED显示控制器是否处于支持列表中。    </p><h2 id="U8g2支持的Arduino主板"><a href="#U8g2支持的Arduino主板" class="headerlink" title="U8g2支持的Arduino主板"></a>U8g2支持的Arduino主板</h2><p>    可以说基本上所有Arduino API的主板都得到U8g2的支持。包括：</p><p>Aruino Zero，Uno，Mega，Due，101，MKR Zero以及所有其他Arduino官方主板<br>基于Arduino平台的STM32<br>基于Arduino平台的ESP8266和ESP32<br>甚至其他不知名的基于Arduino平台的开发板</p><h2 id="U8g2如何在Arduino平台上安装"><a href="#U8g2如何在Arduino平台上安装" class="headerlink" title="U8g2如何在Arduino平台上安装"></a>U8g2如何在Arduino平台上安装</h2><p> Arduino库U8g2可以从Arduino IDE的库管理器安装，读者在库管理器搜索“U8g2”关键字就可以下载安装：<br> <br> <img src="/2020/05/09/U8G2详解/1588990435.png" alt=""><br> <br> 下载完毕，测试一下库是否安装成功： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// put your setup code here, to run once:</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// put your main code here, to run repeatedly:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成功，证明你本地已经加载了U8G2库。<br><img src="/2020/05/09/U8G2详解/1588990704.png" alt=""></p><blockquote><p><font color="red">重要知识点</font></p></blockquote><ul><li>像素点点阵<br>OLED其实就是一个M x n 的像素点阵，想显示什么就得把具体位置的像素点亮起来。对于每一个像素点，有可能是1点亮，也有可能是0点亮；</li><li>坐标系<br><img src="/2020/05/09/U8G2详解/1588990808.png" alt=""><br>在坐标系中，左上角是原点，向右是X轴，向下是Y轴。</li></ul><h2 id="U8g2优势"><a href="#U8g2优势" class="headerlink" title="U8g2优势"></a>U8g2优势</h2><ul><li>U8g2库平台支持性好，基本上支持绝大部分Arduino开发板，特别也博主比较喜欢的ESP8266；</li><li>U8g2库显示控制器支持性好，基本上市面上的OLED都完美支持；</li><li>U8g2库 API众多，特别支持了中文，支持了不同字体，这是一个对于开发者俩说不小的福利。</li></ul><h2 id="U8g2库函数详解"><a href="#U8g2库函数详解" class="headerlink" title="U8g2库函数详解"></a>U8g2库函数详解</h2><h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><h4 id="u8g2-begin-——-构造U8G2"><a href="#u8g2-begin-——-构造U8G2" class="headerlink" title="u8g2.begin() —— 构造U8G2"></a>u8g2.begin() —— 构造U8G2</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化U8g2库</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 initDisplay clearDisplay setPowerSave</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span> U8G2::begin(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>源码说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">begin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* note: call to u8x8_utf8_init is not required here, this is done in the setup procedures before */</span></span><br><span class="line">   initDisplay(); <span class="comment">//初始化显示器</span></span><br><span class="line">   clearDisplay();  <span class="comment">// 重置清屏</span></span><br><span class="line">   setPowerSave(<span class="number">0</span>); <span class="comment">//唤醒屏幕</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="u8g2-beginSimple-——-构造U8G2"><a href="#u8g2-beginSimple-——-构造U8G2" class="headerlink" title="u8g2.beginSimple() —— 构造U8G2"></a>u8g2.beginSimple() —— 构造U8G2</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单初始化U8g2库</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 beginSimple</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::beginSimple(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>源码说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beginSimple</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* does not clear the display and does not wake up the display */</span></span><br><span class="line"><span class="comment">/* user is responsible for calling clearDisplay() and setPowerSave(0) */</span></span><br><span class="line">   initDisplay();<span class="comment">//初始化显示器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong><br>可以看到和begin()函数的区别，需要用户自行控制初始化过程，给了一定的自由度，建议直接用begin函数。</p></blockquote><h4 id="u8g2-initDisplay-——-初始化显示控制器"><a href="#u8g2-initDisplay-——-初始化显示控制器" class="headerlink" title="u8g2.initDisplay() —— 初始化显示控制器"></a>u8g2.initDisplay() —— 初始化显示控制器</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化显示控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::initDisplay(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong><br>这个方法不需要单独调用，会在begin函数主动调用一次，在里面针对具体的OLED进行配置；</p></blockquote><h4 id="u8g2-clearDisplay-——-清除屏幕内容"><a href="#u8g2-clearDisplay-——-清除屏幕内容" class="headerlink" title="u8g2.clearDisplay() —— 清除屏幕内容"></a>u8g2.clearDisplay() —— 清除屏幕内容</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除屏幕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::clearDisplay(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong><br>这个方法无需单独调用，会在begin函数主动调用一次；<br>不要在 firstPage 和 nextPage 函数之间调用该方法；</p></blockquote><h4 id="u8g2-setPowerSave-——-是否开启省电模式"><a href="#u8g2-setPowerSave-——-是否开启省电模式" class="headerlink" title="u8g2.setPowerSave() —— 是否开启省电模式"></a>u8g2.setPowerSave() —— 是否开启省电模式</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除显示缓冲区</span></span><br><span class="line"><span class="comment"> * @param is_enable</span></span><br><span class="line"><span class="comment"> *        1 表示启用显示器的省电模式，屏幕上看不到任何东西</span></span><br><span class="line"><span class="comment"> *        0 表示禁用省电模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setPowerSave(<span class="keyword">uint8_t</span> is_enable)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>不管是启用还是禁用，显示器需要的内存消耗是不会变的，说到底就是为了关闭屏幕，做到省电；</li><li>所以这里就可以理解为什么初始化需要 setPowerSave(0);</li></ul><h4 id="u8g2-clear-——-清除操作"><a href="#u8g2-clear-——-清除操作" class="headerlink" title="u8g2.clear() —— 清除操作"></a>u8g2.clear() —— 清除操作</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除屏幕显示，清除缓冲区，光标回到左上角原点位置（0，0）</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 home clearDisplay clearBuffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::clear(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>源码说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; </span><br><span class="line">   home(); <span class="comment">//回到原点</span></span><br><span class="line">   clearDisplay(); <span class="comment">//清除屏幕上的显示</span></span><br><span class="line">   clearBuffer();  <span class="comment">//清除缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="u8g2-clearBuffer-——-清除缓冲区"><a href="#u8g2-clearBuffer-——-清除缓冲区" class="headerlink" title="u8g2.clearBuffer() —— 清除缓冲区"></a>u8g2.clearBuffer() —— 清除缓冲区</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除内存中数据缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::clearBuffer(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong><br>一般这个函数是与sendBuffer函数配对使用，通常用法如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.clearBuffer();</span><br><span class="line">  <span class="comment">// ... write something to the buffer </span></span><br><span class="line">  u8g2.sendBuffer();</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="u8g2-disableUTF8Print-——-禁用-UTF8打印"><a href="#u8g2-disableUTF8Print-——-禁用-UTF8打印" class="headerlink" title="u8g2.disableUTF8Print() —— 禁用 UTF8打印"></a>u8g2.disableUTF8Print() —— 禁用 UTF8打印</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 禁用Arduino平台下支持输出UTF8字符集，默认是开启</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::disableUTF8Print(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><h4 id="u8g2-enableUTF8Print-——-启用-UTF8打印"><a href="#u8g2-enableUTF8Print-——-启用-UTF8打印" class="headerlink" title="u8g2.enableUTF8Print() —— 启用 UTF8打印"></a>u8g2.enableUTF8Print() —— 启用 UTF8打印</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启Arduino平台下支持输出UTF8字符集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::enableUTF8Print(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>我们的中文字符就是UTF8；</p></li><li><p>常见例子</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.begin();</span><br><span class="line">  u8g2.enableUTF8Print();       <span class="comment">// enable UTF8 support for the Arduino print() function</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.setFont(u8g2_font_unifont_t_chinese2);  <span class="comment">// use chinese2 for all the glyphs of "你好世界"</span></span><br><span class="line">  u8g2.firstPage();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    u8g2.setCursor(<span class="number">0</span>, <span class="number">40</span>);</span><br><span class="line">    u8g2.print(<span class="string">"你好世界"</span>);     <span class="comment">// Chinese "Hello World" </span></span><br><span class="line">  &#125; <span class="keyword">while</span> ( u8g2.nextPage() );</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="u8g2-home-——-重置显示光标的位置"><a href="#u8g2-home-——-重置显示光标的位置" class="headerlink" title="u8g2.home() —— 重置显示光标的位置"></a>u8g2.home() —— 重置显示光标的位置</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重置显示光标的位置，回到原点（0，0）</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 print clear</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::home(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><h3 id="绘制相关函数"><a href="#绘制相关函数" class="headerlink" title="绘制相关函数"></a>绘制相关函数</h3><h4 id="u8g2-drawBox-——-画实心方形"><a href="#u8g2-drawBox-——-画实心方形" class="headerlink" title="u8g2.drawBox() —— 画实心方形"></a>u8g2.drawBox() —— 画实心方形</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画实心方形，左上角坐标为(x,y),宽度为w，高度为h</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param w 方形的宽度</span></span><br><span class="line"><span class="comment"> * @param h 方形的高度</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 drawFrame setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawBox(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w, <span class="keyword">u8g2_uint_t</span> h)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</p></li><li><p><strong>示例</strong>:</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawBox(<span class="number">3</span>,<span class="number">7</span>,<span class="number">25</span>,<span class="number">15</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawCircle-——-画空心圆"><a href="#u8g2-drawCircle-——-画空心圆" class="headerlink" title="u8g2.drawCircle() —— 画空心圆"></a>u8g2.drawCircle() —— 画空心圆</h4><ul><li><strong>函数说明</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画空心圆，圆心坐标为(x0,y0),半径为rad</span></span><br><span class="line"><span class="comment"> * @param x0 圆点的x坐标</span></span><br><span class="line"><span class="comment"> * @param y0 圆点的y坐标</span></span><br><span class="line"><span class="comment"> * @param rad 圆形的半径</span></span><br><span class="line"><span class="comment"> * @param opt 圆形选项</span></span><br><span class="line"><span class="comment"> *        U8G_DRAW_ALL 整个圆</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        选项可以通过 | 操作符来组合</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 drawDisc setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawCircle(<span class="keyword">u8g2_uint_t</span> x0, <span class="keyword">u8g2_uint_t</span> y0, <span class="keyword">u8g2_uint_t</span> rad, <span class="keyword">uint8_t</span> opt = U8G2_DRAW_ALL)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong><font color="red">注意点:</font></strong><br>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；<br>直径等于2rad + 1；</p></blockquote><ul><li><strong>示例</strong>:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawCircle(<span class="number">20</span>, <span class="number">25</span>, <span class="number">10</span>, U8G2_DRAW_ALL);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawDisc-——-画实心圆"><a href="#u8g2-drawDisc-——-画实心圆" class="headerlink" title="u8g2.drawDisc() —— 画实心圆"></a>u8g2.drawDisc() —— 画实心圆</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画实心圆，圆心坐标为(x0,y0),半径为rad</span></span><br><span class="line"><span class="comment"> * @param x0 圆点的x坐标</span></span><br><span class="line"><span class="comment"> * @param y0 圆点的y坐标</span></span><br><span class="line"><span class="comment"> * @param rad 圆形的半径</span></span><br><span class="line"><span class="comment"> * @param opt 圆形选项</span></span><br><span class="line"><span class="comment"> *        U8G_DRAW_ALL 整个圆</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧</span></span><br><span class="line"><span class="comment"> *       选项可以通过 | 操作符来组合</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 drawCircle setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawDisc(<span class="keyword">u8g2_uint_t</span> x0, <span class="keyword">u8g2_uint_t</span> y0, <span class="keyword">u8g2_uint_t</span> rad, <span class="keyword">uint8_t</span> opt = U8G_DRAW_ALL)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li><li>直径等于2rad + 1；</li></ul><h4 id="u8g2-drawEllipse-——-画空心椭圆"><a href="#u8g2-drawEllipse-——-画空心椭圆" class="headerlink" title="u8g2.drawEllipse() —— 画空心椭圆"></a>u8g2.drawEllipse() —— 画空心椭圆</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画空心椭圆，圆心坐标为(x0,y0),半径为rad</span></span><br><span class="line"><span class="comment"> * @param x0 圆点的x坐标</span></span><br><span class="line"><span class="comment"> * @param y0 圆点的y坐标</span></span><br><span class="line"><span class="comment"> * @param rx 椭圆形水平x方向的半径</span></span><br><span class="line"><span class="comment"> * @param ry 椭圆形竖直y方向的半径</span></span><br><span class="line"><span class="comment"> * @param opt 圆形选项</span></span><br><span class="line"><span class="comment"> *        U8G_DRAW_ALL 整个椭圆</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        选项可以通过 | 操作符来组合</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 drawCircle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawEllipse(<span class="keyword">u8g2_uint_t</span> x0, <span class="keyword">u8g2_uint_t</span> y0, <span class="keyword">u8g2_uint_t</span> rx, <span class="keyword">u8g2_uint_t</span> ry, <span class="keyword">uint8_t</span> opt)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>rx*ry 在8位模式的u8g2必须小于512</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawEllipse(<span class="number">20</span>, <span class="number">25</span>, <span class="number">15</span>, <span class="number">10</span>, U8G2_DRAW_ALL);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawFilledEllipse-——-画实心椭圆"><a href="#u8g2-drawFilledEllipse-——-画实心椭圆" class="headerlink" title="u8g2.drawFilledEllipse() —— 画实心椭圆"></a>u8g2.drawFilledEllipse() —— 画实心椭圆</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画实心椭圆，圆心坐标为(x0,y0),半径为rad</span></span><br><span class="line"><span class="comment"> * @param x0 圆点的x坐标</span></span><br><span class="line"><span class="comment"> * @param y0 圆点的y坐标</span></span><br><span class="line"><span class="comment"> * @param rx 椭圆形水平x方向的半径</span></span><br><span class="line"><span class="comment"> * @param ry 椭圆形竖直y方向的半径</span></span><br><span class="line"><span class="comment"> * @param opt 圆形选项</span></span><br><span class="line"><span class="comment"> *        U8G_DRAW_ALL 整个椭圆</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        选项可以通过 | 操作符来组合</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 drawCircle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawFilledEllipse(<span class="keyword">u8g2_uint_t</span> x0, <span class="keyword">u8g2_uint_t</span> y0, <span class="keyword">u8g2_uint_t</span> rx, <span class="keyword">u8g2_uint_t</span> ry, <span class="keyword">uint8_t</span> opt)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>rx*ry 在8位模式的u8g2必须小于512</li></ul><h4 id="u8g2-drawFrame-——-画空心方形"><a href="#u8g2-drawFrame-——-画空心方形" class="headerlink" title="u8g2.drawFrame() —— 画空心方形"></a>u8g2.drawFrame() —— 画空心方形</h4><ul><li><strong>函数说明</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画空心方形，左上角坐标为(x,y),宽度为w，高度为h</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param w 方形的宽度</span></span><br><span class="line"><span class="comment"> * @param h 方形的高度</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawFrame(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w, <span class="keyword">u8g2_uint_t</span> h)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawFrame(<span class="number">3</span>,<span class="number">7</span>,<span class="number">25</span>,<span class="number">15</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawGlyph-——-绘制字体字集的符号"><a href="#u8g2-drawGlyph-——-绘制字体字集的符号" class="headerlink" title="u8g2.drawGlyph() —— 绘制字体字集的符号"></a>u8g2.drawGlyph() —— 绘制字体字集的符号</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制字体字集里面定义的符号</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param encoding 字符的unicode值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setFont</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawGlyph(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">uint16_t</span> encoding)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>U8g2支持16位以内的unicode字符集，也就是说encoding的范围为0-65535，drawGlyph方法只能绘制存在于所使用的字体字集中的unicode值；</li><li>这个绘制方法依赖于当前的字体模式和绘制颜色；</li></ul><h4 id="u8g2-drawHLine-——-绘制水平线"><a href="#u8g2-drawHLine-——-绘制水平线" class="headerlink" title="u8g2.drawHLine() —— 绘制水平线"></a>u8g2.drawHLine() —— 绘制水平线</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制水平线</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param w 水平线的长度</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">void</span> U8G2::drawHLine(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li></ul><h4 id="u8g2-drawLine-——-两点之间绘制线"><a href="#u8g2-drawLine-——-两点之间绘制线" class="headerlink" title="u8g2.drawLine() —— 两点之间绘制线"></a>u8g2.drawLine() —— 两点之间绘制线</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制线，从坐标(x0,y0) 到(x1,y1)</span></span><br><span class="line"><span class="comment"> * @param x0 端点0的x坐标</span></span><br><span class="line"><span class="comment"> * @param y0 端点0的y坐标</span></span><br><span class="line"><span class="comment"> * @param x1 端点1的x坐标</span></span><br><span class="line"><span class="comment"> * @param y1 端点1的y坐标</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">void</span> U8G2::drawLine(<span class="keyword">u8g2_uint_t</span> x0, <span class="keyword">u8g2_uint_t</span> y0, <span class="keyword">u8g2_uint_t</span> x1, <span class="keyword">u8g2_uint_t</span> y1)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawLine(<span class="number">20</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">32</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawPixel-——-绘制像素点"><a href="#u8g2-drawPixel-——-绘制像素点" class="headerlink" title="u8g2.drawPixel() —— 绘制像素点"></a>u8g2.drawPixel() —— 绘制像素点</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制像素点，坐标(x,y)</span></span><br><span class="line"><span class="comment"> * @param x 像素点的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 像素点的y坐标</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawPixel(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li><li>你会发现很多绘制方法的底层都是调用drawPixel，毕竟像素属于最小颗粒度；</li><li>我们可以利用这个绘制方法自定义自己的图形显示；</li></ul><h4 id="u8g2-drawRBox-——-绘制圆角实心方形"><a href="#u8g2-drawRBox-——-绘制圆角实心方形" class="headerlink" title="u8g2.drawRBox() —— 绘制圆角实心方形"></a>u8g2.drawRBox() —— 绘制圆角实心方形</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制圆角实心方形，左上角坐标为(x,y),宽度为w，高度为h，圆角半径为r</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param w 方形的宽度</span></span><br><span class="line"><span class="comment"> * @param h 方形的高度</span></span><br><span class="line"><span class="comment"> * @param r 圆角半径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawRBox(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w, <span class="keyword">u8g2_uint_t</span> h, <span class="keyword">u8g2_uint_t</span> r)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li><li>要求，w &gt;= 2(r+1) 并且 h &gt;= 2(r+1)，这是显而易见的限制；</li></ul><h4 id="u8g2-drawRFrame-——-绘制圆角空心方形"><a href="#u8g2-drawRFrame-——-绘制圆角空心方形" class="headerlink" title="u8g2.drawRFrame() —— 绘制圆角空心方形"></a>u8g2.drawRFrame() —— 绘制圆角空心方形</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制圆角空心方形，左上角坐标为(x,y),宽度为w，高度为h，圆角半径为r</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param w 方形的宽度</span></span><br><span class="line"><span class="comment"> * @param h 方形的高度</span></span><br><span class="line"><span class="comment"> * @param r 圆角半径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawRFrame(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w, <span class="keyword">u8g2_uint_t</span> h, <span class="keyword">u8g2_uint_t</span> r)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong><br>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；<br>要求，w &gt;= 2(r+1) 并且 h &gt;= 2(r+1)，这是显而易见的限制</p></blockquote><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawRFrame(<span class="number">20</span>,<span class="number">15</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">7</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawStr-——-绘制字符串"><a href="#u8g2-drawStr-——-绘制字符串" class="headerlink" title="u8g2.drawStr() —— 绘制字符串"></a>u8g2.drawStr() —— 绘制字符串</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制字符串</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param s 绘制字符串内容</span></span><br><span class="line"><span class="comment"> * @return 字符串的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> U8g2::drawStr(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>需要先设置字体，调用setFont方法；</p></li><li><p>这个方法不能绘制encoding超过256的，超过256需要用drawUTF8或者drawGlyph；说白了就是一般用来显示英文字符；</p></li><li><p>x，y属于字符串左下角的坐标；</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">u8g2.drawStr(<span class="number">0</span>,<span class="number">15</span>,<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawTriangle-——-绘制实心三角形"><a href="#u8g2-drawTriangle-——-绘制实心三角形" class="headerlink" title="u8g2.drawTriangle() —— 绘制实心三角形"></a>u8g2.drawTriangle() —— 绘制实心三角形</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制实心三角形，定点坐标分别为(x0,y0),(x1,y1),(x2,y2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawTriangle(<span class="keyword">int16_t</span> x0, <span class="keyword">int16_t</span> y0, <span class="keyword">int16_t</span> x1, <span class="keyword">int16_t</span> y1, <span class="keyword">int16_t</span> x2, <span class="keyword">int16_t</span> y2)</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawTriangle(<span class="number">20</span>,<span class="number">5</span>, <span class="number">27</span>,<span class="number">50</span>, <span class="number">5</span>,<span class="number">32</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawUTF8-——-绘制UTF8编码的字符"><a href="#u8g2-drawUTF8-——-绘制UTF8编码的字符" class="headerlink" title="u8g2.drawUTF8() —— 绘制UTF8编码的字符"></a>u8g2.drawUTF8() —— 绘制UTF8编码的字符</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制UTF8编码的字符串</span></span><br><span class="line"><span class="comment"> * @param x 字符串在屏幕上的左下角x坐标</span></span><br><span class="line"><span class="comment"> * @param y 字符串在屏幕上的左下角y坐标</span></span><br><span class="line"><span class="comment"> * @param s 需要绘制的UTF-8编码字符串</span></span><br><span class="line"><span class="comment"> * @return 返回字符串的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> U8g2::drawUTF8(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>使用该方法，有两个前提。首先是你的编译器需要支持UTF-8编码，对于绝大部分Arduino板子已经支持；其次，显示的字符串需要存为“UTF-8”编码，Arduino IDE上默认支持；</p></li><li><p>该方法需要依赖于fontMode（setFont）以及drawing Color，也就是说如果你传进来的字符串编码必须在font定义里面；</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setFont(u8g2_font_unifont_t_symbols);</span><br><span class="line">u8g2.drawUTF8(<span class="number">5</span>, <span class="number">20</span>, <span class="string">"Snowman: ☃"</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawVLine-——-绘制竖直线"><a href="#u8g2-drawVLine-——-绘制竖直线" class="headerlink" title="u8g2.drawVLine() —— 绘制竖直线"></a>u8g2.drawVLine() —— 绘制竖直线</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制竖直线</span></span><br><span class="line"><span class="comment"> * @param x 左上角坐标x</span></span><br><span class="line"><span class="comment"> * @param y 左上角坐标y</span></span><br><span class="line"><span class="comment"> * @param h 高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawVLine(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> h)</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawXBM-drawXBMP-——-绘制图像"><a href="#u8g2-drawXBM-drawXBMP-——-绘制图像" class="headerlink" title="u8g2.drawXBM()/drawXBMP() —— 绘制图像"></a>u8g2.drawXBM()/drawXBMP() —— 绘制图像</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制图像</span></span><br><span class="line"><span class="comment"> * @param x 左上角坐标x</span></span><br><span class="line"><span class="comment"> * @param y 左上角坐标y</span></span><br><span class="line"><span class="comment"> * @param w 图形宽度</span></span><br><span class="line"><span class="comment"> * @param h 图形高度</span></span><br><span class="line"><span class="comment"> * @param bitmap 图形内容</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setBitmapMode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawXBM(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w, <span class="keyword">u8g2_uint_t</span> h, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *bitmap)</span><br><span class="line"><span class="keyword">void</span> U8G2::drawXBMP(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w, <span class="keyword">u8g2_uint_t</span> h, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *bitmap)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>drawXBM和drawXBMP区别在于 XBMP支持PROGMEM；</li></ul><h4 id="u8g2-firstPage-nextPage-——-绘制命令"><a href="#u8g2-firstPage-nextPage-——-绘制命令" class="headerlink" title="u8g2.firstPage()/nextPage() —— 绘制命令"></a>u8g2.firstPage()/nextPage() —— 绘制命令</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制图像</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::firstPage(<span class="keyword">void</span>)</span><br><span class="line"><span class="keyword">uint8_t</span> U8G2::nextPage(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>firstPage方法会把当前页码位置变成0；</p></li><li><p>修改内容处于firstPage和nextPage之间，每次都是重新渲染所有内容；</p></li><li><p><strong>优势点：</strong><br>该方法消耗的ram空间，比sendBuffer消耗的ram空间要少；</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u8g2.firstPage();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* all graphics commands have to appear within the loop body. */</span>    </span><br><span class="line">    u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">    u8g2.drawStr(<span class="number">0</span>,<span class="number">20</span>,<span class="string">"Hello World!"</span>);</span><br><span class="line">  &#125; <span class="keyword">while</span> ( u8g2.nextPage() );</span><br></pre></td></tr></table></figure><ul><li><strong>源码解析</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u8g2_FirstPage</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( u8g2-&gt;is_auto_page_clear )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//清除缓冲区</span></span><br><span class="line">    u8g2_ClearBuffer(u8g2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置当前缓冲区的Tile Row 一个Tile等于8个像素点的高度</span></span><br><span class="line">  u8g2_SetBufferCurrTileRow(u8g2, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">uint8_t</span> u8g2_NextPage(<span class="keyword">u8g2_t</span> *u8g2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> row;</span><br><span class="line">  u8g2_send_buffer(u8g2);</span><br><span class="line">  row = u8g2-&gt;tile_curr_row;</span><br><span class="line">  row += u8g2-&gt;tile_buf_height;</span><br><span class="line">  <span class="keyword">if</span> ( row &gt;= u8g2_GetU8x8(u8g2)-&gt;display_info-&gt;tile_height )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//如果row已经到达最后一行，触发refreshDisplay调用，表示整个页面已经刷完了</span></span><br><span class="line">    u8x8_RefreshDisplay( u8g2_GetU8x8(u8g2) );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( u8g2-&gt;is_auto_page_clear )</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//清除缓冲区</span></span><br><span class="line">    u8g2_ClearBuffer(u8g2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不断更新TileRow 这是非常关键的一步</span></span><br><span class="line">  u8g2_SetBufferCurrTileRow(u8g2, row);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="u8g2-print-——-绘制内容"><a href="#u8g2-print-——-绘制内容" class="headerlink" title="u8g2.print() —— 绘制内容"></a>u8g2.print() —— 绘制内容</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制内容</span></span><br><span class="line"><span class="comment"> * @Note 关联方法  setFont setCursor enableUTF8Print</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::print(...)</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">u8g2.setCursor(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">u8g2.print(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-sendBuffer-——-绘制缓冲区的内容"><a href="#u8g2-sendBuffer-——-绘制缓冲区的内容" class="headerlink" title="u8g2.sendBuffer() —— 绘制缓冲区的内容"></a>u8g2.sendBuffer() —— 绘制缓冲区的内容</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制缓冲区的内容</span></span><br><span class="line"><span class="comment"> * @Note 关联方法  clearBuffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::sendBuffer(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>sendBuffer的RAM占用空间大，需要结合构造器的buffer选项（请继续往下看，先有个概念）使用；</p></li><li><p>不管是fistPage、nextPage还是sendBuffer，都涉及到一个叫做 current page position的概念；</p></li><li><p><strong>源码解析</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u8g2_SendBuffer</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u8g2_send_buffer(u8g2);</span><br><span class="line">  u8x8_RefreshDisplay( u8g2_GetU8x8(u8g2) );  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u8g2_send_tile_row</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2, <span class="keyword">uint8_t</span> src_tile_row, <span class="keyword">uint8_t</span> dest_tile_row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> *ptr;</span><br><span class="line">  <span class="keyword">uint16_t</span> offset;</span><br><span class="line">  <span class="keyword">uint8_t</span> w;</span><br><span class="line">  </span><br><span class="line">  w = u8g2_GetU8x8(u8g2)-&gt;display_info-&gt;tile_width;</span><br><span class="line">  offset = src_tile_row;</span><br><span class="line">  ptr = u8g2-&gt;tile_buf_ptr;</span><br><span class="line">  offset *= w;</span><br><span class="line">  offset *= <span class="number">8</span>;</span><br><span class="line">  ptr += offset;</span><br><span class="line">  u8x8_DrawTile(u8g2_GetU8x8(u8g2), <span class="number">0</span>, dest_tile_row, w, ptr);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  write the buffer to the display RAM. </span></span><br><span class="line"><span class="comment">  For most displays, this will make the content visible to the user.</span></span><br><span class="line"><span class="comment">  Some displays (like the SSD1606) require a u8x8_RefreshDisplay()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u8g2_send_buffer</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2)</span> U8X8_NOINLINE</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u8g2_send_buffer</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> src_row;</span><br><span class="line">  <span class="keyword">uint8_t</span> src_max;</span><br><span class="line">  <span class="keyword">uint8_t</span> dest_row;</span><br><span class="line">  <span class="keyword">uint8_t</span> dest_max;</span><br><span class="line"> </span><br><span class="line">  src_row = <span class="number">0</span>;</span><br><span class="line">  src_max = u8g2-&gt;tile_buf_height;</span><br><span class="line">  dest_row = u8g2-&gt;tile_curr_row;</span><br><span class="line">  dest_max = u8g2_GetU8x8(u8g2)-&gt;display_info-&gt;tile_height;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    u8g2_send_tile_row(u8g2, src_row, dest_row);</span><br><span class="line">    src_row++;</span><br><span class="line">    dest_row++;</span><br><span class="line">  &#125; <span class="keyword">while</span>( src_row &lt; src_max &amp;&amp; dest_row &lt; dest_max );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.clearBuffer();</span><br><span class="line">  <span class="comment">// ... write something to the buffer </span></span><br><span class="line">  u8g2.sendBuffer();</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="显示配置相关函数"><a href="#显示配置相关函数" class="headerlink" title="显示配置相关函数"></a>显示配置相关函数</h3><h4 id="u8g2-getAscent-——-获取基准线以上的高度"><a href="#u8g2-getAscent-——-获取基准线以上的高度" class="headerlink" title="u8g2.getAscent() —— 获取基准线以上的高度"></a>u8g2.getAscent() —— 获取基准线以上的高度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取基准线以上的高度</span></span><br><span class="line"><span class="comment"> * @return 返回高度值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法  setFont getDescent setFontRefHeightAll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int8_t</span> U8G2::getAscent(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>跟字体有关（setFont）；</li></ul><h4 id="u8g2-getDescent-——-获取基准线以下的高度"><a href="#u8g2-getDescent-——-获取基准线以下的高度" class="headerlink" title="u8g2.getDescent() —— 获取基准线以下的高度"></a>u8g2.getDescent() —— 获取基准线以下的高度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取基准线以下的高度</span></span><br><span class="line"><span class="comment"> * @return 返回高度值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法  setFont setFontRefHeightAll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int8_t</span> U8G2::getDescent(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>跟字体有关（setFont）；</li></ul><h4 id="u8g2-getDisplayHeight-——-获取显示器的高度"><a href="#u8g2-getDisplayHeight-——-获取显示器的高度" class="headerlink" title="u8g2.getDisplayHeight() —— 获取显示器的高度"></a>u8g2.getDisplayHeight() —— 获取显示器的高度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取显示器的高度</span></span><br><span class="line"><span class="comment"> * @return 返回高度值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> getDisplayHeight(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><h4 id="u8g2-getDisplayWidth-——-获取显示器的宽度"><a href="#u8g2-getDisplayWidth-——-获取显示器的宽度" class="headerlink" title="u8g2.getDisplayWidth() —— 获取显示器的宽度"></a>u8g2.getDisplayWidth() —— 获取显示器的宽度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取显示器的宽度</span></span><br><span class="line"><span class="comment"> * @return 返回宽度值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> getDisplayWidth(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><h4 id="u8g2-getMaxCharHeight-——-获取当前字体里的最大字符的高度"><a href="#u8g2-getMaxCharHeight-——-获取当前字体里的最大字符的高度" class="headerlink" title="u8g2.getMaxCharHeight() —— 获取当前字体里的最大字符的高度"></a>u8g2.getMaxCharHeight() —— 获取当前字体里的最大字符的高度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前字体里的最大字符的高度</span></span><br><span class="line"><span class="comment"> * @return 返回高度值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setFont</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> getMaxCharHeight(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>每一个字符在font字集中都是一个位图，位图有高度和宽度；</li></ul><h4 id="u8g2-getMaxCharWidth-——-获取当前字体里的最大字符的宽度"><a href="#u8g2-getMaxCharWidth-——-获取当前字体里的最大字符的宽度" class="headerlink" title="u8g2.getMaxCharWidth() —— 获取当前字体里的最大字符的宽度"></a>u8g2.getMaxCharWidth() —— 获取当前字体里的最大字符的宽度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前字体里的最大字符的宽度</span></span><br><span class="line"><span class="comment"> * @return 返回宽度值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setFont</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> getMaxCharWidth(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>每一个字符在font字集中都是一个位图，位图有高度和宽度；</li></ul><h4 id="u8g2-getStrWidth-——-获取字符串的像素宽度"><a href="#u8g2-getStrWidth-——-获取字符串的像素宽度" class="headerlink" title="u8g2.getStrWidth() —— 获取字符串的像素宽度"></a>u8g2.getStrWidth() —— 获取字符串的像素宽度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取字符串的像素宽度</span></span><br><span class="line"><span class="comment"> * @param s 绘制字符串</span></span><br><span class="line"><span class="comment"> * @return 返回字符串的像素宽度值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setFont drawStr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> U8G2::getStrWidth(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>像素宽度和当前font字体有关；</li></ul><h4 id="u8g2-getUTF8Width-——-获取UTF-8字符串的像素宽度"><a href="#u8g2-getUTF8Width-——-获取UTF-8字符串的像素宽度" class="headerlink" title="u8g2.getUTF8Width() —— 获取UTF-8字符串的像素宽度"></a>u8g2.getUTF8Width() —— 获取UTF-8字符串的像素宽度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取UTF-8字符串的像素宽度</span></span><br><span class="line"><span class="comment"> * @param s 绘制字符串</span></span><br><span class="line"><span class="comment"> * @return 返回字符串的像素宽度值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setFont drawStr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> U8G2::getUTF8Width(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>像素宽度和当前font字体有关；</li></ul><h4 id="u8g2-setAutoPageClear-——-设置自动清除缓冲区"><a href="#u8g2-setAutoPageClear-——-设置自动清除缓冲区" class="headerlink" title="u8g2.setAutoPageClear() —— 设置自动清除缓冲区"></a>u8g2.setAutoPageClear() —— 设置自动清除缓冲区</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否自动清除缓冲区</span></span><br><span class="line"><span class="comment"> * @param mode 0 表示关闭</span></span><br><span class="line"><span class="comment"> *             1 表示开启，默认是开启</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setAutoPageClear(<span class="keyword">uint8_t</span> mode)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>该方法用于 firstPage 和 nextPage（看上面的源码解析）；</li><li>建议该方法保持默认就好，如果用户禁止了，那么需要自己维护缓冲区的状态或者手动调用clearBuffer；</li></ul><h4 id="u8g2-setBitmapMode-——-设置位图模式"><a href="#u8g2-setBitmapMode-——-设置位图模式" class="headerlink" title="u8g2.setBitmapMode() —— 设置位图模式"></a>u8g2.setBitmapMode() —— 设置位图模式</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置位图模式（定义drawXBM方法是否绘制背景颜色）</span></span><br><span class="line"><span class="comment"> * @param is_transparent</span></span><br><span class="line"><span class="comment"> *         0 绘制背景颜色，不透明，默认是该值</span></span><br><span class="line"><span class="comment"> *         1 不绘制背景颜色，透明</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 drawXBM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setBitmapMode(<span class="keyword">uint8_t</span> is_transparent)</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setDrawColor(<span class="number">1</span>);</span><br><span class="line">u8g2.setBitmapMode(<span class="number">0</span>);</span><br><span class="line">u8g2.drawXBM(<span class="number">4</span>,<span class="number">3</span>, u8g2_logo_97x51_width, u8g2_logo_97x51_height,  u8g2_logo_97x51_bits);</span><br><span class="line">u8g2.drawXBM(<span class="number">12</span>,<span class="number">11</span>, u8g2_logo_97x51_width, u8g2_logo_97x51_height,  u8g2_logo_97x51_bits);</span><br></pre></td></tr></table></figure><h4 id="u8g2-setBusClock-——-设置总线时钟"><a href="#u8g2-setBusClock-——-设置总线时钟" class="headerlink" title="u8g2.setBusClock() —— 设置总线时钟"></a>u8g2.setBusClock() —— 设置总线时钟</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置总线时钟(I2C SPI)</span></span><br><span class="line"><span class="comment"> * @param mode clock_speed 总线时钟频率(Hz)</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setBusClock(<span class="keyword">uint32_t</span> clock_speed);</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>仅仅Arduino平台支持；</li><li>必须在u8g2.begin() 或者 u8g2.initDisplay()之前调用；</li></ul><h4 id="u8g2-setClipWindow-——-设置采集窗口大小"><a href="#u8g2-setClipWindow-——-设置采集窗口大小" class="headerlink" title="u8g2.setClipWindow() —— 设置采集窗口大小"></a>u8g2.setClipWindow() —— 设置采集窗口大小</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置采集窗口，窗口范围从左上角(x0,y0)到右下角(x1,y1)</span></span><br><span class="line"><span class="comment"> * 也就是我们绘制的内容只能在规范范围内显示</span></span><br><span class="line"><span class="comment"> * @param x0 左上角x坐标</span></span><br><span class="line"><span class="comment"> * @param y0 左上角y坐标</span></span><br><span class="line"><span class="comment"> * @param x1 右上角x坐标</span></span><br><span class="line"><span class="comment"> * @param y1 右上角y坐标</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setClipWindow(<span class="keyword">u8g2_uint_t</span> x0, <span class="keyword">u8g2_uint_t</span> y0, <span class="keyword">u8g2_uint_t</span> x1, <span class="keyword">u8g2_uint_t</span> y1 );</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong><br>可以通过 setMaxClipWindow 去掉该限制</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> U8G2::setMaxClipWindow(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setClipWindow(<span class="number">10</span>, <span class="number">10</span>, <span class="number">85</span>, <span class="number">30</span>);</span><br><span class="line">u8g2.setDrawColor(<span class="number">1</span>);</span><br><span class="line">u8g2.drawStr(<span class="number">3</span>, <span class="number">32</span>, <span class="string">"U8g2"</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-setCursor-——-设置绘制光标位置"><a href="#u8g2-setCursor-——-设置绘制光标位置" class="headerlink" title="u8g2.setCursor() —— 设置绘制光标位置"></a>u8g2.setCursor() —— 设置绘制光标位置</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置绘制光标位置(x,y)</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 print</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setCursor(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y)</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">u8g2.setCursor(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">u8g2.print(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-setDisplayRotation-——-设置显示器的旋转角度"><a href="#u8g2-setDisplayRotation-——-设置显示器的旋转角度" class="headerlink" title="u8g2.setDisplayRotation() —— 设置显示器的旋转角度"></a>u8g2.setDisplayRotation() —— 设置显示器的旋转角度</h4><ul><li><strong>函数说明</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置显示器的旋转角度</span></span><br><span class="line"><span class="comment"> * @param u8g2_cb 旋转选项</span></span><br><span class="line"><span class="comment"> *        U8G2_R0 不做旋转 水平</span></span><br><span class="line"><span class="comment"> *        U8G2_R1 旋转90度</span></span><br><span class="line"><span class="comment"> *        U8G2_R2 旋转180度</span></span><br><span class="line"><span class="comment"> *        U8G2_R3 旋转270度</span></span><br><span class="line"><span class="comment"> *        U8G2_MIRROR 不做旋转 水平，显示内容是镜像的，暂时不理解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDisplayRotation</span><span class="params">(<span class="keyword">const</span> <span class="keyword">u8g2_cb_t</span> *u8g2_cb)</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="u8g2-setDrawColor-——-设置绘制颜色"><a href="#u8g2-setDrawColor-——-设置绘制颜色" class="headerlink" title="u8g2.setDrawColor() —— 设置绘制颜色"></a>u8g2.setDrawColor() —— 设置绘制颜色</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置绘制颜色（暂时还没有具体去了解用法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setDrawColor(<span class="keyword">uint8_t</span> color)</span><br></pre></td></tr></table></figure><h4 id="u8g2-setFont-——-设置字体集"><a href="#u8g2-setFont-——-设置字体集" class="headerlink" title="u8g2.setFont() —— 设置字体集"></a><font color="red">u8g2.setFont() —— 设置字体集</font></h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置字体集（字体集用于字符串绘制方法或者glyph绘制方法）</span></span><br><span class="line"><span class="comment"> * @param font 具体的字体集</span></span><br><span class="line"><span class="comment"> * @Note 关联方法  drawUTF8 drawStr drawGlyph print</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setFont(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *font)</span><br></pre></td></tr></table></figure><p>Font会根据像素点高度做了很多区分，具体font请参考 wiki。<br>如果我们需要用到中文字符，可以在wiki里面搜索一下chinese，你就会发现很多中文font，比如：</p><p>//支持UTF-8或者GB2312编码<br>u8g2_font_wqy15_t_chinese1<br>u8g2_font_wqy15_t_chinese2<br>u8g2_font_wqy15_t_chinese3<br>u8g2_font_wqy12_t_gb2312<br>u8g2_font_wqy12_t_gb2312a<br>……</p><blockquote><p><strong><font color="red">注意点:</font></strong><br>中文字符集消耗内存大，请谨慎使用，可以用在Arduino 101等ram空间比较大的板子上；</p></blockquote><p>Font的命名规则：</p><p><prefix> ‘<em>‘ <name> ‘</name></em>‘ <purpose> <char set=""><br>其中：</char></purpose></prefix></p><ul><li>prefix基本上都是 u8g2；</li><li>name 一般会挂钩上字符像素使用量，比如5X7</li><li>purpose</li></ul><table><thead><tr><th></th><th>描述</th></tr></thead><tbody><tr><td>t</td><td>Transparent font, Do not use a background color.</td></tr><tr><td>h</td><td>All glyphs have common height(所有的图形有通用的高度).</td></tr><tr><td>m</td><td>All glyphs have common height and width (monospace).</td></tr><tr><td>8</td><td>All glyphs fit into a 8x8 pixel box.</td></tr></tbody></table><ul><li>char set</li></ul><table><thead><tr><th></th><th>描述</th></tr></thead><tbody><tr><td>f</td><td>The font includes up to 256 glyphs.</td></tr><tr><td>r</td><td>Only glyphs on the range of the ASCII codes 32 to 127 are included in the font.</td></tr><tr><td>u</td><td>Only glyphs on the range of the ASCII codes 32 to 95 (uppercase chars) are included in the font.</td></tr><tr><td>n</td><td>Only numbers and extra glyphs for writing date and time strings are included in the font.</td></tr><tr><td>…</td><td>Other custom character list.</td></tr></tbody></table><blockquote><p><strong><font color="red">注意点:</font></strong><br>U8G2库提供的font非常多，博主也暂时消化不了太多。如果我们使用中文的话，就去看看中文font就好；</p></blockquote><blockquote><p><strong>示例字体</strong></p></blockquote><ul><li>u8g2_font_5x7_tr</li><li>u8g2_font_pressstart2p_8u</li></ul><h4 id="u8g2-setFontDirection-——-设置字体方向"><a href="#u8g2-setFontDirection-——-设置字体方向" class="headerlink" title="u8g2.setFontDirection() —— 设置字体方向"></a>u8g2.setFontDirection() —— 设置字体方向</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义字符串绘制或者图形绘制的方向</span></span><br><span class="line"><span class="comment"> * @param dir 方向</span></span><br><span class="line"><span class="comment"> * @param 关联方法 drawStr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setFontDirection(<span class="keyword">uint8_t</span> dir)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>dir参数</li></ul><table><thead><tr><th>Argument</th><th>String Rotation</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>0 degree</td><td>Left to right</td></tr><tr><td>1</td><td>90 degree</td><td>Top to down</td></tr><tr><td>2</td><td>180 degree</td><td>Right to left</td></tr><tr><td>3</td><td>270 degree</td><td>Down to top</td></tr></tbody></table><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setFont(u8g2_font_ncenB14_tf);</span><br><span class="line">u8g2.setFontDirection(<span class="number">0</span>);</span><br><span class="line">u8g2.drawStr(<span class="number">15</span>, <span class="number">20</span>, <span class="string">"Abc"</span>);</span><br><span class="line">u8g2.setFontDirection(<span class="number">1</span>);</span><br><span class="line">u8g2.drawStr(<span class="number">15</span>, <span class="number">20</span>, <span class="string">"Abc"</span>);</span><br></pre></td></tr></table></figure><h3 id="缓存相关函数"><a href="#缓存相关函数" class="headerlink" title="缓存相关函数"></a>缓存相关函数</h3><p>缓存相关函数，一般不会去操作，了解即可；</p><h4 id="u8g2-getBufferPtr-——-获取缓存空间的地址"><a href="#u8g2-getBufferPtr-——-获取缓存空间的地址" class="headerlink" title="u8g2.getBufferPtr() —— 获取缓存空间的地址"></a>u8g2.getBufferPtr() —— 获取缓存空间的地址</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓存空间的地址</span></span><br><span class="line"><span class="comment"> * @return 返回缓存空间起始地址</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 getBufferTileHeight, getBufferTileWidth, clearBuffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> *U8G2::getBufferPtr(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>缓存大小等于 8 * u8g2.getBufferTileHeight() * u8g2.getBufferTileWidth().</li></ul><h4 id="u8g2-getBufferTileHeight-——-获取缓冲区的Tile高度"><a href="#u8g2-getBufferTileHeight-——-获取缓冲区的Tile高度" class="headerlink" title="u8g2.getBufferTileHeight() —— 获取缓冲区的Tile高度"></a>u8g2.getBufferTileHeight() —— 获取缓冲区的Tile高度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区的Tile高度</span></span><br><span class="line"><span class="comment"> * @return 返回高度值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> U8G2::getBufferTileHeight(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>一个tile等于8个像素点.</li></ul><h4 id="u8g2-getBufferTileWidth-——-获取缓冲区的Tile宽度"><a href="#u8g2-getBufferTileWidth-——-获取缓冲区的Tile宽度" class="headerlink" title="u8g2.getBufferTileWidth() —— 获取缓冲区的Tile宽度"></a>u8g2.getBufferTileWidth() —— 获取缓冲区的Tile宽度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区的Tile宽度</span></span><br><span class="line"><span class="comment"> * @return 返回宽度值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> U8G2::getBufferTileWidth(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>一个tile等于8个像素点.</li></ul><h4 id="u8g2-getBufferCurrTileRow-——-获取缓冲区的当前Tile-row"><a href="#u8g2-getBufferCurrTileRow-——-获取缓冲区的当前Tile-row" class="headerlink" title="u8g2.getBufferCurrTileRow() —— 获取缓冲区的当前Tile row"></a>u8g2.getBufferCurrTileRow() —— 获取缓冲区的当前Tile row</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区的当前Tile row行数</span></span><br><span class="line"><span class="comment"> * @return 返回当前的tilerow</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> U8G2::getBufferCurrTileRow(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>这个方法跟我们上面说到的page position相关.</li></ul><h4 id="u8g2-setBufferCurrTileRow-——-设置缓冲区的当前Tile-row"><a href="#u8g2-setBufferCurrTileRow-——-设置缓冲区的当前Tile-row" class="headerlink" title="u8g2.setBufferCurrTileRow() —— 设置缓冲区的当前Tile row"></a>u8g2.setBufferCurrTileRow() —— 设置缓冲区的当前Tile row</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置缓冲区的当前Tile row</span></span><br><span class="line"><span class="comment"> * @param 当前的tilerow</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setBufferCurrTileRow(<span class="keyword">uint8_t</span>  row)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>在 firstPage/nextPage 循环时，由于底层调用了setBufferCurrTileRow，所以尽量不要自己手动调用该方法；</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setBufferCurrTileRow(<span class="number">0</span>);       <span class="comment">// let y=0 be the topmost row of the buffer</span></span><br><span class="line">u8g2.clearBuffer();</span><br><span class="line">u8g2.setFont(u8g2_font_helvB08_tr);</span><br><span class="line">u8g2.drawStr(<span class="number">2</span>, <span class="number">8</span>, <span class="string">"abcdefg"</span>);</span><br><span class="line"> </span><br><span class="line">u8g2.setBufferCurrTileRow(<span class="number">2</span>);   <span class="comment">// write the buffer to tile row 2 (y=16) on the display</span></span><br><span class="line">u8g2.sendBuffer();</span><br><span class="line">u8g2.setBufferCurrTileRow(<span class="number">4</span>);   <span class="comment">// write the same buffer to tile row 4 (y=32) on the display</span></span><br><span class="line">u8g2.sendBuffer();</span><br></pre></td></tr></table></figure><h2 id="如何运用U8G2库"><a href="#如何运用U8G2库" class="headerlink" title="如何运用U8G2库"></a>如何运用U8G2库</h2><p>构建具体的OLED驱动可分为以下几个顺序步骤：</p><ol><li>区分显示器</li><li>选择物理总线方式</li><li>区分数字连线</li><li>U8g2初始化</li><li>U8g2绘制模式</li></ol><h3 id="区分显示器"><a href="#区分显示器" class="headerlink" title="区分显示器"></a>区分显示器</h3><p>首先，你需要知道OLED显示器的控制器型号以及屏幕大小。举个例子，博主手上有一块SSD1306 128X64的OLED，那么它的控制器就是SSD1306，屏幕大小是128X64。<br>其次，你所选择的OLED必须在U8g2库所支持的OLED列表中，具体可参考<a href="https://github.com/olikraus/u8g2/wiki/u8g2setupcpp" target="_blank" rel="noopener">链接地址</a>。</p><h3 id="选择物理总线方式"><a href="#选择物理总线方式" class="headerlink" title="选择物理总线方式"></a>选择物理总线方式</h3><p> 图像信息是通过物理总线方式发给OLED显示器。通常，我们的总线包括：</p><ul><li>3SPI，3-wire SPI：串行外围接口，依靠三个控制信号，Clock、Data、CS；</li><li>4SPI, 4-Wire SPI，跟3SPI一样，只是额外多了一条数据命令线，经常叫做D/C;</li><li>I2C, IIC or TWI: SCL SDA;</li><li>8080:A 8-Bit bus which requires 8 data lines, chip select and a write strobe signa</li><li>6800: Another 8-Bit bus, but with a different protocol.<br>具体的OLED使用什么物理总线，需要查阅各自的数据手册。比如，SSD1306就是IIC。</li></ul><h3 id="区分数字连线"><a href="#区分数字连线" class="headerlink" title="区分数字连线"></a>区分数字连线</h3><p>知道了物理连线模式之后，我们一般都是把OLED连接到Arduino Board的输出引脚，也就是软件模拟具体总线协议。当然，如果有现成的物理总线端口那就更好了。</p><h3 id="U8g2初始化"><a href="#U8g2初始化" class="headerlink" title="U8g2初始化"></a>U8g2初始化</h3><p>经历以上三步之后，我们就可以开始初始化出具体的OLED驱动了。比如，博主的IIC SSD1306 128X64 的OLED，就可以用以下初始化构造器（Builder设计模式，有空可以去了解一下）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_1_SW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* clock=*/</span> SCL, <span class="comment">/* data=*/</span> SDA, <span class="comment">/* reset=*/</span> U8X8_PIN_NONE)</span></span>;   <span class="comment">// All Boards without Reset of the Display</span></span><br></pre></td></tr></table></figure><p>当然SSD1306还有其他构造器（具体可以参考<a href="https://github.com/olikraus/u8g2/wiki/u8g2setupcpp" target="_blank" rel="noopener">wiki</a>）：</p><table><thead><tr><th>Controller “ssd1306”</th><th>Display “128x64_noname”    Descirption</th></tr></thead><tbody><tr><td>U8G2_SSD1306_128X64_NONAME_1_4W_SW_SPI(rotation, clock, data, cs, dc [, reset])</td><td>page buffer, size = 128 bytes</td></tr><tr><td>U8G2_SSD1306_128X64_NONAME_2_4W_SW_SPI(rotation, clock, data, cs, dc [, reset])</td><td>page buffer, size = 256 bytes</td></tr><tr><td>U8G2_SSD1306_128X64_NONAME_F_4W_SW_SPI(rotation, clock, data, cs, dc [, reset])</td><td>full framebuffer, size = 1024 bytes</td></tr><tr><td>U8G2_SSD1306_128X64_NONAME_1_4W_HW_SPI(rotation, cs, dc [, reset])</td><td>page buffer, size = 128 bytes</td></tr></tbody></table><p> 那么，我们这里就需要重点讲述一下构造器的规则。<br> 构造器的名字包括以下几方面：</p><table><thead><tr><th>No</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>1</td><td>Prefix</td><td>U8G2</td></tr><tr><td>2</td><td>Display Controller</td><td>SSD1306</td></tr><tr><td>3</td><td>Display Name</td><td>128X64_NONAME</td></tr><tr><td>4</td><td>Buffer Size</td><td>1, 2 or F (full frame buffer)</td></tr><tr><td>5</td><td>Communication</td><td>4W_SW_SPI</td></tr></tbody></table><p>它们之间使用”_”连接起来。其中：</p><ul><li>BufferSize，缓存大小</li></ul><table><thead><tr><th>BufferSize</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>保持一页的缓冲区，用于firstPage/nextPage的PageMode.</td></tr><tr><td>2</td><td>保持两页的缓冲区，用于firstPage/nextPage的PageMode.</td></tr><tr><td>F</td><td>获取整个屏幕的缓冲区，ram消耗大，一般用在ram空间比较大的arduino板子.</td></tr></tbody></table><ul><li>Communication，通信协议</li></ul><p>| Communication     | Description |<br>| 4W_SW_SPI |    4-wire (clock, data, cs and dc) software emulated SPI |<br>| 4W_HW_SPI |    4-wire (clock, data, cs and dc) hardware SPI (based on Arduino SPI library) |<br>| 2ND_4W_HW_SPI |    If supported, second 4-wire hardware SPI (based on Arduino SPI library) |<br>| 3W_SW_SPI    | 3-wire (clock, data and cs) software emulated SPI |<br>| SW_I2C    | Software emulated I2C/TWI |<br>| HW_I2C    | Hardware I2C based on the Arduino Wire library |<br>| 2ND_HW_I2C    | If supported, use second hardware I2C (Arduino Wire lib) |<br>| 6800 |    8-bit parallel interface, 6800 protocol |<br>| 8080 |    8-bit parallel interface, 8080 protocol |</p><ul><li>Rotation （软件模拟总线前提下的构造器的第一个参数）</li></ul><p>| Rotation/Mirror |    Description |<br>| U8G2_R0    | No rotation, landscape |<br>| U8G2_R1    | 90 degree clockwise rotation |<br>| U8G2_R2    | 180 degree clockwise rotation |<br>| U8G2_R3    | 270 degree clockwise rotation |<br>| U8G2_MIRROR    | No rotation, landscape, display content is mirrored (v2.6.x) |</p><p>一个完整的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SPI.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Wire.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">U8G2_ST7920_128X64_1_SW_SPI <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="number">13</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.begin();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.firstPage();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">    u8g2.drawStr(<span class="number">0</span>,<span class="number">24</span>,<span class="string">"Hello World!"</span>);</span><br><span class="line">  &#125; <span class="keyword">while</span> ( u8g2.nextPage() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们来看看到底构造器里面做了什么操作？还是以博主使用的SSD1306 128X64为例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SSD1306 4线软件模拟SPI</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">U8G2_SSD1306_128X64_NONAME_1_4W_SW_SPI(.....)</span><br></pre></td></tr></table></figure><ul><li><strong>类定义：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SSD1306构造器，继承U8G2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">U8G2_SSD1306_128X64_NONAME_1_4W_SW_SPI</span> :</span> <span class="keyword">public</span> U8G2 &#123;</span><br><span class="line">  <span class="keyword">public</span>: U8G2_SSD1306_128X64_NONAME_1_4W_SW_SPI(<span class="keyword">const</span> <span class="keyword">u8g2_cb_t</span> *rotation, <span class="keyword">uint8_t</span> clock, <span class="keyword">uint8_t</span> data, <span class="keyword">uint8_t</span> cs, <span class="keyword">uint8_t</span> dc, <span class="keyword">uint8_t</span> reset = U8X8_PIN_NONE) : U8G2() &#123;</span><br><span class="line">    <span class="comment">//配置SSD1306</span></span><br><span class="line">    u8g2_Setup_ssd1306_128x64_noname_1(&amp;u8g2, rotation, u8x8_byte_arduino_4wire_sw_spi, u8x8_gpio_and_delay_arduino);</span><br><span class="line">    <span class="comment">//设置通信协议</span></span><br><span class="line">    u8x8_SetPin_4Wire_SW_SPI(getU8x8(), clock, data, cs, dc, reset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面代码看出，默认调用了父类U8G2的构造函数，我们看看它里面做了什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">U8G2</span> :</span> <span class="keyword">public</span> Print</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">u8g2_t</span> u8g2;</span><br><span class="line">    u8x8_char_cb cpp_next_cb; <span class="comment">/*  the cpp interface has its own decoding function for the Arduino print command */</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">u8g2_uint_t</span> tx, ty;</span><br><span class="line">  </span><br><span class="line">    U8G2(<span class="keyword">void</span>) &#123; </span><br><span class="line">          <span class="comment">//设置Arduino print函数的解码方法，这里是ASCII，当然也有UTF-8</span></span><br><span class="line">          cpp_next_cb = u8x8_ascii_next; </span><br><span class="line">          <span class="comment">//屏幕初始化</span></span><br><span class="line">          home(); </span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br></pre></td></tr></table></figure><ul><li>U8G2类构造函数主要是定义好解码方法以及初始化屏幕（包括重置原点）；</li></ul><p>    然后我们看看，u8g2_Setup_ssd1306_128x64_noname_1做了什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u8g2_Setup_ssd1306_128x64_noname_1</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2, <span class="keyword">const</span> <span class="keyword">u8g2_cb_t</span> *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> tile_buf_height;</span><br><span class="line">  <span class="comment">//定义好缓存空间 记住 这里是 1 page mode</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *buf;</span><br><span class="line">  <span class="comment">//配置屏幕</span></span><br><span class="line">  u8g2_SetupDisplay(u8g2, u8x8_d_ssd1306_128x64_noname, u8x8_cad_001, byte_cb, gpio_and_delay_cb);</span><br><span class="line">  <span class="comment">//生成buf 这里是128 bytes</span></span><br><span class="line">  buf = u8g2_m_16_8_1(&amp;tile_buf_height);</span><br><span class="line">  <span class="comment">//初始化buf</span></span><br><span class="line">  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*============================================*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This procedure is called after setting up the display (u8x8 structure).</span></span><br><span class="line"><span class="comment">  --&gt; This is the central init procedure for u8g2 object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u8g2_SetupBuffer</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2, <span class="keyword">uint8_t</span> *buf, <span class="keyword">uint8_t</span> tile_buf_height, u8g2_draw_ll_hvline_cb ll_hvline_cb, <span class="keyword">const</span> <span class="keyword">u8g2_cb_t</span> *u8g2_cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u8g2-&gt;font = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//u8g2-&gt;kerning = NULL;</span></span><br><span class="line">  <span class="comment">//u8g2-&gt;get_kerning_cb = u8g2_GetNullKerning;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//u8g2-&gt;ll_hvline = u8g2_ll_hvline_vertical_top_lsb;</span></span><br><span class="line">  u8g2-&gt;ll_hvline = ll_hvline_cb;</span><br><span class="line">  </span><br><span class="line">  u8g2-&gt;tile_buf_ptr = buf;</span><br><span class="line">  u8g2-&gt;tile_buf_height = tile_buf_height;</span><br><span class="line">  </span><br><span class="line">  u8g2-&gt;tile_curr_row = <span class="number">0</span>;<span class="comment">//页码 这是一个很重要的参数</span></span><br><span class="line">  </span><br><span class="line">  u8g2-&gt;font_decode.is_transparent = <span class="number">0</span>; <span class="comment">/* issue 443 */</span></span><br><span class="line">  u8g2-&gt;bitmap_transparency = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  u8g2-&gt;draw_color = <span class="number">1</span>;</span><br><span class="line">  u8g2-&gt;is_auto_page_clear = <span class="number">1</span>;<span class="comment">//自动清除</span></span><br><span class="line">  </span><br><span class="line">  u8g2-&gt;cb = u8g2_cb;</span><br><span class="line">  u8g2-&gt;cb-&gt;update_dimension(u8g2);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> U8G2_WITH_CLIP_WINDOW_SUPPORT</span></span><br><span class="line">  u8g2_SetMaxClipWindow(u8g2);      <span class="comment">/* assign a clip window and call the update() procedure */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  u8g2-&gt;cb-&gt;update_page_win(u8g2);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  u8g2_SetFontPosBaseline(u8g2);  <span class="comment">/* issue 195 */</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> U8G2_WITH_FONT_ROTATION  </span></span><br><span class="line">  u8g2-&gt;font_decode.dir = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以总结几点：</p><ul><li>配置初始化屏幕</li><li>配置初始化缓冲区</li></ul><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>上面讲解涉及到了绘制模式，请参考下一节；</li></ul><h3 id="U8g2绘制模式"><a href="#U8g2绘制模式" class="headerlink" title="U8g2绘制模式"></a>U8g2绘制模式</h3><h3 id="U8g2支持三种绘制模式："><a href="#U8g2支持三种绘制模式：" class="headerlink" title="U8g2支持三种绘制模式："></a>U8g2支持三种绘制模式：</h3><ul><li>Full screen buffer mode，全屏缓存模式</li><li>Page mode (This is the U8glib picture loop) 分页模式</li><li>U8x8, character only mode 仅仅支持普通字符</li></ul><h3 id="Full-screen-buffer-mode"><a href="#Full-screen-buffer-mode" class="headerlink" title="Full screen buffer mode"></a>Full screen buffer mode</h3><ul><li><strong>特点：</strong></li></ul><p>绘制速度快<br>所有的绘制方法都可以使用<br>需要大量的ram空间</p><ul><li><strong>构造器：</strong></li></ul><p>构造器必须带有F，比如：<br>U8G2_ST7920_128X64_F_SW_SPI(rotation, clock, data, cs [, reset])</p><ul><li><strong>用法：</strong></li></ul><ol><li>清除缓冲区 u8g2.clearBuffer()</li><li>操作一些绘制方法</li><li>发送缓冲区的内容到显示器 u8g2.sendBuffer().</li></ol><ul><li><strong>示例代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.begin();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.clearBuffer();</span><br><span class="line">  u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">  u8g2.drawStr(<span class="number">0</span>,<span class="number">20</span>,<span class="string">"Hello World!"</span>);</span><br><span class="line">  u8g2.sendBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Page-mode"><a href="#Page-mode" class="headerlink" title="Page mode"></a>Page mode</h3><ul><li><strong>特点：</strong></li></ul><p>绘制速度慢<br>所有的绘制方法都可以使用<br>需要少量的ram空间</p><ul><li><p><strong>构造器：</strong></p></li><li><p>构造器必须带有“1”或者2，比如：<br>U8G2_ST7920_128X64_ 1 _SW_SPI(rotation, clock, data, cs [, reset])</p></li><li><p><strong>用法：</strong></p></li></ul><ol><li>调用 u8g2.firstPage()</li><li>开始一个 do while 循环</li><li>在循环内部 操作一些绘制方法</li><li>不断判断 u8g2.nextPage()</li></ol><ul><li><strong>示例代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.begin();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.firstPage();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">    u8g2.drawStr(<span class="number">0</span>,<span class="number">24</span>,<span class="string">"Hello World!"</span>);</span><br><span class="line">  &#125; <span class="keyword">while</span> ( u8g2.nextPage() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="U8x8-character-mode"><a href="#U8x8-character-mode" class="headerlink" title="U8x8 character mode"></a>U8x8 character mode</h3><ul><li><p><strong>特点：</strong></p></li><li><p>绘制速度快</p></li><li><p>并不是对所有的显示器都有效</p></li><li><p>图形绘制不可用</p></li><li><p>不需要ram空间</p></li><li><p><strong>构造器：</strong></p></li><li><p>使用U8X8构造器，比如：<br>U8X8_ST7565_EA_DOGM128_4W_SW_SPI(clock, data, cs, dc [, reset])</p></li><li><p><strong>用法：</strong></p></li><li><p>所有绘制命令是直接把数据写到显示器</p></li><li><p><strong>示例代码</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8x8.begin();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8x8.setFont(u8x8_font_chroma48medium8_r);</span><br><span class="line">  u8x8.drawString(<span class="number">0</span>,<span class="number">1</span>,<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;U8g2简介&quot;&gt;&lt;a href=&quot;#U8g2简介&quot; class=&quot;headerlink&quot; title=&quot;U8g2简介&quot;&gt;&lt;/a&gt;U8g2简介&lt;/h2&gt;&lt;p&gt;U8g2是嵌入式设备的单色图形库，一句话简单明了。主要应用于嵌入式设备，包括我们常见的单片机。
    &lt;/p&gt;
    
    </summary>
    
    
      <category term="OLED" scheme="https://zhaolilong.com/tags/OLED/"/>
    
      <category term="API参考" scheme="https://zhaolilong.com/tags/API%E5%8F%82%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>NodeMCU使用OLED</title>
    <link href="https://zhaolilong.com/2020/05/09/NodeMCU%E4%BD%BF%E7%94%A8OLED/"/>
    <id>https://zhaolilong.com/2020/05/09/NodeMCU使用OLED/</id>
    <published>2020-05-09T01:08:58.000Z</published>
    <updated>2020-05-09T07:28:43.547Z</updated>
    
    <content type="html"><![CDATA[<p>硬件准备：</p><ol><li><p>NodeMCU</p></li><li><p>I2c-12864-oled液晶屏模块 0.96寸 （12864就是128*64点阵的屏幕，所以叫12864！）<br><img src="/2020/05/09/NodeMCU使用OLED/1588986804.jpg" alt=""></p></li><li><p>母对母杜邦线4根</p></li><li><p>microUSB口-用来连接ESP8266</p></li></ol><p>软件准备：<br>Win：<a href="https://github.com/nodemcu/nodemcu-flasher/tree/master/Win64/Release" target="_blank" rel="noopener">https://github.com/nodemcu/nodemcu-flasher/tree/master/Win64/Release</a><br>Mac：<a href="https://github.com/marcelstoer/nodemcu-pyflasher/releases" target="_blank" rel="noopener">https://github.com/marcelstoer/nodemcu-pyflasher/releases</a></p><a id="more"></a><h2 id="给NodeMCU刷入固件"><a href="#给NodeMCU刷入固件" class="headerlink" title="给NodeMCU刷入固件"></a>给NodeMCU刷入固件</h2><ol><li>在nodemcu官网<a href="https://nodemcu-build.com/中下载固件" target="_blank" rel="noopener">https://nodemcu-build.com/中下载固件</a></li></ol><table><thead><tr><th>基本信息</th><th>参数</th></tr></thead><tbody><tr><td>驱动电压</td><td>3.3~5V</td></tr><tr><td>分辨率</td><td>128x64</td></tr><tr><td>驱动接口</td><td>I2C</td></tr><tr><td>I2C地址</td><td>0x3c(默认)\0x3d可选</td></tr></tbody></table><p><img src="/2020/05/09/NodeMCU使用OLED/1588987148.png" alt=""><br>构建模块中勾选I2C和U8G2。<br>字体需要勾选中文，默认不支持中文字体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u8g2_font_wqy15_t_chinese1</span><br><span class="line">u8g2_font_wqy15_t_chinese2</span><br><span class="line">u8g2_font_wqy15_t_chinese3</span><br></pre></td></tr></table></figure><p><img src="/2020/05/09/NodeMCU使用OLED/1588987612.png" alt=""><br><img src="/2020/05/09/NodeMCU使用OLED/1588988007.png" alt=""></p><p>在邮箱中查看<br><img src="/2020/05/09/NodeMCU使用OLED/1588988246.png" alt=""></p><p>一般下载integer的固件</p><h2 id="用ESPFlashDownloadTool写入固件"><a href="#用ESPFlashDownloadTool写入固件" class="headerlink" title="用ESPFlashDownloadTool写入固件"></a>用ESPFlashDownloadTool写入固件</h2><h2 id="按照接线图进行接线"><a href="#按照接线图进行接线" class="headerlink" title="按照接线图进行接线"></a>按照接线图进行接线</h2><p><img src="/2020/05/09/NodeMCU使用OLED/1588988622.png" alt=""></p><table><thead><tr><th>NodeMCU</th><th>OLED</th></tr></thead><tbody><tr><td>D5</td><td>SDA</td></tr><tr><td>D6</td><td>SCL</td></tr><tr><td>GND</td><td>GND</td></tr><tr><td>3V</td><td>VCC</td></tr></tbody></table><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//"hello world" test</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.begin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.clearBuffer();                   <span class="comment">// clear the internal memory</span></span><br><span class="line">  u8g2.setFont(u8g2_font_ncenB14_tr);   <span class="comment">// choose a suitable font</span></span><br><span class="line">  u8g2.drawStr(<span class="number">0</span>,<span class="number">20</span>,<span class="string">"Hello World!"</span>);    <span class="comment">// write something to the internal memory</span></span><br><span class="line">  u8g2.sendBuffer();                    <span class="comment">// transfer internal memory to the display</span></span><br><span class="line">  delay(<span class="number">1000</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;硬件准备：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;NodeMCU&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I2c-12864-oled液晶屏模块 0.96寸 （12864就是128*64点阵的屏幕，所以叫12864！）&lt;br&gt;&lt;img src=&quot;/2020/05/09/NodeMCU使用OLED/1588986804.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;母对母杜邦线4根&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;microUSB口-用来连接ESP8266&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;软件准备：&lt;br&gt;Win：&lt;a href=&quot;https://github.com/nodemcu/nodemcu-flasher/tree/master/Win64/Release&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/nodemcu/nodemcu-flasher/tree/master/Win64/Release&lt;/a&gt;&lt;br&gt;Mac：&lt;a href=&quot;https://github.com/marcelstoer/nodemcu-pyflasher/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/marcelstoer/nodemcu-pyflasher/releases&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeMCU" scheme="https://zhaolilong.com/tags/NodeMCU/"/>
    
      <category term="OLED" scheme="https://zhaolilong.com/tags/OLED/"/>
    
  </entry>
  
  <entry>
    <title>Linux查找并终止指定进程</title>
    <link href="https://zhaolilong.com/2020/04/29/Linux%E6%9F%A5%E6%89%BE%E5%B9%B6%E7%BB%88%E6%AD%A2%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>https://zhaolilong.com/2020/04/29/Linux查找并终止指定进程/</id>
    <published>2020-04-29T02:28:23.000Z</published>
    <updated>2020-04-29T02:29:05.546Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps -ef | grep  php | grep -v ‘grep’ | awk ‘{print $2}’| xargs kill -9</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps -ef | grep  php | grep -v ‘grep’ | awk ‘{print $2}’| xargs kill -9&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阿里云ECS中的CentOS7变为只读的解决方法</title>
    <link href="https://zhaolilong.com/2020/04/29/%E9%98%BF%E9%87%8C%E4%BA%91ECS%E4%B8%AD%E7%9A%84CentOS7%E5%8F%98%E4%B8%BA%E5%8F%AA%E8%AF%BB%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://zhaolilong.com/2020/04/29/阿里云ECS中的CentOS7变为只读的解决方法/</id>
    <published>2020-04-29T01:34:24.000Z</published>
    <updated>2020-04-29T03:05:31.274Z</updated>
    
    <content type="html"><![CDATA[<p>升级阿里云ECS配置及带宽后，CentOS 7系统变为只读状态，导致nginx、MySQL等服务无法启动。</p><a id="more"></a><p>解决方案如下：</p><ul><li>在终端中输入mount，查看ro挂载的分区,如果发现有ro，就重新mount</li></ul><ol><li><p>mount方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/sda1</span><br><span class="line">mount /dev/sda1 /boot</span><br><span class="line">如果发现有提示“device is busy”，找到是什么进程使得他busy</span><br><span class="line">fuser -m /boot 将会显示使用这个模块的pid</span><br><span class="line">fuser -mk /boot 将会直接kill那个pid</span><br><span class="line">然后重新mount即可。</span><br></pre></td></tr></table></figure></li><li><p>remount方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -o rw,remount /boot</span><br><span class="line">或者mount -o remount,rw /boot</span><br></pre></td></tr></table></figure></li><li><p>重启</p></li><li><p>使用用 fsck – y /dev/hdc6 (/dev/hdc6指你需要修复的分区) 来修复文件系统</p></li><li><p>查看文件系统状态/etc/fstab发现里面是空的，于是找到了两种解决方案：</p></li><li><p>重新挂载系统<br>#mount -o remount,rw /                            //这样每次重新开启虚拟机都要运行一次该命令！</p></li><li><p>将fstab写入正确内容<br><code>cat /etc/fstab</code></p><p>#</p><h1 id="etc-fstab"><a href="#etc-fstab" class="headerlink" title="/etc/fstab"></a>/etc/fstab</h1><h1 id="Created-by-anaconda-on-Sun-Oct-15-15-19-00-2017"><a href="#Created-by-anaconda-on-Sun-Oct-15-15-19-00-2017" class="headerlink" title="Created by anaconda on Sun Oct 15 15:19:00 2017"></a>Created by anaconda on Sun Oct 15 15:19:00 2017</h1><p>#</p><h1 id="Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’"><a href="#Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’" class="headerlink" title="Accessible filesystems, by reference, are maintained under ‘/dev/disk’"></a>Accessible filesystems, by reference, are maintained under ‘/dev/disk’</h1><h1 id="See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info"><a href="#See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info" class="headerlink" title="See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info"></a>See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</h1><p>#<br>UUID=00e25cc9-6880-442b-b430-62bb8061394d /                       ext4    defaults        1 1<br>/www/swap    swap    swap    defaults    0 0</p></li></ol><p><code>lsblk -f</code></p><p>NAME   FSTYPE LABEL UUID                                 MOUNTPOINT<br>vda<br>└─vda1 ext4         eb448abb-3012-4d8d-bcde-94434d586a31 /</p><p>fstab实际挂载点与打印的挂载点不一致，则修改/etc/fstabw文件中的挂载点为打印挂载点.</p><p>重启即可！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级阿里云ECS配置及带宽后，CentOS 7系统变为只读状态，导致nginx、MySQL等服务无法启动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="阿里云ECS" scheme="https://zhaolilong.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91ECS/"/>
    
      <category term="Linux" scheme="https://zhaolilong.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>实例学习Metal-参考书目</title>
    <link href="https://zhaolilong.com/2020/04/12/%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0Metal-%E5%8F%82%E8%80%83%E4%B9%A6%E7%9B%AE/"/>
    <id>https://zhaolilong.com/2020/04/12/实例学习Metal-参考书目/</id>
    <published>2020-04-11T16:00:00.000Z</published>
    <updated>2020-03-13T04:56:02.207Z</updated>
    
    <content type="html"><![CDATA[<p>Barrett, Sean. 2014. “stb Single-File Public Domain Libraries for C/C++.” <a href="https://github" target="_blank" rel="noopener">https://github</a>. com/nothings/stb.<br><br><br>Blinn, James F. 1977. “Models of Light Reflection for Computer Synthesized Pictures.” In Proceedings of the 4th Annual Conference on Computer Graphics and Interactive Techniques, 192–98. SIGGRAPH ’77. New York, NY, USA: ACM. doi:10.1145/563858.563893.<br><br></p><a id="more"></a><p>Barrett, Sean. 2014. “stb Single-File Public Domain Libraries for C/C++.” <a href="https://github" target="_blank" rel="noopener">https://github</a>. com/nothings/stb.<br><br><br>Blinn, James F. 1977. “Models of Light Reflection for Computer Synthesized Pictures.” In Proceedings of the 4th Annual Conference on Computer Graphics and Interactive Techniques, 192–98. SIGGRAPH ’77. New York, NY, USA: ACM. doi:10.1145/563858.563893.<br><br><br>Boxley, Paul. 2011. “Terrain Generation with the Diamond Square Algorithm.” http: //<a href="http://www.paulboxley.com/blog/2011/03/terrain-generation-mark-one" target="_blank" rel="noopener">www.paulboxley.com/blog/2011/03/terrain-generation-mark-one</a>.<br><br><br>Carpenter, Loren. 1984. “The A-Buffer, an Antialiased Hidden Surface Method.” In Pro- ceedings of the 11th Annual Conference on Computer Graphics and Interactive Techniques, 103–8. SIGGRAPH ’84. New York, NY, USA: ACM. doi:10.1145/800031.808585.<br><br><br>Esfahbod, Behdad. 2014. “GLyphy.” <a href="https://github.com/behdad/glyphy" target="_blank" rel="noopener">https://github.com/behdad/glyphy</a>.<br><br><br>Giesen, Fabien. 2011. “A Trip Through the Graphics Pipeline 2011, Part 7,” July. https:// fgiesen.wordpress.com/2011/07/08/a-trip-through-the-graphics-pipeline-2011-part-7/.<br><br><br>Glassner, Andrew. 2015. “Interpreting Alpha.” Journal of Computer Graphics Techniques (JCGT) 4 (2): 30–44. <a href="http://jcgt.org/published/0004/02/03/" target="_blank" rel="noopener">http://jcgt.org/published/0004/02/03/</a>.<br><br><br>Gortler, Steven J. 2012. Foundations of 3D Computer Graphics. The MIT Press.<br><br><br>Green, Chris. 2007. “Improved Alpha-Tested Magnification for Vector Textures and Spe- cial Effects.” In ACM SIGGRAPH 2007 Courses, 9–18. SIGGRAPH ’07. New York, NY, USA: ACM. doi:10.1145/1281500.1281665.<br><br><br>Grevera, George J. 2004. “The ‘Dead Reckoning’ Signed Distance Transform.” Com- put. Vis. Image Underst. 95 (3). New York, NY, USA: Elsevier Science Inc.: 317–33. doi:10.1016/j.cviu.2004.05.002.<br><br><br>Gustavson, Stefan. 2012. “2D Shape Rendering by Distance Fields.” In OpenGL Insights, edited by Patrick Cozzi and Christophe Riccio, 173–82. CRC Press.<br><br><br>Hughes, J.F., A. Van Dam, J.D. Foley, and S.K. Feiner. 2013. Computer Graphics: Principles<br>and Practice. 3rd ed. Addison-Wesley.<br><br><br>International Telecom Union. 2011. RECOMMENDATION ITU-R BT.601-7. https://<br><a href="http://www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.601-7-201103-I!!PDF-E.pdf" target="_blank" rel="noopener">www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.601-7-201103-I!!PDF-E.pdf</a>.<br><br><br>Jargstorff, Frank. 2004. “A Framework for Image Processing.” In GPU Gems, edited by Randima Fernando. Addison-Wesley Professional. <a href="http://http.developer.nvidia.com/" target="_blank" rel="noopener">http://http.developer.nvidia.com/</a> GPUGems/gpugems_ch27.html.<br><br><br>Khronos Group. 2013. “KTX File Format Specification.” Edited by Mark Callow, Georg Kolling, and Jacob Ström. <a href="https://www.khronos.org/opengles/sdk/tools/KTX/file" target="_blank" rel="noopener">https://www.khronos.org/opengles/sdk/tools/KTX/file</a>_ format_spec/.<br><br><br>Lengyel, Eric. 2011. Mathematics for 3D Game Programming and Computer Graphics. 3rd ed. Boston, MA, United States: Course Technology Press.<br><br><br>McGuire, Morgan, and Louis Bavoil. 2013. “Weighted Blended Order-Independent Transparency.” Journal of Computer Graphics Techniques (JCGT) 2 (2): 122–41. <a href="http://jcgt" target="_blank" rel="noopener">http://jcgt</a>. org/published/0002/02/09/.<br><br><br>Miller, Gavin S P. 1986. “The Definition and Rendering of Terrain Maps.” In Proceedings of the 13th Annual Conference on Computer Graphics and Interactive Techniques, 39–48. SIG- GRAPH ’86. New York, NY, USA: ACM. doi:10.1145/15922.15890.<br><br><br>Wavefront Technologies. 1991. “Appendix B1. Object Files.” In Programmer’s Reference Manual for the Advanced Visualizer. <a href="http://www.cs.utah.edu/~boulos/cs3505/obj_spec" target="_blank" rel="noopener">http://www.cs.utah.edu/~boulos/cs3505/obj_spec</a>. pdf.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Barrett, Sean. 2014. “stb Single-File Public Domain Libraries for C/C++.” &lt;a href=&quot;https://github&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github&lt;/a&gt;. com/nothings/stb.&lt;br&gt;&lt;br&gt;&lt;br&gt;Blinn, James F. 1977. “Models of Light Reflection for Computer Synthesized Pictures.” In Proceedings of the 4th Annual Conference on Computer Graphics and Interactive Techniques, 192–98. SIGGRAPH ’77. New York, NY, USA: ACM. doi:10.1145/563858.563893.&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS/Mac" scheme="https://zhaolilong.com/tags/iOS-Mac/"/>
    
      <category term="图形学" scheme="https://zhaolilong.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Metal" scheme="https://zhaolilong.com/tags/Metal/"/>
    
  </entry>
  
  <entry>
    <title>实例学习Metal-第十四章 图像处理基础</title>
    <link href="https://zhaolilong.com/2020/04/05/%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0Metal-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/"/>
    <id>https://zhaolilong.com/2020/04/05/实例学习Metal-第十四章/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2020-03-13T04:42:40.214Z</updated>
    
    <content type="html"><![CDATA[<p>在本章中，我们将开始使用Metal着色语言探索图像处理世界。我们将创建一个能够表示图像滤镜链的框架，然后编写一对图像滤镜，以便我们调整图像的饱和度和模糊度。最终结果将是一个交互式应用程序，允许您实时控制图像过滤器参数。</p><p>图像处理是数据并行编程的主要应用之一。在许多情况下，图像滤波器仅需要查询源图像中的一个像素或小邻域像素以计算每个输出像素的值。在这种情况下，图像滤波器的工作可以以并行方式完成。这非常适合现代GPU架构，它使用许多小内核同时处理多个数据。</p><a id="more"></a><h1 id="Chapter-14-第十四章"><a href="#Chapter-14-第十四章" class="headerlink" title="Chapter 14(第十四章)"></a>Chapter 14(第十四章)</h1><h2 id="Fundamentals-of-Image-Processing-图像处理基础"><a href="#Fundamentals-of-Image-Processing-图像处理基础" class="headerlink" title="Fundamentals of Image Processing(图像处理基础)"></a>Fundamentals of Image Processing(图像处理基础)</h2><p>在本章中，我们将开始使用Metal着色语言探索图像处理世界。我们将创建一个能够表示图像滤镜链的框架，然后编写一对图像滤镜，以便我们调整图像的饱和度和模糊度。最终结果将是一个交互式应用程序，允许您实时控制图像过滤器参数。</p><p>图像处理是数据并行编程的主要应用之一。在许多情况下，图像滤波器仅需要查询源图像中的一个像素或小邻域像素以计算每个输出像素的值。在这种情况下，图像滤波器的工作可以以并行方式完成。这非常适合现代GPU架构，它使用许多小内核同时处理多个数据。</p><h3 id="A-Look-Ahead-展望未来"><a href="#A-Look-Ahead-展望未来" class="headerlink" title="A Look Ahead(展望未来)"></a>A Look Ahead(展望未来)</h3><p>为了进一步激励本章，这里是示例项目的一个片段。它说明了如何简洁地创建并将由可动态调整的用户界面控制的去饱和度和模糊过滤器链接在一起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context = [MBEContext newContext]; </span><br><span class="line">imageProvider = [MBEMainBundleTextureProvider textureProviderWithImageNamed:@&quot;mandrill&quot; context:context];</span><br><span class="line">desaturateFilter = [MBESaturationAdjustmentFilter filterWithSaturationFactor:0.75</span><br><span class="line">context:context];</span><br><span class="line">desaturateFilter.provider = self.imageProvider; </span><br><span class="line">blurFilter = [MBEGaussianBlur2DFilter filterWithRadius:0.0 context:context];</span><br><span class="line">blurFilter.provider = desaturateFilter;</span><br><span class="line">imageView.image = [UIImage imageWithMTLTexture:blurFilter.texture];</span><br></pre></td></tr></table></figure><p><img src="/2020/04/05/实例学习Metal-第十四章/1584068924.png" alt=""></p><center>图14.1：示例应用程序UI，允许实时过滤器调整。</center><h3 id="A-Framework-for-Image-Processing-图像处理框架"><a href="#A-Framework-for-Image-Processing-图像处理框架" class="headerlink" title="A Framework for Image Processing(图像处理框架)"></a>A Framework for Image Processing(图像处理框架)</h3><p>现在我们已经了解了我们希望图像处理框架的界面看起来像什么，我们可以讨论构建这样一个框架的实用性。该框架的大部分架构都受到（Jargstorff 2004）的启发。</p><h4 id="Texture-Providers-and-Consumers-纹理提供者和消费者"><a href="#Texture-Providers-and-Consumers-纹理提供者和消费者" class="headerlink" title="Texture Providers and Consumers(纹理提供者和消费者)"></a>Texture Providers and Consumers(纹理提供者和消费者)</h4><p>每个过滤器都能够使用其输入和输出纹理配置其计算管道并执行其内核功能。</p><p>由于我们将以纹理的形式对图像进行操作，因此我们需要一种抽象的方式来引用生成和使用纹理的对象。例如，过滤器使用和生成纹理，我们还需要一个用于从中生成纹理的类应用程序包。</p><p>我们使用名为<code>MBETextureProvider</code>的协议来抽象纹理生成的概念：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MBETextureProvider</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;<span class="built_in">MTLTexture</span>&gt; texture; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这个简单的界面为我们提供了一种(同步)从纹理提供者请求纹理的方法。它可能导致图像过滤器执行其过滤过程，或从磁盘加载图像。重要的是，我们知道我们可以从任何符合<code>MBETextureProvider</code>的对象中检索纹理。</p><p>另一方面，<code>MBETextureConsumer</code>协议允许我们告诉对象它应该从哪个纹理提供者使用纹理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MBETextureConsumer</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;MBETextureProvider&gt; provider; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这个简单的接口为我们提供了一种（同步）从纹理提供者请求纹理的方式。它可能导致图像过滤器执行其过滤过程，或从磁盘加载图像。重要的是，我们知道我们可以从任何符合<code>MBETextureProvider</code>的对象中检索纹理。</p><p>另一方面，<code>MBETextureConsumer</code>协议允许我们告诉对象它应该从哪个纹理提供者使用纹理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@protocol MBETextureConsumer &lt;NSObject&gt;</span><br><span class="line">@property (nonatomic, strong) id&lt;MBETextureProvider&gt; provider; </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>当纹理使用者想要对纹理进行操作时，它会从其提供者请求纹理并对其进行操作。</p><h4 id="An-Image-Filter-Base-Class-图像过滤器基类"><a href="#An-Image-Filter-Base-Class-图像过滤器基类" class="headerlink" title="An Image Filter Base Class(图像过滤器基类)"></a>An Image Filter Base Class(图像过滤器基类)</h4><p>抽象地，图像滤波器通过对其进行任意操作将一个纹理转换为另一个纹理。我们的MBEImageFilter类完成了调用计算着色器以从另一个生成一个纹理所需的大量工作。</p><p>图像过滤器基类符合刚才讨论的纹理提供者和纹理消费者协议。让过滤器表现为纹理提供者和纹理消费者都允许我们将过滤器链接在一起以按顺序执行多个操作。由于图像上下文管理的命令队列的串行特性，因此可以保证每个过滤器在允许其后继执行之前完成其工作。</p><p>这是MBEImageFilter类接口的相关部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface MBEImageFilter : NSObject &lt;MBETextureProvider, MBETextureConsumer&gt; @property (nonatomic, strong) MBEContext *context;</span><br><span class="line">@property (nonatomic, strong) id&lt;MTLComputePipelineState&gt; pipeline; @property (nonatomic, strong) id&lt;MTLTexture&gt; internalTexture;</span><br><span class="line">@property (nonatomic, assign, getter=isDirty) BOOL dirty;</span><br><span class="line">- (instancetype)initWithFunctionName:(NSString *)functionName</span><br><span class="line">context:(MBEContext *)context;</span><br><span class="line">- (void)configureArgumentTableWithCommandEncoder: (id&lt;MTLComputeCommandEncoder&gt;)commandEncoder;</span><br></pre></td></tr></table></figure><p>必须使用函数名称和上下文来实例化过滤器。这些用于创建计算管道状态，然后将其存储在<code>pipeline</code>属性中。</p><p>图像过滤器保持内部纹理，用作其内核函数的输出纹理。这样它可以存储其计算结果并将其提供给其他过滤器。它也可以绘制到屏幕或转换为图像。</p><p>图像过滤器可能具有任何数量的参数，这些参数会影响它们执行计算的方式。当其中一个更改时，内部纹理无效，并且必须重新执行内核函数。脏标志允许过滤器子类指示何时需要。仅当<code>dirty</code>标识设置为YES时才会执行过滤器，这在自定义属性设置器中完成。</p><p>图像过滤器基类包含<code>-applyFilter</code>方法，该方法在被要求提供其输出纹理时被调用，并且当前是脏的。此方法创建一个命令缓冲区和命令编码器，并调度其内核函数，如前一章所述。</p><p>既然我们已经拥有了必要的机器，让我们来谈谈将要使用的几个示例过滤器。</p><h3 id="Building-a-Saturation-Adjustment-Filter-构建饱和度调整过滤器"><a href="#Building-a-Saturation-Adjustment-Filter-构建饱和度调整过滤器" class="headerlink" title="Building a Saturation Adjustment Filter(构建饱和度调整过滤器)"></a>Building a Saturation Adjustment Filter(构建饱和度调整过滤器)</h3><p>我们将构建的第一个滤镜是饱和度调整滤镜。滤波器将具有可配置的饱和因子，用于确定滤波器应对输入图像进行去饱和的程度。此因子的范围为0到1.当饱和因子为0时，输出图像将是输入的灰度版本。对于介于0和1之间的值，滤镜将通过在灰度图像和输入图像之间进行插值来生成颜色或多或少静音的图像。</p><p><img src="/2020/04/05/实例学习Metal-第十四章/1584068954.png" alt=""></p><center>图14.2：一系列图像显示了如何将滤波器的饱和因子从0增加到1会增加图像饱和度</center><h4 id="Calculating-Brightness-from-RGB-从RGB计算亮度"><a href="#Calculating-Brightness-from-RGB-从RGB计算亮度" class="headerlink" title="Calculating Brightness from RGB(从RGB计算亮度)"></a>Calculating Brightness from RGB(从RGB计算亮度)</h4><p>每个RGB颜色值都有一个相应的亮度值，我们将用符号Y’表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y′ = 0.299R + 0.587G + 0.114B</span><br></pre></td></tr></table></figure><p>请注意，公式中的因子总和为1.它们的值基于人类对不同原色光强度的感知：人眼对绿光最敏感，其次是红光，最后是蓝光。 （这些值作为ITU-R BT.601-7建议书（国际电信联盟2011）第2.5.1节）的一部分公布。</p><p>用相应亮度的灰色像素替换图像中的每种颜色会产生完全去饱和的图像，该图像与原始图像具有相同的感知亮度。这将是我们的去饱和核函数的任务，如下所示。</p><h4 id="The-Desaturation-Kernel-去饱和核"><a href="#The-Desaturation-Kernel-去饱和核" class="headerlink" title="The Desaturation Kernel(去饱和核)"></a>The Desaturation Kernel(去饱和核)</h4><p>为了支持将饱和因子传递给我们的内核函数，我们创建了一个名为AdjustSaturationUniforms的单元结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct AdjustSaturationUniforms </span><br><span class="line">&#123;</span><br><span class="line">    float saturationFactor; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内核函数本身采用输入纹理，输出纹理，对统一结构的引用，以及具有我们在前一章中没有详细描述的属性的整数的2D向量：<code>thread_position_in_grid</code>。</p><p>回想一下前一章，我们发送了一组二维线程组，其大小是根据源纹理的维度计算的。 <code>thread_position_in_grid</code>属性告诉Metal生成一个坐标向量，告诉我们我们在2D网格中的位置，该网格跨越整个调度的工作项集，即源纹理中的当前坐标。</p><p>我们为每个纹理参数指定预期的访问模式：<code>access::read</code>用于输入纹理，<code>access::write</code>用于输出纹理。这限制了我们可以调用这些参数的函数集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kernel void adjust_saturation(texture2d&lt;float, access::read&gt; inTexture [[texture(0)]],</span><br><span class="line">texture2d&lt;float, access::write&gt; outTexture [[texture(1)]], constant AdjustSaturationUniforms &amp;uniforms [[buffer(0)]], uint2 gid [[thread_position_in_grid]])</span><br><span class="line">&#123;</span><br><span class="line">    float4 inColor = inTexture.read(gid);</span><br><span class="line">    float value = dot(inColor.rgb, float3(0.299, 0.587, 0.114));</span><br><span class="line">    float4 grayColor(value, value, value, 1.0);</span><br><span class="line">    float4 outColor = mix(grayColor, inColor, uniforms.saturationFactor); outTexture.write(outColor, gid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们读取源纹素的颜色，并根据前面给出的公式计算其亮度值。点函数允许我们比分别进行三次乘法和两次加法更简洁地完成此操作。然后，我们通过将亮度复制到RGB组件中来生成新颜色，这会产生灰色阴影。</p><p>要计算部分去饱和的输出颜色，我们使用Metal标准库中的函数：mix，它采用两种颜色，系数介于0和1之间。如果系数为0，则返回第一种颜色，如果为1，则返回1 ，返回第二种颜色。在它们之间，它使用线性插值将它们混合在一起。</p><p>最后，我们将得到的去饱和颜色写入输出纹理。请注意，我们之前假设输入和输出纹理具有相同的大小，并且两者的维度都是我们的线程组大小的倍数。如果不是这种情况，我们需要防止在输出纹理边界之外的输入写入范围之外进行读取。</p><h4 id="The-Saturation-Adjustment-Class-饱和度调整类"><a href="#The-Saturation-Adjustment-Class-饱和度调整类" class="headerlink" title="The Saturation Adjustment Class(饱和度调整类)"></a>The Saturation Adjustment Class(饱和度调整类)</h4><p>为了驱动饱和度调整内核，我们需要扩展图像过滤器基类。该子类名为<code>MBESaturationAdjustmentFilter</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MBESaturationAdjustmentFilter</span> : <span class="title">MBEImageFilter</span> </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">float</span> saturationFactor;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)filterWithSaturationFactor:(<span class="keyword">float</span>)saturation</span><br><span class="line">context:(MBEContext *)context; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>该子类使用去饱和内核函数的名称调用初始化程序，并通过对它应该操作的上下文的引用。</p><p>设置<code>saturationFactor</code>属性会导致过滤器设置其<code>dirty</code>属性，这会导致在其纹理属性被请求时延迟重新计算去饱和图像。</p><p>子类的<code>-configureArgumentTableWithCommandEncoder:</code>的实现：包含样板，用于将饱和因子复制到Metal缓冲区中。这里没有显示。</p><p>我们现在有一个完整的过滤器类和内核函数来执行图像去饱和。</p><h4 id="模糊"><a href="#模糊" class="headerlink" title="模糊"></a>模糊</h4><p>我们将看到的下一类图像滤镜是模糊滤镜。</p><p>模糊图像涉及将每个纹素的颜色与相邻文本的颜色混合。在数学上，模糊滤波器是纹素的邻域的加权平均值（这种操作称为<code>卷积</code>）。邻域的大小称为过滤器的半径。小半径将平均较少的纹理像素并产生较少模糊的图像。</p><h4 id="盒子模糊"><a href="#盒子模糊" class="headerlink" title="盒子模糊"></a>盒子模糊</h4><p>最简单的模糊是盒子模糊。框模糊给予所有附近纹素的相同权重，计算它们的平均值。盒子模糊很容易计算，但会产生难看的伪影，因为它们会给噪音带来不适当的重量。</p><p>假设我们选择半径为1的盒子模糊。然后输出图像中的每个纹素将是输入纹理元素及其最近邻居的平均值。 9种颜色中的每一种都具有相同的1/9重量。</p><p><img src="/2020/04/05/实例学习Metal-第十四章/1584068998.png" alt=""></p><center>图14.3：框模糊过滤器平均每个纹素周围的邻域。</center><p>盒子模糊很容易，但它们不会产生非常令人满意的结果。相反，我们将使用更复杂的模糊滤镜，即高斯模糊。</p><h4 id="Gussian-Blur-高斯模糊"><a href="#Gussian-Blur-高斯模糊" class="headerlink" title="Gussian Blur(高斯模糊)"></a>Gussian Blur(高斯模糊)</h4><p>与盒子模糊相反，高斯模糊给相邻纹素提供了不相等的权重，为更接近的纹素赋予了更多的权重，而对于那些更远的纹理则更轻。实际上，权重是根据关于当前纹素的2D正态分布计算的：</p><p>$$<br>G_\sigma(x, y) = {1 \over \sqrt {2\pi\sigma^2}}e^{-{x^2 + y^2\over 2 \sigma^2}}<br>$$</p><p>其中x和y分别是正在处理的纹理元素与其邻居之间沿x和y轴的距离。 σ是分布的标准偏差，默认等于半径的一半。</p><p><img src="/2020/04/05/实例学习Metal-第十四章/1584069023.png" alt=""></p><center>图14.4：高斯模糊滤波器。增加滤镜半径可以创建更平滑的图像。此处显示的最大半径为7。</center><h4 id="The-Blur-Shaders-模糊着色器"><a href="#The-Blur-Shaders-模糊着色器" class="headerlink" title="The Blur Shaders(模糊着色器)"></a>The Blur Shaders(模糊着色器)</h4><p>计算高斯滤波器的模糊权重在核函数中是很昂贵的，特别是对于具有大半径的滤波器。因此，我们将预先计算表格权重并将其作为纹理提供给高斯模糊核函数。此纹理的像素格式为<code>MTLPixelFormatR32Float</code>，它是单通道32位浮点格式。每个纹素都包含0到1之间的权重，所有权重总和为1。</p><p>在内核函数内部，我们迭代当前纹理元素的邻域，从查找表中读取每个纹素及其相应的权重。然后我们将加权颜色添加到累积值。一旦我们完成了所有加权颜色值的加总，我们就会将最终颜色写入输出纹理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kernel void gaussian_blur_2d(texture2d&lt;float, access::read&gt; inTexture [[texture(0)]],</span><br><span class="line">texture2d&lt;float, access::write&gt; outTexture [[texture(1)]], texture2d&lt;float, access::read&gt; weights [[texture(2)]], uint2 gid [[thread_position_in_grid]])</span><br><span class="line">&#123;</span><br><span class="line">    int size = blurKernel.get_width(); int radius = size / 2;</span><br><span class="line">    float4 accumColor(0, 0, 0, 0); for(intj=0;j&lt;size;++j) </span><br><span class="line">    &#123;</span><br><span class="line">        for(inti=0;i&lt;size;++i) </span><br><span class="line">        &#123;</span><br><span class="line">            uint2 kernelIndex(i, j);</span><br><span class="line">            uint2 textureIndex(gid.x + (i - radius), gid.y + (j - radius)); float4 color = inTexture.read(textureIndex).rgba;</span><br><span class="line">            float4 weight = weights.read(kernelIndex).rrrr;</span><br><span class="line">            accumColor += weight * color;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    outTexture.write(float4(accumColor.rgb, 1), gid); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="The-Filter-Class-过滤类"><a href="#The-Filter-Class-过滤类" class="headerlink" title="The Filter Class(过滤类)"></a>The Filter Class(过滤类)</h4><p>模糊过滤器类<code>MBEGaussianBlur2DFilter</code>派生自图像过滤器基类。它的<code>-configureArgumentTableWithCommandEncoder:</code>的实现：懒惰地生成模糊权重并将命令编码器上的查找表纹理设置为第三个参数（参数表索引2）。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)configureArgumentTableWithCommandEncoder: (<span class="keyword">id</span>&lt;<span class="built_in">MTLComputeCommandEncoder</span>&gt;)commandEncoder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.blurWeightTexture) </span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span> generateBlurWeightTexture]; </span><br><span class="line">    &#125;</span><br><span class="line">    [commandEncoder setTexture:<span class="keyword">self</span>.blurWeightTexture atIndex:<span class="number">2</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-generateBlurWeightTexture</code>方法使用上面的2D标准分布公式计算适当大小的权重矩阵，并将值复制到Metal纹理中。</p><p>这完成了我们对高斯模糊滤镜类和着色器的实现。现在我们需要讨论如何将滤镜链接在一起并将最终图像输出到屏幕上。</p><h3 id="Chaining-Image-Filters-链接图像过滤器"><a href="#Chaining-Image-Filters-链接图像过滤器" class="headerlink" title="Chaining Image Filters(链接图像过滤器)"></a>Chaining Image Filters(链接图像过滤器)</h3><p>再次考虑本章开头的代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context = [MBEContext newContext]; imageProvider = [MBEMainBundleTextureProvider</span><br><span class="line">textureProviderWithImageNamed:<span class="string">@"mandrill"</span> context:context];</span><br><span class="line">desaturateFilter = [MBESaturationAdjustmentFilter filterWithSaturationFactor:<span class="number">0.75</span></span><br><span class="line">context:context];</span><br><span class="line">desaturateFilter.provider = <span class="keyword">self</span>.imageProvider; </span><br><span class="line">blurFilter = [MBEGaussianBlur2DFilter filterWithRadius:<span class="number">0.0</span> context:context];</span><br><span class="line">blurFilter.provider = desaturateFilter;</span><br><span class="line">imageView.image = [<span class="built_in">UIImage</span> imageWithMTLTexture:blurFilter.texture];</span><br></pre></td></tr></table></figure><p>主捆绑图像提供程序是一个实用程序，用于将图像加载到Metal纹理中，并充当链的开头。它被设置为去饱和度过滤器的纹理提供者，后者又被设置为模糊过滤器的纹理提供者。</p><p>请求模糊滤镜的纹理实际上是将图像滤镜处理设置为运动的原因。这会导致模糊滤镜请求去饱和过滤器的纹理，这反过来会导致去饱和内核同步调度。一旦完成，模糊滤镜将去饱和纹理作为输入并调度其自己的内核函数。</p><p>现在我们已经过滤了图像，我们可以使用它来渲染带有Metal的纹理四边形（或其他表面）。假设我们想用UIKit显示它？我们如何从UIImage创建Metal纹理，而不是从Metal纹理创建UIImage？</p><h3 id="Creating-a-UIImage-from-a-Texture-从纹理创建UIImage"><a href="#Creating-a-UIImage-from-a-Texture-从纹理创建UIImage" class="headerlink" title="Creating a UIImage from a Texture(从纹理创建UIImage)"></a>Creating a UIImage from a Texture(从纹理创建UIImage)</h3><p>最有效的方法是使用Core Graphics中的图像实用程序。首先，创建一个临时缓冲区，其中读取Metal纹理的像素数据。可以使用CGDataProviderRef包装此缓冲区，然后使用CGDataProviderRef创建CGImageRef。然后我们可以创建一个包装此CGImageRef的UIImage实例。</p><p>示例代码在UIImage上实现了一个类别，该类别在名为<code>+imageWithMTLTexture:</code>的方法中执行所有这些操作。为简洁起见，此处不包含此内容，但它有助于阅读。</p><p>值得一提的是，这不是在屏幕上获取过滤图像的最有效方法。从纹理创建图像使用额外的内存，占用CPU时间，并要求Core Animation合成器将图像数据复制回纹理以供显示。所有这些都是昂贵的，并且在许多情况下可以避免。幸运的是，在本书的整个过程中，我们已经看到很多方法可以使用不涉及UIKit的纹理。</p><h4 id="Driving-Image-Processing-Asynchronously-异步驱动图像处理"><a href="#Driving-Image-Processing-Asynchronously-异步驱动图像处理" class="headerlink" title="Driving Image Processing Asynchronously(异步驱动图像处理)"></a>Driving Image Processing Asynchronously(异步驱动图像处理)</h4><p>上面，我们提到过滤器同步调度它们的内核函数。由于图像处理是计算密集型的，我们需要一种在背景线程上进行工作的方法，以保持用户界面的响应。</p><p>将命令缓冲区提交到命令队列本质上是线程安全的，但是控制并发的其他方面是程序员的责任。</p><p>幸运的是，Grand Central Dispatch使我们的工作变得轻松。由于我们只会在主线程上响应用户操作而使用图像过滤器，因此我们可以使用一对<code>dispatch_async</code>调用将我们的图像处理工作重定位到后台线程上，异步更新主线程上的图像视图过滤器的处理完成。</p><p>我们将在视图控制器上以原子64位整数属性的形式使用粗互斥，每次请求更新时都会递增。该计数器的值由入队的块捕获。如果块在后台队列上执行时尚未发生另一个用户事件，则允许执行图像过滤器，并刷新UI。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateImage &#123;</span><br><span class="line">    ++<span class="keyword">self</span>.jobIndex;</span><br><span class="line">    uint64_t currentJobIndex = <span class="keyword">self</span>.jobIndex;</span><br><span class="line">    <span class="keyword">float</span> blurRadius = <span class="keyword">self</span>.blurRadiusSlider.value; </span><br><span class="line">    <span class="keyword">float</span> saturation = <span class="keyword">self</span>.saturationSlider.value;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.renderingQueue, ^&#123; </span><br><span class="line">        <span class="keyword">if</span> (currentJobIndex != <span class="keyword">self</span>.jobIndex)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">self</span>.blurFilter.radius = blurRadius; <span class="keyword">self</span>.desaturateFilter.saturationFactor = saturation;</span><br><span class="line">        <span class="keyword">id</span>&lt;<span class="built_in">MTLTexture</span>&gt; texture = <span class="keyword">self</span>.blurFilter.texture; <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithMTLTexture:texture];</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; <span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="The-Sample-Project-示例项目"><a href="#The-Sample-Project-示例项目" class="headerlink" title="The Sample Project(示例项目)"></a>The Sample Project(示例项目)</h3><p>本章的示例代码位于14-ImageProcessing目录中。</p><p>在本章中，我们采用了与Metal并行计算的后续步骤，并看到了几个可以在GPU上高效运行的图像过滤器示例。您现在可以使用此处提供的框架来创建自己的效果，并使用Metal的强大功能在GPU上高效运行它们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本章中，我们将开始使用Metal着色语言探索图像处理世界。我们将创建一个能够表示图像滤镜链的框架，然后编写一对图像滤镜，以便我们调整图像的饱和度和模糊度。最终结果将是一个交互式应用程序，允许您实时控制图像过滤器参数。&lt;/p&gt;
&lt;p&gt;图像处理是数据并行编程的主要应用之一。在许多情况下，图像滤波器仅需要查询源图像中的一个像素或小邻域像素以计算每个输出像素的值。在这种情况下，图像滤波器的工作可以以并行方式完成。这非常适合现代GPU架构，它使用许多小内核同时处理多个数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS/Mac" scheme="https://zhaolilong.com/tags/iOS-Mac/"/>
    
      <category term="图形学" scheme="https://zhaolilong.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Metal" scheme="https://zhaolilong.com/tags/Metal/"/>
    
  </entry>
  
  <entry>
    <title>实例学习Metal-第十三章 介绍数据并行编程</title>
    <link href="https://zhaolilong.com/2020/03/29/%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0Metal-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"/>
    <id>https://zhaolilong.com/2020/03/29/实例学习Metal-第十三章/</id>
    <published>2020-03-28T16:00:00.000Z</published>
    <updated>2020-03-13T03:06:58.793Z</updated>
    
    <content type="html"><![CDATA[<p>本章介绍了数据并行编程的主题，在GPU上完成时也称为计算编程（与图形编程相反，这是我们通常使用GPU执行的操作）。我们将介绍设置计算管道和并行处理大型数据集上的内核函数的基础知识。本章将作为下一章的设置，演示如何使用计算内核在GPU上进行图像处理。</p><a id="more"></a><h1 id="Chapter-13-第十三章"><a href="#Chapter-13-第十三章" class="headerlink" title="Chapter 13(第十三章)"></a>Chapter 13(第十三章)</h1><h2 id="Introduction-to-Data-Parallel-Programming-介绍数据并行编程"><a href="#Introduction-to-Data-Parallel-Programming-介绍数据并行编程" class="headerlink" title="Introduction to Data-Parallel Programming(介绍数据并行编程)"></a>Introduction to Data-Parallel Programming(介绍数据并行编程)</h2><p>本章介绍了数据并行编程的主题，在GPU上完成时也称为计算编程（与图形编程相反，这是我们通常使用GPU执行的操作）。我们将介绍设置计算管道和并行处理大型数据集上的内核函数的基础知识。本章将作为下一章的设置，演示如何使用计算内核在GPU上进行图像处理。</p><h3 id="Kenel-Functions-内核函数"><a href="#Kenel-Functions-内核函数" class="headerlink" title="Kenel Functions(内核函数)"></a>Kenel Functions(内核函数)</h3><p>在本书中，我们广泛使用了顶点和片段函数。在本章中，我们介绍一种新的着色器函数：内核函数。内核函数允许我们构建大规模并行程序，这些程序可以同时处理多个数据。我们将交替使用术语“内核函数”，“计算内核”和“计算着色器”。</p><p>在着色器源中通过为内核限定符添加前缀来标识内核函数，就像我们使用<code>顶点</code>或<code>片段</code>为其他类型的函数添加前缀一样。这些类型的函数之间的一个区别是内核函数<code>必须</code>返回void。这是因为内核函数对缓冲区和纹理进行操作，而不是像顶点和片段函数那样将数据提供给其他管道阶段。</p><p>以下代码段是内核函数签名的示例。稍后将详细讨论此函数签名中引入的新属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel void kernel_function(</span><br><span class="line">texture2d&lt;float, access::read&gt; inTexture [[texture(0)]], texture2d&lt;float, access::write&gt; outTexture [[texture(1)]], uint2 gid [[thread_position_in_grid]]);</span><br></pre></td></tr></table></figure><h3 id="The-Compute-Pipeline-计算管道"><a href="#The-Compute-Pipeline-计算管道" class="headerlink" title="The Compute Pipeline(计算管道)"></a>The Compute Pipeline(计算管道)</h3><p>构建计算管道类似于为我们的3D渲染工作构建渲染管道。我们创建一个上下文对象来保存各种Metal对象，而不是渲染器类。</p><h4 id="The-Context-Class-上下文类"><a href="#The-Context-Class-上下文类" class="headerlink" title="The Context Class(上下文类)"></a>The Context Class(上下文类)</h4><p>上下文包装了设备，库和命令队列，因为它们是长期存在的对象，将由我们创建的各种内核类引用。</p><p>上下文类有一个非常简单的接口。调用<code>+newContext</code>工厂方法将返回具有系统默认设备的上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface MBEContext : NSObject</span><br><span class="line">@property (strong) id&lt;MTLDevice&gt; device;</span><br><span class="line">@property (strong) id&lt;MTLLibrary&gt; library; @property (strong) id&lt;MTLCommandQueue&gt; commandQueue;</span><br><span class="line">+ (instancetype)newContext; @end</span><br></pre></td></tr></table></figure><p>每个上下文有一个串行命令队列。这允许我们序列化工作项，例如可能在它们之间具有数据依赖性的图像过滤器。</p><h4 id="Creating-a-Pipeline-State-创建管道状态"><a href="#Creating-a-Pipeline-State-创建管道状态" class="headerlink" title="Creating a Pipeline State(创建管道状态)"></a>Creating a Pipeline State(创建管道状态)</h4><p>构建用于执行内核函数的管道状态比创建渲染管道要简单一些。没有与计算管道的MTLRenderPipelineDescriptor等效，因为计算管道的唯一可配置部分是其关联的内核函数。</p><p>与顶点和片段函数一样，内核函数通过库中的名称检索：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[library newFunctionWithName:@&quot;kernel_function&quot;];</span><br></pre></td></tr></table></figure><p>然后通过从设备请求计算管道状态对象来创建计算管道。如果在为目标硬件编译内核函数时发生错误，则会将错误分配给error参数，并返回nil。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&lt;MTLComputePipelineState&gt; pipeline = [device newComputePipelineStateWithFunction:kernelFunction error:&amp;error];</span><br></pre></td></tr></table></figure><h4 id="Creating-a-Command-Buffer-and-Command-Encoder-创建命令缓冲区和命令编码器"><a href="#Creating-a-Command-Buffer-and-Command-Encoder-创建命令缓冲区和命令编码器" class="headerlink" title="Creating a Command Buffer and Command Encoder(创建命令缓冲区和命令编码器)"></a>Creating a Command Buffer and Command Encoder(创建命令缓冲区和命令编码器)</h4><p>正如我们使用渲染命令编码器将绘制调用编码到命令缓冲区中一样，我们使用新类型的命令编码器来执行内核函数：MTLComputeCommandEncoder。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id&lt;MTLCommandBuffer&gt; commandBuffer = [context.commandQueue commandBuffer]; id&lt;MTLComputeCommandEncoder&gt; commandEncoder =</span><br><span class="line">[commandBuffer computeCommandEncoder];</span><br></pre></td></tr></table></figure><p>但是，在将工作发送到GPU之前，我们需要了解如何配置计算命令编码器的参数表以及如何描述我们希望GPU执行的工作。</p><h4 id="The-Argument-Table-参数表"><a href="#The-Argument-Table-参数表" class="headerlink" title="The Argument Table(参数表)"></a>The Argument Table(参数表)</h4><p>我们之前使用参数表来指定哪些缓冲区，纹理和采样器状态绑定到顶点和片段函数的参数。</p><p>例如，我们通过在渲染命令编码器上调用<code>-setFragmentTexture:atIndex:</code>方法来配置片段着色器的参数。回想一下，索引参数将参数表中的条目与片段函数的签名中具有相应属性（例如，<code>[[texture（0）]]</code>）的参数匹配。<br>设置计算编码器的参数表有类似的方法：<code>-setTexture:atIndex:</code>。在准备执行内核函数时，我们将使用此方法设置参数表。</p><h4 id="Threadgroups-线程组"><a href="#Threadgroups-线程组" class="headerlink" title="Threadgroups(线程组)"></a>Threadgroups(线程组)</h4><p>线程组是Metal内核函数编程的核心概念。为了并行执行，必须将每个工作负载分解为称为线程组的块，这些块可以进一步划分并分配给GPU上的线程池。</p><p>为了有效运行，GPU不会调度单个线程。相反，它们被安排成套（有时称为“warp”或“wavefronts”，尽管Metal文档不使用这些术语）。线程执行宽度表示此执行单元的大小。这是实际计划在GPU上并发运行的线程数。您可以使用其<code>threadExecutionWidth</code>属性从命令编码器查询此值。它可能是2的小功率，例如32或64。</p><p>我们还可以通过查询<code>maxTotalThreadsPerThreadgroup</code>来确定线程组大小的上限。此数字始终是线程执行宽度的倍数。例如，在iPhone 6上它是512。</p><p>为了最有效地使用GPU，线程组中的项目总数应该是线程执行宽度的倍数，并且必须低于每个线程组的最大总线程数。这通知我们如何选择细分输入数据以实现最快和最方便的执行。</p><p>线程组不必是一维的。通常，线程组的尺寸与正在操作的数据的尺寸相匹配是很方便的。例如，当在2D图像上操作时，每个块通常将是源纹理的矩形区域。下图显示了如何选择将纹理细分为线程组。</p><p><img src="/2020/03/29/实例学习Metal-第十三章/1584068791.png" alt=""></p><center>图13.1：要处理的图像被划分为多个线程组，此处用白色方块表示。</center><p>为了告诉Metal每个线程组的维度以及在给定的计算调用中应该执行多少个线程组，我们创建了一对MTLSize结构：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MTLSize</span> threadgroupCounts = <span class="built_in">MTLSizeMake</span>(<span class="number">8</span>, <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">MTLSize</span> threadgroups = <span class="built_in">MTLSizeMake</span>([texture width] / threadgroupCounts.width,</span><br><span class="line">[texture height] / threadgroupCounts.height, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在这里，我们有点随意选择8行8列的线程组大小，或者每个线程组总共64个项目。我们假设这个代码处理的纹理的维度是8的倍数，这通常是一个安全的选择。总线程组大小是目标硬件线程执行宽度的偶数倍，并且安全地低于最大总线程数。如果纹理尺寸不能被我们的线程组大小整除，我们需要在内核函数中采取措施，不要在纹理边界之外读取或写入。</p><p>既然在我们已经确定了线程组的大小以及我们需要执行多少线程组，现在我们已经准备好让GPU工作了。</p><h4 id="Dispatching-Threadgroups-for-Execution-调度线程组以执行"><a href="#Dispatching-Threadgroups-for-Execution-调度线程组以执行" class="headerlink" title="Dispatching Threadgroups for Execution(调度线程组以执行)"></a>Dispatching Threadgroups for Execution(调度线程组以执行)</h4><p>编码命令来对一组数据执行内核函数称为<code>调度</code>。一旦我们引用了一个计算命令编码器，我们就可以调用它的<code>-dispatchThreadgroups:threadsPerThreadgroup:</code>方法对执行请求进行编码，传递我们之前计算过的MTLSize结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[commandEncoder dispatchThreadgroups:threadgroups threadsPerThreadgroup:threadgroupCounts];</span><br></pre></td></tr></table></figure><p>一旦完成调度，我们告诉命令编码器endEncoding，然后提交相应的命令缓冲区。然后我们可以在命令缓冲区上使用<code>-waitUntilCompleted</code>方法来阻止，直到着色器在GPU上运行完毕。每个数据项将执行一次内核函数（例如，源纹理中每个纹素一次）。</p><h3 id="Conclusion-结论"><a href="#Conclusion-结论" class="headerlink" title="Conclusion(结论)"></a>Conclusion(结论)</h3><p>在这个简短的章节中，我们为讨论Metal中的高性能图像滤波以及数据并行编程的其他应用奠定了基础。在下一章中，我们将在Metal中应用数据并行编程来解决图像处理中的一些有趣问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章介绍了数据并行编程的主题，在GPU上完成时也称为计算编程（与图形编程相反，这是我们通常使用GPU执行的操作）。我们将介绍设置计算管道和并行处理大型数据集上的内核函数的基础知识。本章将作为下一章的设置，演示如何使用计算内核在GPU上进行图像处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS/Mac" scheme="https://zhaolilong.com/tags/iOS-Mac/"/>
    
      <category term="图形学" scheme="https://zhaolilong.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Metal" scheme="https://zhaolilong.com/tags/Metal/"/>
    
  </entry>
  
  <entry>
    <title>实例学习Metal-第十二章 渲染文本</title>
    <link href="https://zhaolilong.com/2020/03/22/%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0Metal-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"/>
    <id>https://zhaolilong.com/2020/03/22/实例学习Metal-第十二章/</id>
    <published>2020-03-21T16:00:00.000Z</published>
    <updated>2020-03-13T03:02:13.506Z</updated>
    
    <content type="html"><![CDATA[<p>在本章中，我们将讨论使用Metal渲染高保真文本的方法。在考虑3D图形时，很容易忽略文本渲染。但是，很少有游戏或应用程序可以在不显示任何文本的情况下使用，因此考虑如何最好地使用GPU将文本合并到我们的Metal应用程序中非常重要。</p><a id="more"></a><h1 id="Chapter-12-第十二章"><a href="#Chapter-12-第十二章" class="headerlink" title="Chapter 12(第十二章)"></a>Chapter 12(第十二章)</h1><h2 id="Rendering-Text-渲染文本"><a href="#Rendering-Text-渲染文本" class="headerlink" title="Rendering Text(渲染文本)"></a>Rendering Text(渲染文本)</h2><p>在本章中，我们将讨论使用Metal渲染高保真文本的方法。在考虑3D图形时，很容易忽略文本渲染。但是，很少有游戏或应用程序可以在不显示任何文本的情况下使用，因此考虑如何最好地使用GPU将文本合并到我们的Metal应用程序中非常重要。</p><p><img src="/2020/03/22/实例学习Metal-第十二章/1584067620.png" alt=""></p><center>图12.1：示例应用程序使用signed-distance字段技术呈现的文本<center><h4 id="The-Structure-and-Interpretation-of-Fonts-字体的结构与解释"><a href="#The-Structure-and-Interpretation-of-Fonts-字体的结构与解释" class="headerlink" title="The Structure and Interpretation of Fonts(字体的结构与解释)"></a>The Structure and Interpretation of Fonts(字体的结构与解释)</h4><p>我们通过选择<code>字体</code>开始绘制文本的过程。字体是字形的集合，字形是字符或字符部分的图形表示。在现代字体格式中，字形表示为分段曲线，特别是线段和二次贝塞尔曲线。</p><p><img src="/2020/03/22/实例学习Metal-第十二章/1584067651.png" alt=""></p><center>图12.2：来自Verdana的'g'字形，显示了如何构造字形的二次Beziér曲线</center><p>绘制一串文本至少包含两个不同的阶段。首先，<code>文本布局引擎</code>确定将使用哪些字形来表示字符串以及它们如何相对于彼此定位。然后，渲染引擎负责将字形的抽象描述转换为屏幕上的文本。</p><h3 id="Approaches-to-Real-Time-Text-Rendering-实时文本渲染的方法"><a href="#Approaches-to-Real-Time-Text-Rendering-实时文本渲染的方法" class="headerlink" title="Approaches to Real-Time Text Rendering(实时文本渲染的方法)"></a>Approaches to Real-Time Text Rendering(实时文本渲染的方法)</h3><p>您可以通过多种方式在iOS上呈现文本。您可能熟悉UIKit控件，如UILabel和UITextField。这些UI元素由叫作Core Text的强大框架支持。 Core Text是一种Unicode文本布局引擎，它与Quartz 2D（Core Graphics）紧密集成，可以布局和渲染文本。</p><p>文本布局是一个非常复杂的主题，必须考虑到不同的脚本，书写方向和印刷约定。我们永远不会想要自己重新发明这个功能，因此我们会让Core Text在我们的实时文本渲染解决方案中付出沉重的代价。</p><p>让我们简要介绍一下在实时3D图形环境中绘制文本的常用方法。</p><h4 id="Dynamic-Rasterization-动态光栅化"><a href="#Dynamic-Rasterization-动态光栅化" class="headerlink" title="Dynamic Rasterization(动态光栅化)"></a>Dynamic Rasterization(动态光栅化)</h4><p>文本渲染最灵活的方法之一是动态光栅化，其中字符串在CPU上进行光栅化，并将生成的位图作为纹理上载到GPU进行绘制。这是<code>stb_truetype</code>等库采用的方法(Bar-rett 2014)。</p><p>动态光栅化的缺点是每当文本字符串改变时重新绘制字形的计算成本。即使文本渲染的大部分成本发生在布局阶段，光栅化字形对CPU的需求也是非常重要的，并且iOS上没有现有的字体光栅化GPU实现。此技术还需要一定量的纹理内存，与字体大小和正在呈现的字符串的长度成比例。最后，放大时，光栅化文本会变得模糊或模糊，具体取决于放大滤镜。</p><h4 id="Font-Atlases-字体地图集"><a href="#Font-Atlases-字体地图集" class="headerlink" title="Font Atlases(字体地图集)"></a>Font Atlases(字体地图集)</h4><p>许多使用GPU绘制文本的应用程序更喜欢预先渲染所有可能的字形而不是动态绘制它们。这种方法根据纹理内存进行折衷，以获得按需栅格化字形的计算成本。为了最小化字体所需的纹理内存量，字形被打包成单个矩形纹理，称为图集。下图说明了这种纹理。</p><p><img src="/2020/03/22/实例学习Metal-第十二章/1584067674.png" alt=""></p><center> 图 12.3：一个字体地图集</center><p>辅助数据结构存储描述每个字形的边界矩形的纹理坐标。绘制字符串时，应用程序会生成一个网格，其中包含字符串构成字形的适当位置和纹理坐标。</p><p><img src="/2020/03/22/实例学习Metal-第十二章/1584067697.png" alt=""></p><center>图12.4：为文本字符串中的每个字形生成一对三角形</center><p>字体图集的一个缺点是，即使它们包含的许多字形在运行时都没有使用，它们也会占用大量的内存。</p><p>与动态光栅化一样，使用图集纹理渲染的文本在放大时会受到失去的影响。这里，问题可能更糟，因为字形通常被绘制得更小以便将整个字体打包成一个纹理。</p><p>在下一节中，我们将寻求纠正一些基于天真地图集的文本渲染问题。</p><h4 id="Signed-Distance-Fields-签名距离字段"><a href="#Signed-Distance-Fields-签名距离字段" class="headerlink" title="Signed-Distance Fields(签名距离字段)"></a>Signed-Distance Fields(签名距离字段)</h4><p>我们将深入探索的方法使用有符号距离字段，该字段是字体图集的预先表示，其隐式存储字形轮廓。具体地，有符号距离场纹理的纹理元素值对应于纹素与最近的字形边缘的距离，其中字形外的纹素采用负值。</p><p><img src="/2020/03/22/实例学习Metal-第十二章/1584067721.png" alt=""></p><center>图12.5：从字体图集生成的带符号距离字段。最亮的像素是最里面的。</center><p>为了在纹理中存储有符号距离字段，必须对其进行缩放和量化以匹配像素格式。我们的示例项目使用单通道8位纹理，每像素占一个字节。通过这种结构，恰好落在字形边缘的纹素的值为127或50％。</p><p>在其最简单的化身中，可以使用固定功能alpha测试来完成符号距离场渲染。通过丢弃其值小于50％的所有片段，将仅渲染字形内的那些像素。不幸的是，这会产生沿着字形边缘产生“摆动”的效果，因为下采样和量化的距离纹理不能捕获足够的细节来完美地重建理想的轮廓。</p><p>对alpha测试技术的改进是使用像素着色器在字形的内部和外部之间进行插值，从而平滑摆动的不连续性。这将在下面详细描述。</p><p>签名距离场渲染由Valve的Green Green（Green 2007）引入主流，描述了该技术在热门游戏Team Fortress 2中的使用。我们的实施将严格遵循Green的论文中提出的方案。</p><h4 id="Signed-Distance-Field-Rendering-in-Metal-Metal中的符号距离场渲染"><a href="#Signed-Distance-Field-Rendering-in-Metal-Metal中的符号距离场渲染" class="headerlink" title="Signed-Distance Field Rendering in Metal(Metal中的符号距离场渲染)"></a>Signed-Distance Field Rendering in Metal(Metal中的符号距离场渲染)</h4><p>在本节中，我们将详细描述使用Metal在GPU上实现平滑文本渲染的方法。</p><h4 id="Generating-a-Font-Atlas-Texture-生成字体图集纹理）"><a href="#Generating-a-Font-Atlas-Texture-生成字体图集纹理）" class="headerlink" title="Generating a Font Atlas Texture(生成字体图集纹理）"></a>Generating a Font Atlas Texture(生成字体图集纹理）</h4><p>第一步是将我们选择的字体中的所有可用字形呈现为图集。在示例代码中，不使用最佳打包;相反，字形只是从左到右排列，以贪婪的方式从上到下包裹线条。这大大简化了实施，代价是浪费了一些空间。</p><p>示例代码通过确定所选字体的最大大小来构建来自UIFont的字体图集，其字形将完全适合用于构建图集（4096×4096像素）的位图。然后，它使用Core Text从字体中检索字形轮廓，并在没有抗锯齿的情况下将它们渲染到地图集图像中。</p><p>在绘制字体图集时，实现还将每个字形的原点和范围（即纹理坐标）存储在单独的数组中。在渲染期间使用此数组从布局的字形映射到atlas纹理上的相应区域。</p><h4 id="Generating-a-Signed-Distance-Field-生成有符号距离场"><a href="#Generating-a-Signed-Distance-Field-生成有符号距离场" class="headerlink" title="Generating a Signed-Distance Field(生成有符号距离场)"></a>Generating a Signed-Distance Field(生成有符号距离场)</h4><p>上述过程以相当高的分辨率生成字体的二进制图像。也就是说，落入字形内部的像素一直是“开启”（255），而字形外部的像素一直都是“关闭”（0）。我们现在需要对此位图执行带符号距离变换，以生成字体图集的带符号距离字段表示，我们将使用它来进行渲染。</p><h4 id="A-Brute-Force-Approach-蛮力方法"><a href="#A-Brute-Force-Approach-蛮力方法" class="headerlink" title="A Brute Force Approach(蛮力方法)"></a>A Brute Force Approach(蛮力方法)</h4><p>生成有符号距离字段需要找到从每个纹素到最近的字形边缘的距离。某些实现（例如GLyphy（Esfahbod 2014））直接针对字形的分段曲线表示执行此计算。这种方法可以具有惊人的保真度，但实施起来很复杂，充满了边缘情况。</p><p>由于我们已选择生成字体的位图表示，因此我们可以简单地在每个纹素的邻域上进行操作，在我们处理边缘另一侧的纹素时执行最小化搜索。为了达到易处理性，这要求我们选择一个合理大小的区域来进行搜索。</p><p>合理的启发式是字体平均笔划宽度的一半。例如，在典型笔画为20像素宽的字体中，在字形内到目前为止它们具有大于10的距离的纹素已经将在渲染期间被钳位到“内部”的最大值。类似地，在字形外部距离大于10的纹素不太可能影响字形的呈现方式。因此，我们将对每个纹素周围的10 x 10邻域进行搜索。</p><p>根据Green的说法，蛮力方法适用于在生产中使用的工作站类别上为文本和矢量图形创建距离场。<br>TF2。然而，由于对签名距离场生成进行了大量研究，让我们看一下稍微好一点的方法，即使在移动硬件上也能让我们快速生成它们。</p><h4 id="A-Better-Approach-Dead-Reckoning-更好的方法：航位推算法"><a href="#A-Better-Approach-Dead-Reckoning-更好的方法：航位推算法" class="headerlink" title="A Better Approach: Dead Reckoning(更好的方法：航位推算法)"></a>A Better Approach: Dead Reckoning(更好的方法：航位推算法)</h4><p>有符号距离场具有广泛的适用性，因此成为许多研究的主题。 G. J. Grevera，建立在一个名为cham-的古老的算法倒角距离算法的基础之上，构造了一种更精确的启发式方法，称为“航位推算”（Grevera 2004）。实质上，该算法在源图像上执行两次传递，首先向下和向右传播最小距离，然后将第一次传递中发现的最小距离传播回到左侧。在每个步骤中，距离值被确定为围绕中心纹理元素的一些掩模上的最小距离值加上沿着矢量到最近的先前发现边缘的距离。</p><p>在不深入研究该算法的所有细节的情况下，值得注意的是它比蛮力方法快得多。在两次传球中，航位推算都只能得到3x3纹素的邻域，远远低于类似精度的蛮力算法。虽然我们还没有使用计算着色器实现它，但我们强烈怀疑它可以通过基于GPU的实现更快地制作。</p><h4 id="使用核心文本进行布局"><a href="#使用核心文本进行布局" class="headerlink" title="使用核心文本进行布局"></a>使用核心文本进行布局</h4><p>一旦我们有了字体的有符号距离字段表示，我们需要一种在屏幕上呈现其字形的方法。此过程的第一部分再次使用Core Text布局引擎告诉我们应该呈现哪些字形以及它们应该如何定位。我们使用CTFramesetter对象在所选矩形中布局文本。框架设置过程生成一个CTLine对象数组，每个对象包含一系列字形。有关这些类的其他详细信息，请参阅Core Text参考。</p><p>为了构造用于使用Metal渲染的文本网格，我们枚举了Core Text框架设置提供的字形，它为我们提供了屏幕空间坐标和我们在构建字体图集纹理时先前构建的纹理坐标表的索引。这两个数据允许我们创建一个表示文本字符串的索引三角形网格。然后可以以通常的方式渲染该网格，片段着色器对从每个像素的有符号距离场纹理转换为适当的颜色进行繁重的提升。</p><h4 id="The-Orthographic-Projection-正投影"><a href="#The-Orthographic-Projection-正投影" class="headerlink" title="The Orthographic Projection(正投影)"></a>The Orthographic Projection(正投影)</h4><p>在屏幕上绘制文本时，我们使用<code>正交投影</code>或<code>平行投影</code>。这种投影使网格平行于屏幕平面，而不会引入透视投影中固有的缩短。</p><p>渲染UI元素时，可以方便地选择其范围与视图尺寸匹配的正交投影。因此，示例应用程序使用的正交投影使用（0,0）作为屏幕的左上角和屏幕的可绘制宽度和高度（以像素为单位）作为右下角，与UIKit的约定相匹配。</p><p>在数学上，这种转换由以下矩阵表示：</p><p>$$<br> \left[<br> \begin{matrix}<br>   2\over r-l &amp; 0 &amp; 0 &amp; r+l \over l-r \<br>   0 &amp; 2\over t-b &amp; 0 &amp; t+b \over b-t \<br>   0 &amp; 0 &amp; 1\over f-n &amp; n \over f-n \<br>   0 &amp; 0 &amp; 0 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p><p>这里l，r，t，b，n和f是左，右，上，下，近和远剪裁平面值。在我们的实现中，假设近平面和远平面分别位于z = 0和z = 1。</p><h4 id="The-Vertex-and-Fragment-Functions-顶点和片段函数"><a href="#The-Vertex-and-Fragment-Functions-顶点和片段函数" class="headerlink" title="The Vertex and Fragment Functions(顶点和片段函数)"></a>The Vertex and Fragment Functions(顶点和片段函数)</h4><p>绘制文本的顶点函数非常简单;它看起来与我们过去使用的顶点函数完全一样。文本网格的每个顶点由模型矩阵（可用于定位和缩放文本）和组合的视图 - 投影矩阵变换，该矩阵简单地是上面讨论的正交投影矩阵。</p><p>另一方面，片段函数涉及更多。由于我们正在使用带符号距离字段作为查找表而不是纹理，我们需要将场中的采样纹理像素转换为颜色值，该颜色值根据像素与相应字形边缘的接近度而变化。</p><p>我们在字形的边缘应用抗锯齿，通过在边缘周围的窄带中从不透明到半透明插值。通过使用内置的<code>dfdx</code>和<code>dfdy</code>函数找到距离场的梯度的长度，每个像素计算该带的宽度。然后我们使用smoothstep函数，它从0过渡到1这个平滑边缘的宽度，使用采样距离值本身作为最终参数。无论文本放大或缩小多少，这都会产生大约一个像素宽的边带。 Green对原始方法的改进归功于Gustavson（Gustavson 2012）。</p><p>以下是用于从有符号距离字段表示中呈现字形的完整片段函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float edgeDistance = 0.5;</span><br><span class="line">float dist = texture.sample(samp, vert.texCoords).r;</span><br><span class="line">float edgeWidth = 0.7 * length(float2(dfdx(dist), dfdy(dist))); </span><br><span class="line">float opacity = smoothstep(edgeDistance - edgeWidth, edgeDistance + edgeWidth, dist);</span><br><span class="line">return half4(textColor.r, textColor.g, textColor.b, opacity);</span><br></pre></td></tr></table></figure><p>请注意，我们返回一个具有alpha分量的颜色，因此我们使用的管道状态应启用Alpha混合，以便文本与其后面的几何图形正确混合。这也意味着应该在场景几何的其余部分之后绘制文本。</p><h3 id="The-Sample-App-示例应用"><a href="#The-Sample-App-示例应用" class="headerlink" title="The Sample App(示例应用)"></a>The Sample App(示例应用)</h3><p>本章的示例代码位于12-TextRendering目录中。</p><p>本章的示例应用程序呈现了一段可以实时缩放和平移的文本。使用一对UIGestureRecognizers实现交互。更确切地说，即使在极端放大率下，字形的边缘仍然保持非常清晰，这与预光栅化的位图纹理在放大下会变得锯齿状或模糊的方式形成对比。</p></center></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本章中，我们将讨论使用Metal渲染高保真文本的方法。在考虑3D图形时，很容易忽略文本渲染。但是，很少有游戏或应用程序可以在不显示任何文本的情况下使用，因此考虑如何最好地使用GPU将文本合并到我们的Metal应用程序中非常重要。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS/Mac" scheme="https://zhaolilong.com/tags/iOS-Mac/"/>
    
      <category term="图形学" scheme="https://zhaolilong.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Metal" scheme="https://zhaolilong.com/tags/Metal/"/>
    
  </entry>
  
  <entry>
    <title>用arduino uno r3给ESP8266-01WiFi模块烧写固件</title>
    <link href="https://zhaolilong.com/2020/03/16/%E7%94%A8arduino%20uno%20r3%E7%BB%99ESP8266-01WiFi%E6%A8%A1%E5%9D%97%E7%83%A7%E5%86%99%E5%9B%BA%E4%BB%B6/"/>
    <id>https://zhaolilong.com/2020/03/16/用arduino uno r3给ESP8266-01WiFi模块烧写固件/</id>
    <published>2020-03-16T05:55:35.000Z</published>
    <updated>2020-03-16T06:18:51.653Z</updated>
    
    <content type="html"><![CDATA[<p>如何在没有USB转串口烧写器的情况下，直接用arduino uno R3给ESP8266-01WiFi模块烧写固件。</p><a id="more"></a><p>一. 连接esp8266千先连接电脑打开arduino IDE给UNO板写入初始化程序，程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pinMode(<span class="number">0</span>, INPUT_PULLUP);</span><br><span class="line">    pinMode(<span class="number">1</span>, INPUT_PULLUP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/用arduino uno r3给ESP8266-01WiFi模块烧写固件/1584338558.jpg" alt=""></p><p>二. 把esp8826-01连接到UNO板，连接方法如下：</p><p><img src="/2020/03/16/用arduino uno r3给ESP8266-01WiFi模块烧写固件/1584338752.jpg" alt=""></p><p>三. 打开乐鑫官网下载Flash下载工具，添加准备好的bin格式的固件，设置参数，开始下载。具体步骤见下图：</p><p><img src="/2020/03/16/用arduino uno r3给ESP8266-01WiFi模块烧写固件/1584338851.jpg" alt=""></p><p><img src="/2020/03/16/用arduino uno r3给ESP8266-01WiFi模块烧写固件/1584338910.jpg" alt=""></p><p>四. 烧写完成，接下来就是串口调试了，断开GPIO0引脚地连线，打开串口调试工具，选择正确的波特率和端口后点击打开串口，然后插拔CH_PD引脚连线，当出现乱码固件的版本号就显示出来了，OK！</p><p><img src="/2020/03/16/用arduino uno r3给ESP8266-01WiFi模块烧写固件/1584339052.jpg" alt=""></p><blockquote><p>注意事项</p></blockquote><ul><li>在点击开始以后短暂断开CH_PD引脚的接线，重新上电.</li><li>GPIO0引脚必须拉低接GND.</li><li>调试时必须断开GPIO0引脚.</li><li>VCC和CH_PD引脚供电必须为3.3V.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何在没有USB转串口烧写器的情况下，直接用arduino uno R3给ESP8266-01WiFi模块烧写固件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IoT" scheme="https://zhaolilong.com/tags/IoT/"/>
    
      <category term="Arduino" scheme="https://zhaolilong.com/tags/Arduino/"/>
    
  </entry>
  
  <entry>
    <title>实例学习Metal-第十一章 实例渲染</title>
    <link href="https://zhaolilong.com/2020/03/15/%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0Metal-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"/>
    <id>https://zhaolilong.com/2020/03/15/实例学习Metal-第十一章/</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2020-03-13T02:43:22.103Z</updated>
    
    <content type="html"><![CDATA[<p>在本章中，我们将讨论一种通过单个绘制调用有效绘制许多对象的重要技术：实例渲染。此技术可帮助您充分利用GPU，同时将内存和CPU使用率降至最低。</p><p>本章的示例应用程序呈现了数十个动画奶牛在顶部移动随机生成的地形补丁。每头奶牛都有自己的位置，方向和运动方向，所有这些都在每一帧都更新。我们只用两次绘制调用来完成所有这些绘图。该应用程序仅消耗A8处理器上CPU的百分之几，但最大化GPU，每帧绘制超过240,000个三角形。即使有这么大的负载，这样的设备也能够以理想的每秒60帧的速度渲染。</p><a id="more"></a><h1 id="Chapter11-第11章"><a href="#Chapter11-第11章" class="headerlink" title="Chapter11(第11章)"></a>Chapter11(第11章)</h1><h2 id="Instanced-Rendering-实例渲染"><a href="#Instanced-Rendering-实例渲染" class="headerlink" title="Instanced Rendering(实例渲染)"></a>Instanced Rendering(实例渲染)</h2><p>在本章中，我们将讨论一种通过单个绘制调用有效绘制许多对象的重要技术：实例渲染。此技术可帮助您充分利用GPU，同时将内存和CPU使用率降至最低。</p><p>本章的示例应用程序呈现了数十个动画奶牛在顶部移动随机生成的地形补丁。每头奶牛都有自己的位置，方向和运动方向，所有这些都在每一帧都更新。我们只用两次绘制调用来完成所有这些绘图。该应用程序仅消耗A8处理器上CPU的百分之几，但最大化GPU，每帧绘制超过240,000个三角形。即使有这么大的负载，这样的设备也能够以理想的每秒60帧的速度渲染。</p><h3 id="What-is-Instanced-Rendering-什么是实例渲染？"><a href="#What-is-Instanced-Rendering-什么是实例渲染？" class="headerlink" title="What is Instanced Rendering?(什么是实例渲染？)"></a>What is Instanced Rendering?(什么是实例渲染？)</h3><p>虚拟世界经常在场景中拥有许多某些元素的副本：粒子，树叶，敌人等等。这些元素在内存中由单个几何体（网格）和一组特定于应用程序的属性表示。实例化渲染多次绘制相同的几何体，每个实例的属性用于控制它出现的位置和方式。</p><p>实例化渲染也称为“几何实例化”，“实例绘制”，或者有时只是“实例化”。</p><h4 id="Setting-the-Scene-设置场景"><a href="#Setting-the-Scene-设置场景" class="headerlink" title="Setting the Scene(设置场景)"></a>Setting the Scene(设置场景)</h4><p>这一章的虚拟场景是一个田园山坡，有许多流浪的牛。每次应用程序运行时，地形都是唯一生成的，每头牛都有自己的随机运动路径。</p><p><img src="/2020/03/15/实例学习Metal-第十一章/1584067202.png" alt=""></p><center>图11.1：使用实例化渲染可以有效地绘制数十个动画角色。 （草纹理由Simon Murray提供的goodtextures.com）</center><h4 id="Generating-the-Terrain-生成地形"><a href="#Generating-the-Terrain-生成地形" class="headerlink" title="Generating the Terrain(生成地形)"></a>Generating the Terrain(生成地形)</h4><p>地形的特征由称为中点位移的算法创建，也称为“菱形方形”算法。这是一种递归细分地形边缘的技术，并随机向上或向下轻推它们以产生看起来自然的山丘。由于本章的重点是实例绘图而非地形生成，如果您对此技术感到好奇，请参阅示例源代码（请参阅MBETerrainMesh类）。可以在线找到该技术的交互式演示（Boxley 2011）。</p><h4 id="Loading-the-Model-加载模型"><a href="#Loading-the-Model-加载模型" class="headerlink" title="Loading the Model(加载模型)"></a>Loading the Model(加载模型)</h4><p>我们使用前面章节中的OBJ模型加载器来加载牛模型。一旦我们在内存中有一个OBJ模型，我们就会从OBJ文件中的相应组创建一个MBEOBJMesh实例。</p><h4 id="Instanced-Rendering-实例渲染-1"><a href="#Instanced-Rendering-实例渲染-1" class="headerlink" title="Instanced Rendering(实例渲染)"></a>Instanced Rendering(实例渲染)</h4><p>通过发出绘制调用来执行实例渲染，该调用指定应该渲染几何的次数。为了使每个实例都有自己的属性，我们将包含每个实例数据的缓冲区设置为顶点着色器参数表中的缓冲区参数之一。我们还需要传入一个共享的统一缓冲区，它存储所有实例共享的制服。以下是配置用于渲染牛网格的完整参数表：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[commandEncoder setVertexBuffer:cowMesh.vertexBuffer offset:<span class="number">0</span> atIndex:<span class="number">0</span>]; </span><br><span class="line">[commandEncoder setVertexBuffer:sharedUniformBuffer offset:<span class="number">0</span> atIndex:<span class="number">1</span>]; </span><br><span class="line">[commandEncoder setVertexBuffer:cowUniformBuffer offset:<span class="number">0</span> atIndex:<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>现在让我们来看看我们如何在校园里布置制服。</p><h4 id="Storing-Per-Instance-Uniforms-存储每个实例统一量"><a href="#Storing-Per-Instance-Uniforms-存储每个实例统一量" class="headerlink" title="Storing Per-Instance Uniforms(存储每个实例统一量)"></a>Storing Per-Instance Uniforms(存储每个实例统一量)</h4><p>对于每个实例，我们需要一个唯一的模型矩阵和一个相应的正常矩阵。回想一下，常规矩阵用于将网格的法线转换为世界空间。我们还希望将投影矩阵本身存储在共享的统一缓冲区中。我们将Uniforms结构拆分为两个结构：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    matrix_float4x4 viewProjectionMatrix; </span><br><span class="line">&#125; Uniforms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    matrix_float4x4 modelMatrix;</span><br><span class="line">    matrix_float3x3 normalMatrix; </span><br><span class="line">&#125; PerInstanceUniforms;</span><br></pre></td></tr></table></figure><p>共享统一量存储在Metal缓冲区中，该缓冲区可容纳Uniforms类型的单个实例。每个实例的制服缓冲区可以为我们想要呈现的每头牛的一个PerInstanceUniforms实例提供空间：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cowUniformBuffer = [device newBufferWithLength:<span class="keyword">sizeof</span>(PerInstanceUniforms) * MBECowCount</span><br><span class="line">options:<span class="built_in">MTLResourceOptionCPUCacheModeDefault</span>];</span><br></pre></td></tr></table></figure><h4 id="Updating-Per-Instance-Uniforms-更新每个实例统一量"><a href="#Updating-Per-Instance-Uniforms-更新每个实例统一量" class="headerlink" title="Updating Per-Instance Uniforms(更新每个实例统一量)"></a>Updating Per-Instance Uniforms(更新每个实例统一量)</h4><p>因为我们希望奶牛移动，所以我们在名为MBECow的数据模型中存储了一些简单的属性。每一帧，我们更新这些值以将奶牛移动到新位置并旋转它以使其与其行进方向对齐。</p><p>一旦奶牛对象是最新的，我们可以为每头奶牛生成适当的矩阵并将它们写入每个实例缓冲区，以便与下一个绘图调用一起使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PerInstanceUniforms uniforms;</span><br><span class="line">uniforms.modelMatrix = matrix_multiply(translation, rotation); </span><br><span class="line">uniforms.normalMatrix = matrix_upper_left3x3(uniforms.modelMatrix);</span><br><span class="line"><span class="built_in">NSInteger</span> instanceUniformOffset = <span class="keyword">sizeof</span>(PerInstanceUniforms) * instanceIndex; </span><br><span class="line">memcpy([<span class="keyword">self</span>.cowUniformBuffer contents] + instanceUniformOffset, &amp;uniforms, <span class="keyword">sizeof</span>(PerInstanceUniforms));</span><br></pre></td></tr></table></figure><h4 id="Issuing-the-Draw-Call-发给绘制调用"><a href="#Issuing-the-Draw-Call-发给绘制调用" class="headerlink" title="Issuing the Draw Call(发给绘制调用)"></a>Issuing the Draw Call(发给绘制调用)</h4><p>要发给实例化绘图调用，我们在具有<code>instanceCount:</code>参数的渲染命令编码器上使用<code>-drawIndexedPrimitive:</code>方法。在这里，我们传递实例总数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[commandEncoder drawIndexedPrimitives:<span class="built_in">MTLPrimitiveTypeTriangle</span>                                    indexCount:indexCount</span><br><span class="line">                            indexType:<span class="built_in">MTLIndexTypeUInt16</span></span><br><span class="line">                          indexBuffer:cowMesh.indexBuffer</span><br><span class="line">                    indexBufferOffset:<span class="number">0</span> </span><br><span class="line">                        instanceCount:MBECowCount];</span><br></pre></td></tr></table></figure><p>要执行此绘制调用，GPU将多次绘制网格，每次重复使用几何体。但是，我们需要一种在顶点着色器中获取适当矩阵集的方法，这样我们就可以将每头牛转换到它在世界中的位置。为此，我们来看看如何从顶点着色器中获取实例ID。</p><h4 id="Accessing-Per-Instance-Data-in-Shaders-访问着色器中的每实例数据"><a href="#Accessing-Per-Instance-Data-in-Shaders-访问着色器中的每实例数据" class="headerlink" title="Accessing Per-Instance Data in Shaders(访问着色器中的每实例数据)"></a>Accessing Per-Instance Data in Shaders(访问着色器中的每实例数据)</h4><p>要索引每个实例的统一缓冲区，我们使用instance_id属性添加顶点着色器参数。这告诉Metal我们希望它向我们传递一个参数，该参数表示当前正在绘制的实例的索引。然后我们可以在正确的偏移处访问每个实例的uniforms数组并提取适当的矩阵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vertex ProjectedVertex vertex_project(device InVertex *vertices [[buffer(0)]], constant Uniforms &amp;uniforms [[buffer(1)]], constant PerInstanceUniforms *perInstanceUniforms [[buffer(2)]], ushort vid [[vertex_id]], ushort iid [[instance_id]]) </span><br><span class="line">&#123;</span><br><span class="line">    float4x4 instanceModelMatrix = perInstanceUniforms[iid].modelMatrix; </span><br><span class="line">    float3x3 instanceNormalMatrix = perInstanceUniforms[iid].normalMatrix;</span><br></pre></td></tr></table></figure><p>顶点着色器的其余部分很简单。它投影顶点，变换法线，并穿过纹理坐标。</p><h4 id="Going-Further-走得更远"><a href="#Going-Further-走得更远" class="headerlink" title="Going Further(走得更远)"></a>Going Further(走得更远)</h4><p>您可以在每个实例的统一结构中存储所需的任何类型的数据。例如，您可以为每个实例传递颜色，并使用它来唯一地着色每个对象。您可以包含纹理索引，并将索引编入纹理数组，以便为​​某些实例提供完全不同的视觉外观。您还可以将缩放矩阵乘以模型转换，以便为每个实例提供不同的物理大小。基本上任何特征（网格拓扑本身除外）都可以改变，以便为每个实例创建一个独特的外观。</p><h3 id="The-Sample-App-示例应用"><a href="#The-Sample-App-示例应用" class="headerlink" title="The Sample App(示例应用)"></a>The Sample App(示例应用)</h3><p>本章的示例代码位于11-InstancedDrawing目录中。</p><p>您可以通过将手指放在屏幕上向前移动来移动示例应用程序。通过向左或向右平移来转动相机。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本章中，我们将讨论一种通过单个绘制调用有效绘制许多对象的重要技术：实例渲染。此技术可帮助您充分利用GPU，同时将内存和CPU使用率降至最低。&lt;/p&gt;
&lt;p&gt;本章的示例应用程序呈现了数十个动画奶牛在顶部移动随机生成的地形补丁。每头奶牛都有自己的位置，方向和运动方向，所有这些都在每一帧都更新。我们只用两次绘制调用来完成所有这些绘图。该应用程序仅消耗A8处理器上CPU的百分之几，但最大化GPU，每帧绘制超过240,000个三角形。即使有这么大的负载，这样的设备也能够以理想的每秒60帧的速度渲染。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS/Mac" scheme="https://zhaolilong.com/tags/iOS-Mac/"/>
    
      <category term="图形学" scheme="https://zhaolilong.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Metal" scheme="https://zhaolilong.com/tags/Metal/"/>
    
  </entry>
  
  <entry>
    <title>Modbus</title>
    <link href="https://zhaolilong.com/2020/03/12/Modbus/"/>
    <id>https://zhaolilong.com/2020/03/12/Modbus/</id>
    <published>2020-03-12T07:07:32.000Z</published>
    <updated>2020-03-13T00:56:09.642Z</updated>
    
    <content type="html"><![CDATA[<p>Modbus是一个通信协议，它可以用来发送和接收数据通过一条串行总线，像RS232和RS485总线。在本章中，你将学习到如何使用Modbus通讯协议通过RS485总线来连接工业设备到您的基于Arduino的PLC（可编程序逻辑控制器）。Modbus使用master-slave（主-从）架构，配置一个节点作为master（例如，Arduino PLC）并配置其他设备作为slaves（温度传感器，湿度传感器，光传感器等等）。使用RS485的好处是它仅仅使用两条共享线来连接所有设备（slaves）到主节点上。它也支持远距离以及电噪声环境中设备的使用。</p><a id="more"></a><p>Modbus</p><p>  Modbus是一个通信协议，它可以用来发送和接收数据通过一条串行总线，像RS232和RS485总线。在本章中，你将学习到如何使用Modbus通讯协议通过RS485总线来连接工业设备到您的基于Arduino的PLC（可编程序逻辑控制器）。Modbus使用master-slave（主-从）架构，配置一个节点作为master（例如，Arduino PLC）并配置其他设备作为slaves（温度传感器，湿度传感器，光传感器等等）。使用RS485的好处是它仅仅使用两条共享线来连接所有设备（slaves）到主节点上。它也支持远距离以及电噪声环境中设备的使用。</p><p>  为了连接您的Arduino PLC到Modbus通信协议开启设备，首先你应当添加一些硬件模块到Arduino中为了开启它作为一个Modbus主节点。</p><p>  <strong>RS485/Modbus模块</strong>是一个理想组件，它可以用来在您的Arduino主板上开启Modbus通信协议。另外，你需要一个板子来与您的Arduino连接和交互。市场上有很多Arduino的RS485/Modbus模块。</p><p>  为了搭建开启RS485和Modbus的Arduino PLC，需要下列操作：<br>    * Multiprotocol Radio Shield（多协议无线电板)<br>    * RS485/Modbus模块</p><h3 id="多协议无线电板"><a href="#多协议无线电板" class="headerlink" title="多协议无线电板"></a>多协议无线电板</h3><p>来自Cooking Hacks的多协议无线电板是Arduino UNO搭建开启Modbus PLCs的理想兼容板。该板被设计为同时连接两个通信模块。<br><img src="/2020/03/12/Modbus/1583998593.png" alt=""></p><p><strong>图 7-1.</strong> 来自Cooking Hacks的多协议无线电板。图片由Libelium提供（<a href="http://www.cooking-hacks.com" target="_blank" rel="noopener">http://www.cooking-hacks.com</a>)</p><blockquote><p><strong>注意</strong>    多协议板有两个插口（Figure 7-2)，你可以用来连接任何开启UART（通用异步收发传输器）的硬件模块。两个插口被命名为SOCKET0和SOCKET1。插口是由2mm母排针组成的，它一共有20个连接。（UART代表通用一步收发传输器并且它是最流行的串行协议。）</p></blockquote><p><img src="/2020/03/12/Modbus/1583999579.png" alt=""></p><p><strong>图 7-2.</strong> 多协议无线电板的顶视图。图片由Libelium提供（<a href="http://www.cooking-hacks.com" target="_blank" rel="noopener">http://www.cooking-hacks.com</a>)</p><p>  所有插口开启SPI（串行外设接口），所以你可以连接<strong>RS485，RS232，</strong>CAN(Controller Area Network控制局域网路) 总线<strong>模块</strong>到它们上面。对于<strong>SOCKET0，</strong>SPI使用<strong>3.3V</strong>电平，SOCKET1，SPI使用<strong>5V</strong>电平。</p><p>  有<strong>两个</strong>绕线式接头被焊接到板子上，所以您可以连接它们到任何Arduino UNO或者兼容的板子上。板子物理连接到Arduino像下面这样。</p><ul><li><p><strong>Header 1</strong>：Arduino数字引脚，0到7有八个连接。</p></li><li><p><strong>Header 2</strong>：Arduino模拟引脚，A0到A5有六个连接。</p><p>板子也包含<strong>数字开关</strong>来开启和禁用两个插口。您可以使用Arduino IDE中软件定义的库函数控制它们。</p></li></ul><h3 id="Arduino和树莓派的RS485-Modbusm模块"><a href="#Arduino和树莓派的RS485-Modbusm模块" class="headerlink" title="Arduino和树莓派的RS485/Modbusm模块"></a>Arduino和树莓派的RS485/Modbusm模块</h3><p>  <strong>对于Arduino和树莓派的RS485/Modbus模块</strong>允许你仅仅用两根线就可以连接多于一个的工业设备到Arduino上。你可以通过带有唯一标识的设备使用两根共享线最多连接<strong>32个设备</strong>到Arduino。</p><p><img src="/2020/03/12/Modbus/1584000687.png" alt=""></p><p><strong>图 7-3.</strong> Arduino和树莓派的RS485/Modbus模块。图片由Libelium提供（<a href="http://www.cooking-hacks.com" target="_blank" rel="noopener">http://www.cooking-hacks.com</a>)</p><p>  表7-1展示了一些Arduino和树莓派的RS485/Modbus模块的技术说明，由Cooking Hacks发布。</p><table><thead><tr><th>Standard</th><th>EIA RS485</th></tr></thead><tbody><tr><td><strong>Physical Media</strong></td><td>Twisted Pair</td></tr><tr><td><strong>Network Topology</strong></td><td>Point-to-point, multi-dropped, multi-point</td></tr><tr><td><strong>Maximum Devices</strong></td><td>Maximum Devices</td></tr><tr><td><strong>Voltage Levels</strong></td><td>-7V to +12V</td></tr><tr><td><strong>Mark(1)</strong></td><td>Positive voltages (B-A &gt; +200mV)</td></tr><tr><td><strong>Space(0)</strong></td><td>Negative voltages (B-A &lt; -200mV)</td></tr><tr><td><strong>Available Signals</strong></td><td>Tx+/Rx+, Tx-/Rx-(Half Duplex)Tx+,Tx-,Rx+,Rx-(Full Duplex)</td></tr></tbody></table><p><strong>表 7-1.</strong> Arduino和树莓派的RS485/Modbus模块技术说明</p><h3 id="为Arduino安装RS485库"><a href="#为Arduino安装RS485库" class="headerlink" title="为Arduino安装RS485库"></a>为Arduino安装RS485库</h3><p>为了与<strong>RS485</strong>一起工作，首先你应该安装<strong>Arduino的RS485库</strong>。使用以下步骤来安装它到Arduino IDE。</p><pre><code>1. 接下下载的zip文件，RS485_for_Arduino(参见第一章的“Modbus RS485库”部分获得更多关于下载链接的信息）。使用任何压缩软件。你将得到一个名为RS485_for_Arduino的文件夹。2. 文件夹结构和下面的层级非常相似：RS485_for_Arduino                    -&gt; RS485                                -&gt; ModBusMaster485                                -&gt; ModbusSlave485                                -&gt; RS485拷贝ModBusMaster485，ModbusSlave485和RS485文件夹到你的Arduino安装的*libraries*文件夹。3. 最终，重启Arduino IDE并确认是否你可以看见样例sketches通过选择File ➤ Examples ➤ RS485</code></pre><p>如果你可以看见它们，你已经为Arduino成功安装了RS485库。</p><h3 id="用Modbus搭建PLC"><a href="#用Modbus搭建PLC" class="headerlink" title="用Modbus搭建PLC"></a>用Modbus搭建PLC</h3><p>  现在，您将学习如何将温度传感器与Arduino接口，以通过RS485总线使用Modbus通信协议。然后你将学习如何读取传感器值从温度传感器并再Arduino串行显示器上显示它们。</p><h4 id="搭建硬件设置"><a href="#搭建硬件设置" class="headerlink" title="搭建硬件设置"></a>搭建硬件设置</h4><p>搭建硬件设置，需要做下面的事情。</p><ul><li>Arduino UNO</li><li>多协议无线电板</li><li>Arduino的RS485/Modbus模块</li><li>TQS3-I MODBUS RS485 室内温度计</li></ul><p>以下步骤将贯穿整个构建过程。</p><pre><code>1. 使用绕线式接头连接**多协议无线电板**到Arduino UNO上（图 7-4）。2. 连接Arduino的RS485/Modbus模块，树莓派连接到**SOCKET1**（图 7-4）。![](1584002689.png)**图 7-4.** Arduino设置RS485和Modbus。图片由Libelium提供（[http://www.cooking-hacks.com](http://www.cooking-hacks.com)3. **温度传感器**我们将使用来自**PAPOUCH**([www.papouch.com](www.papouch.com))**TQS3-I Modbus RS485室内温度计（图 7-5）。**它支持**Modbus**和**Spinel**通信协议通过**RS485总线**。你可以从[http://www.papouch.com/en/shop/product/tqs3-i-rs485interior-thermometer/tqs3.pdf/_downloadFile.php](http://www.papouch.com/en/shop/product/tqs3-i-rs485interior-thermometer/tqs3.pdf/_downloadFile.php)下载这个产品的文档。</code></pre><p> <img src="/2020/03/12/Modbus/1584003116.png" alt=""></p><p> <strong>图 7-5.</strong> TQS3-I Modbus RS485室内温度计。图片由Papouch提供（<a href="http://www.papouch.com" target="_blank" rel="noopener">http://www.papouch.com</a></p><p>   <strong>Wago接线端</strong>位于装置内部，用于连接电源和RS485。图7-6显示了标有电源的接线端和RS485连接。</p><ul><li><p>连接7-20V的直流供电，使用+极和-极。</p></li><li><p>连接RS485总线，使用TX+和TX-端。</p><p><img src="/2020/03/12/Modbus/1584004096.png" alt=""></p></li></ul><p><strong>图 7-6.</strong> Wago接线端。图片由Papouch提供（<a href="http://www.papouch.com" target="_blank" rel="noopener">http://www.papouch.com</a></p><p>   默认的情况下，这个温度传感器配置使用<strong>Spinel</strong>协议（<a href="http://www.papouch.com/en/website/mainmenu/spinel/" target="_blank" rel="noopener">http://www.papouch.com/en/website/mainmenu/spinel/</a>）来通信。对于<strong>Modbus RTU协议</strong>简单的跳线设置可以用来配置它，如图7-7所示，通过缩短安装跳线。</p><p>   <img src="/2020/03/12/Modbus/1584004381.png" alt=""></p><p><strong>图 7-7.</strong> 缩短跳线的设置来启用Modbus RTU。图片由Papouch提供（<a href="http://www.papouch.com" target="_blank" rel="noopener">http://www.papouch.com</a></p><p>  现在用两条线连接<strong>温度传感器</strong>到<strong>Arduino和树莓派</strong>的RS485/Modbus模块，如图7-8所示。</p><pre><code>  1. 连接温度传感器的TX+端到RS485模块标有**A**的一端（同相信号）。  2. 连接温度传感器的TX-端到RS485模块标有**B**的一端（反相信号）。  ![](1584004721.png)**图 7-7.** 信号线端。Image courtesy of Libelium ([https://www.cooking-hacks.com](https://www.cooking-hacks.com)) 3. 使用壁式电源适配器将7-20V之间的DC电源连接到标有+和-的端。</code></pre><h4 id="Arduino-Sketch"><a href="#Arduino-Sketch" class="headerlink" title="Arduino Sketch"></a>Arduino Sketch</h4><p>RS485库中提供了现成的Arduino草图。使用以下步骤来修改草图按照你的Modbus设备。</p><pre><code>1. 开启你的Arduino IDE并选择File ➤ Examples ➤ RS485 ➤ _RS485_04_modbus_read_input_registers，打开名为_RS485_04_modbus_read_input_registers.ino，如清单7-1所示。文件将打开一个新的窗口。</code></pre><p><strong>清单 7-1</strong> 使用Modbus读取温度传感器示例（_RS485_04_modbus_read_input_register.ino）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;RS485.h&gt; </span><br><span class="line">#include &lt;ModbusMaster485.h&gt; </span><br><span class="line">#include &lt;SPI.h&gt;</span><br><span class="line"></span><br><span class="line">// Instantiate ModbusMaster object as slave ID 1 ModbusMaster485 node(254);</span><br><span class="line"></span><br><span class="line">// Define one address for reading </span><br><span class="line">#define address 101</span><br><span class="line">// Define the number of bytes to read </span><br><span class="line">#define bytesQty 2</span><br><span class="line"></span><br><span class="line">void setup() &#123;</span><br><span class="line">    // Power on the USB for viewing data in the serial monitor </span><br><span class="line">    Serial.begin(115200); </span><br><span class="line">    delay(100); </span><br><span class="line">    // Initialize Modbus communication baud rate </span><br><span class="line">    node.begin(19200);</span><br><span class="line"></span><br><span class="line">    // Print hello message </span><br><span class="line">    Serial.println(&quot;Modbus communication over RS-485&quot;);</span><br><span class="line">    delay(100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loop() &#123;</span><br><span class="line">    // This variable will store the result of the communication </span><br><span class="line">    // result = 0 : no errors </span><br><span class="line">    // result = 1 : error occurred</span><br><span class="line">    int result = node.readHoldingRegisters(address, bytesQty);</span><br><span class="line">    if (result != 0) &#123; </span><br><span class="line">        // If no response from the slave, print an error message </span><br><span class="line">        Serial.println(&quot;Communication error&quot;); </span><br><span class="line">        delay(1000); </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // If all OK </span><br><span class="line">        Serial.print(&quot;Read value : &quot;);</span><br><span class="line"></span><br><span class="line">        // Print the read data from the slave </span><br><span class="line">        Serial.print(node.getResponseBuffer(0)); </span><br><span class="line">        delay(1000);</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.print(&quot;\n&quot;); </span><br><span class="line">    delay(2000);</span><br><span class="line">    // Clear the response buffer </span><br><span class="line">    node.clearResponseBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>2. 现在按照你的温度传感器的存储寄存器地址修改Arduino草图中address变量的值。看到产品数据清单来找到存储寄存器的正确地址，如表7-2。**表 7-2. 存储寄存器的说明</code></pre><table><thead><tr><th>Address</th><th>Acess</th><th>Function</th><th>Description</th></tr></thead><tbody><tr><td>102</td><td>Read</td><td>0x03</td><td>RAW value, which is the value as it was received from the sensors</td></tr></tbody></table><p>  在该示例中，温度值被存储在地址102并且可以被函数readHoldingRegisters()读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Define one address for reading </span><br><span class="line">#define address 102</span><br></pre></td></tr></table></figure><pre><code>3. 修改寄存器的大小（以字节为单位）。在该示例中，存储寄存器在地址102可以存储四个字节的数据。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Define the number of bytes to read </span><br><span class="line">#define bytesQty 4</span><br></pre></td></tr></table></figure><pre><code>4. 以下语句将存储ngreadHoldingRegisters()返回的结果。结果为0表示无错误，结果为1表示已发生错误。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int result = node.readHoldingRegisters(address, bytesQty);</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">    5. 要从响应缓冲区中检索数据，请在loop（）函数内使用以下语句。</span><br></pre></td></tr></table></figure><p>getResponseBuffer(0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    6. 您可以使用以下语句在Arduino串行监视器上打印来自温度传感器的数据：</span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line">Serial.print(node.getResponseBuffer(0));</span><br></pre></td></tr></table></figure><pre><code>7. 读取数据后，不要忘记清除响应缓冲区。您可以使用clearResponseBuffer（）;功能清除响应缓冲区。8. 现在，验证并将Arduino草图上传到Arduino开发板。成功上传草图后，通过选择工具➤串行监视器打开Arduino串行监视器。串行监视器将打印存储在响应缓冲区中的值，如图7-9所示。</code></pre><p><img src="/2020/03/12/Modbus/1584006631.png" alt=""></p><p><strong>图 7-9.</strong> Arduino串行显示器输出（读取响应缓冲）</p><p>通过使用温度传感器数据表中提到的conversion公式，可以将输出值进一步转换为摄氏或华氏温度。但是某些启用了Modbus的设备可以直接以摄氏度或华氏度输出所需的值，而无需进行任何进一步的转换。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本章中，您学习了如何通过RS485总线使用Modbus通信协议将工业设备连接到基于Arduino的PLC并编写基于RS485库的Arduino草图。您还学习了如何从启用了Modbus通信协议的设备中读取值。在下一章中，您将学习如何使用NearBus Cloud Connector将基于Arduino的PLC映射到云中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Modbus是一个通信协议，它可以用来发送和接收数据通过一条串行总线，像RS232和RS485总线。在本章中，你将学习到如何使用Modbus通讯协议通过RS485总线来连接工业设备到您的基于Arduino的PLC（可编程序逻辑控制器）。Modbus使用master-slave（主-从）架构，配置一个节点作为master（例如，Arduino PLC）并配置其他设备作为slaves（温度传感器，湿度传感器，光传感器等等）。使用RS485的好处是它仅仅使用两条共享线来连接所有设备（slaves）到主节点上。它也支持远距离以及电噪声环境中设备的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Modbus" scheme="https://zhaolilong.com/tags/Modbus/"/>
    
      <category term="Ardunio" scheme="https://zhaolilong.com/tags/Ardunio/"/>
    
  </entry>
  
  <entry>
    <title>实例学习Metal-第十章 半透明和透明</title>
    <link href="https://zhaolilong.com/2020/03/08/%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0Metal-%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <id>https://zhaolilong.com/2020/03/08/实例学习Metal-第十章/</id>
    <published>2020-03-07T16:00:00.000Z</published>
    <updated>2020-03-13T02:39:31.983Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，我们在探索金属时已经轻易避免的一个主题是渲染不透明的材料。在本章中，我们将探讨一些实现透明度和半透明度的相关技术：alpha测试和alpha混合。</p><p>本章的示例场景是一片沙漠，里面有许多棕榈树和几个水池。棕榈树的叶子由几个多边形组成，纹理部分透明纹理，水通过alpha混合呈现为半透明表面，我们将在下面详细讨论。</p><a id="more"></a><h1 id="Chapter-10-第十章"><a href="#Chapter-10-第十章" class="headerlink" title="Chapter 10(第十章)"></a>Chapter 10(第十章)</h1><h2 id="Translucency-and-Transparency-半透明和透明"><a href="#Translucency-and-Transparency-半透明和透明" class="headerlink" title="Translucency and Transparency(半透明和透明)"></a>Translucency and Transparency(半透明和透明)</h2><p>到目前为止，我们在探索金属时已经轻易避免的一个主题是渲染不透明的材料。在本章中，我们将探讨一些实现透明度和半透明度的相关技术：alpha测试和alpha混合。</p><p>本章的示例场景是一片沙漠，里面有许多棕榈树和几个水池。棕榈树的叶子由几个多边形组成，纹理部分透明纹理，水通过alpha混合呈现为半透明表面，我们将在下面详细讨论。</p><h3 id="What-is-Alpha-Anyway-无论如何，Alpha是什么？"><a href="#What-is-Alpha-Anyway-无论如何，Alpha是什么？" class="headerlink" title="What is Alpha, Anyway?(无论如何，Alpha是什么？)"></a>What is Alpha, Anyway?(无论如何，Alpha是什么？)</h3><p>Alpha是颜色值的不透明度(或覆盖率)。 alpha值越高，颜色越不透明。 alpha值为0表示总透明度，而值为1(或100％)表示总不透明度。当根据片段颜色说话时，数据组件指示片段后面的场景显示的程度。请参阅(Glassner 2015)对基础知识的严格讨论。</p><p><img src="/2020/03/08/实例学习Metal-第十章/1584066843.png" alt=""></p><center>图10.1：示例应用程序演示了alpha测试和alpha混合</center><h3 id="Alpha-Testing-透明度测试"><a href="#Alpha-Testing-透明度测试" class="headerlink" title="Alpha Testing(透明度测试)"></a>Alpha Testing(透明度测试)</h3><p>我们将用于渲染部分透明表面的第一种技术是<code>alpha testing</code>。</p><p>透明度测试允许我们通过比较其不透明度与阈值(称为<code>参考值</code>)来确定片段是否应该对存储在渲染缓冲区中的颜色做出贡献。 透明度测试用于使表面<code>选择性</code>透明。</p><p>透明度测试的一个常见应用是渲染树叶，其中相对较少的多边形可用于描述树叶的形状，并且叶子纹理的alpha通道可用于确定绘制哪些像素和不绘制哪些像素。</p><p><img src="/2020/03/08/实例学习Metal-第十章/1584066892.png" alt=""></p><center>图10.2：透明度测试允许我们绘制部分透明的棕榈叶</center><h3 id="Alpha-Testing-in-Metal-Metal中的透明度测试"><a href="#Alpha-Testing-in-Metal-Metal中的透明度测试" class="headerlink" title="Alpha Testing in Metal(Metal中的透明度测试)"></a>Alpha Testing in Metal(Metal中的透明度测试)</h3><p>Metal中的透明度测试是在片段函数中实现的。着色器文件包含全局参考值（示例应用程序中为0.5），我们的alpha值将与之进行比较。片段函数对棕榈树的漫反射纹理进行采样，对于应该是透明的纹素，其alpha值为0。然后使用采样的颜色来确定片段是否应该是可见的。</p><h4 id="The-‘discard-fragment’-function-discard-fragment函数"><a href="#The-‘discard-fragment’-function-discard-fragment函数" class="headerlink" title="The ‘discard_fragment’ function(discard_fragment函数)"></a>The ‘discard_fragment’ function(discard_fragment函数)</h4><p>为了向Metal指示我们不想为片段提供颜色，我们不能简单地将返回的alpha值设置为0.如果我们这样做，片段深度仍会被写入深度缓冲区，从而导致任何几何隐藏在“透明”点之后。</p><p>相反，我们需要调用一个特殊的函数来避免完全为片段指定颜色值：<code>discard_fragment</code>。调用此函数可防止Metal将片段的计算深度和颜色值写入帧缓冲区，从而允许片段后面的场景显示。</p><h5 id="The-Texture-Alpha-Channel-纹理Alpha通道"><a href="#The-Texture-Alpha-Channel-纹理Alpha通道" class="headerlink" title="The Texture Alpha Channel(纹理Alpha通道)"></a>The Texture Alpha Channel(纹理Alpha通道)</h5><p>要执行每片段alpha测试，我们需要一个特殊构造的纹理，其alpha通道中包含合适的覆盖信息。下图显示了示例应用程序中使用的棕榈叶纹理。</p><p><img src="/2020/03/08/实例学习Metal-第十章/1584066914.png" alt=""></p><center>图10.3：用于在示例应用程序中绘制棕榈叶的纹理。不绘制图像的透明部分。</center><h5 id="Performing-the-Alpha-Test-执行Alpha测试"><a href="#Performing-the-Alpha-Test-执行Alpha测试" class="headerlink" title="Performing the Alpha Test(执行Alpha测试)"></a>Performing the Alpha Test(执行Alpha测试)</h5><p>片段着色器中alpha测试的实现非常简单。将我们刚刚讨论的技术集合在一起，我们根据阈值测试采样的alpha值，并丢弃未通过alpha测试的任何片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float4 textureColor = texture.sample(texSampler, vert.texCoords);</span><br><span class="line">if (textureColor.a &lt; kAlphaTestReferenceValue) </span><br><span class="line">    discard_fragment();</span><br></pre></td></tr></table></figure><h4 id="A-Note-on-Performance-关于绩效的说明"><a href="#A-Note-on-Performance-关于绩效的说明" class="headerlink" title="A Note on Performance(关于绩效的说明)"></a>A Note on Performance(关于绩效的说明)</h4><p>使用<code>discard_fragment</code>会影响性能。特别是，它可以防止硬件执行称为<code>早期深度测试</code>（有时称为<code>早期z</code>）的优化。</p><p>通常，硬件可以在调用片段函数之前确定片段是否有助于渲染缓冲区，因为片段深度是在光栅化器中计算的。这意味着它可以避免着色已知被其他几何体遮挡的碎片块。</p><p>另一方面，如果要使用包含条件<code>discard_fragment</code>调用的函数对片段进行着色，则无法应用此优化，并且硬件必须为每个可能可见的片段调用着色器。</p><p>在本章的示例代码中，我们为几何体提供了单独的片段函数，这些函数使用alpha测试而不是。 alpha测试函数应仅用于实际需要它的几何体，因为过度使用<code>discard_fragment</code>会对性能产生很大的负面影响。</p><p>早期深度测试的完整解释超出了本书的范围，但Fabien Giesen的博客系列(Giesen 2011)提供了有关深度测试和与现代3D渲染管道相关的许多其他主题的更多详细信息。</p><h4 id="Alpha-Blending-透明度混合"><a href="#Alpha-Blending-透明度混合" class="headerlink" title="Alpha Blending(透明度混合)"></a>Alpha Blending(透明度混合)</h4><p>另一种实现透明度的有用技术是<code>透明度混合</code>。</p><p>通过在渲染缓冲区（目标）中已有的颜色和当前被遮蔽的片段（源）之间进行插值来实现透明度混合。使用的确切公式取决于所需的效果，但对于我们当前的目的，我们将使用以下等式：</p><p>c<sub>f</sub> =α<sub>s</sub> ×c<sub>s</sub> +(1−α<sub>s</sub>)×c<sub>d</sub></p><p>其中c<sub>s</sub>和c<sub>d</sub>分别是源和目标颜色的RGB分量; α<sub>s</sub>是源颜色的不透明度;和c<sub>f</sub>是碎片的最终混合颜色值。</p><p>用文字表示，这个公式说：我们将源颜色的不透明度乘以源颜色的RGB分量，产生片段对最终颜色的贡献。这将添加到不透明度的加法倒数乘以渲染缓冲区中已有的颜色。这将“混合”两种颜色以创建写入渲染缓冲区的新颜色。</p><h3 id="Alpha-Blending-in-Metal-Metal中的透明度混合"><a href="#Alpha-Blending-in-Metal-Metal中的透明度混合" class="headerlink" title="Alpha Blending in Metal(Metal中的透明度混合)"></a>Alpha Blending in Metal(Metal中的透明度混合)</h3><p>在本章的示例项目中，我们使用alpha混合来使水面半透明。这种效果在计算上是便宜的并且不是特别令人信服，但它可以补充立方体图反射或在水面上滑动纹理或物理地移动它的动画。</p><h3 id="Enabling-Blending-in-the-Pipeline-State-在管道状态中启用混合"><a href="#Enabling-Blending-in-the-Pipeline-State-在管道状态中启用混合" class="headerlink" title="Enabling Blending in the Pipeline State(在管道状态中启用混合)"></a>Enabling Blending in the Pipeline State(在管道状态中启用混合)</h3><p>在Metal中混合有两种基本方法：固定功能和可编程。我们将在本节讨论固定功能混合。固定功能混合包括在渲染管道描述符的颜色附件描述符上设置属性。这些属性确定片段函数返回的颜色如何与像素的现有颜色组合以生成最终颜色。</p><p>为了使接下来的几个步骤更简洁，我们保存了对颜色附件的引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MTLRenderPipelineColorAttachmentDescriptor *renderbufferAttachment = pipelineDescriptor.colorAttachments[0];</span><br></pre></td></tr></table></figure><p>要启用混合，请将blendingEnabled设置为YES：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderbufferAttachment.blendingEnabled = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure><p>接下来，我们选择用于组合加权颜色和透明度分量的操作。在这里，我们选择<code>Add</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderbufferAttachment.rgbBlendOperation = <span class="built_in">MTLBlendOperationAdd</span>; renderbufferAttachment.alphaBlendOperation = <span class="built_in">MTLBlendOperationAdd</span>;</span><br></pre></td></tr></table></figure><p>现在我们需要指定源颜色和透明度的加权因子。我们选择SourceAlpha因子，以匹配上面给出的公式。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderbufferAttachment.sourceRGBBlendFactor = <span class="built_in">MTLBlendFactorSourceAlpha</span>; renderbufferAttachment.sourceAlphaBlendFactor = <span class="built_in">MTLBlendFactorSourceAlpha</span>;</span><br></pre></td></tr></table></figure><p>最后，我们选择目标颜色和透明度的加权因子。这些是源颜色因子的加法逆运算，OneMinusSourceAlpha：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renderbufferAttachment.destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;</span><br><span class="line">renderbufferAttachment.destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;</span><br></pre></td></tr></table></figure><h4 id="The-Alpha-Blending-Fragment-Shader-透明度混合碎片着色器"><a href="#The-Alpha-Blending-Fragment-Shader-透明度混合碎片着色器" class="headerlink" title="The Alpha Blending Fragment Shader(透明度混合碎片着色器)"></a>The Alpha Blending Fragment Shader(透明度混合碎片着色器)</h4><p>片段着色器返回它为其片段计算的颜色。在前面的章节中，此颜色的alpha分量无关紧要，因为未启用混合。现在，我们需要确保着色器返回的alpha分量表示片段所需的不透明度。此值将用作在渲染管道状态上配置的混合方程中的“源”alpha值。</p><p>在示例代码中，我们将采样的漫反射纹理颜色与当前顶点颜色相乘，以获得片段的源颜色。由于纹理是不透明的，因此顶点颜色的alpha分量变为水的不透明度。将此值作为alpha的alpha传递片段颜色的返回值根据先前配置颜色附件的方式生成alpha混合。</p><p><img src="/2020/03/08/实例学习Metal-第十章/1584067144.png" alt=""></p><center>图10.4：Alpha混合允许沙漠沙漠通过清澈的水面</center><h4 id="Order-Dependent-Blending-versus-Order-Independent-Blending-依赖于顺序的混合与顺序无关的混合"><a href="#Order-Dependent-Blending-versus-Order-Independent-Blending-依赖于顺序的混合与顺序无关的混合" class="headerlink" title="Order-Dependent Blending versus Order-Independent Blending(依赖于顺序的混合与顺序无关的混合)"></a>Order-Dependent Blending versus Order-Independent Blending(依赖于顺序的混合与顺序无关的混合)</h4><p>在渲染半透明表面时，顺序很重要。为了使透明度混合生成正确的图像，应在所有不透明对象之后渲染半透明对象。另外，相对于相机，它们应该从后端到前端。由于顺序取决于视图位置和方向，因此每当相对顺序发生变化时，通常每当相机移动时，都需要对对象进行重新排序。</p><p>我们在示例应用程序中完全避免了这个问题，因为在场景中只有一个凸出的半透明表面：水。其他应用程序不会那么容易。</p><p>在过去几年中，已经有很多关于避免这种昂贵的分选步骤的方法的研究。一种技术使用所谓的A缓冲（由Carpenter于1984年引入（Carpenter 1984））来维持对每个像素贡献的片段的一对颜色和深度值。然后将这些片段分类并在第二轮中混合。<br>最近，研究强调了alpha复合本身的数学，试图推导出一种与订单无关的透明度解决方案。有关此技术的进展，请参阅McGuire和Bavoil的论文(McGuire和Bavoil 2013)。</p><h3 id="示例应用"><a href="#示例应用" class="headerlink" title="示例应用"></a>示例应用</h3><p>本章的示例代码位于10-AlphaBlending目录中。按屏幕可使摄像机沿其当前航向前进，同时向左或向右平移会改变摄像机前进的方向。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到目前为止，我们在探索金属时已经轻易避免的一个主题是渲染不透明的材料。在本章中，我们将探讨一些实现透明度和半透明度的相关技术：alpha测试和alpha混合。&lt;/p&gt;
&lt;p&gt;本章的示例场景是一片沙漠，里面有许多棕榈树和几个水池。棕榈树的叶子由几个多边形组成，纹理部分透明纹理，水通过alpha混合呈现为半透明表面，我们将在下面详细讨论。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS/Mac" scheme="https://zhaolilong.com/tags/iOS-Mac/"/>
    
      <category term="图形学" scheme="https://zhaolilong.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Metal" scheme="https://zhaolilong.com/tags/Metal/"/>
    
  </entry>
  
</feed>
