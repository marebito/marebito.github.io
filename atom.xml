<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博伊卡の楼閣</title>
  
  <subtitle>逆水行舟，不进则退</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhaolilong.com/"/>
  <updated>2018-11-21T23:52:12.000Z</updated>
  <id>https://zhaolilong.com/</id>
  
  <author>
    <name>Boyka·Yuri</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>增强现实交互</title>
    <link href="https://zhaolilong.com/2018/06/20/%E5%A2%9E%E5%BC%BA%E7%8E%B0%E5%AE%9E%E4%BA%A4%E4%BA%92/"/>
    <id>https://zhaolilong.com/2018/06/20/增强现实交互/</id>
    <published>2018-06-20T08:47:03.000Z</published>
    <updated>2018-11-21T23:52:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在真实世界场景中显示虚拟物体可能是很有趣的，但是你想做得更多而不仅仅是在一个场景上覆盖静态图片。另外在场景中显示虚拟物体，ARKit也可以使得虚拟物体在屏幕上移动，给用户与虚拟物体交互的能力，通过触摸手势，例如点击或者滑动。</p><a id="more"></a><p>例如，一个用户可能想点击一个虚拟物体来使得它移动或者以某种方式响应，例如改变它的外观或者在屏幕上移动。通过制作增强现实交互，你的应用可能更感兴趣和赞同。</p><blockquote><p><strong>注意</strong> 你仅仅可以测试和运行ARKit应用在iPhone 6s或者更高，或者一个iPad Pro上。</p></blockquote><p>让我们创建一个新的增强现实应项目，命名为ARGesture。这个项目将包含一个AppDelegate.swift文件，一个ViewController.swift文件和一个Main.storyboard文件，还有art.scnassets文件夹，它包含了一个ship.scn对象和一个texture.png文件。</p><p>我们的目标是创建一个几何模型并在屏幕上显示它。然后用户可以在那个模型上滑动并使得它旋转。为了做到这点，我们将需要学习一些技能。</p><p>首先，大多数人熟悉操作几何模型使用角度，但是苹果的SceneKit框架使用弧度。我们可以编写我们自己的公式去转换角度到弧度，但是苹果提供了一个数学框架叫作GLKit，它包含了一个可以执行这个计算的函数。作为一个通用的规则，尽可能依赖苹果框架总是最好的，而不是编写你自己的函数，因为苹果框架被测试过，而你讲不得不花费时间调试和测试你自己的函数。</p><p>在ViewController.swift文件的顶部，添加以下行导入GLKit框架</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GLKit</span><br></pre></td></tr></table></figure><p>你的ViewController.swift文件应该导入GLKit，UIKit，SceneKit和ARKit框架总共四个import语句。</p><p>接下来，我们需要创建一个节点，该节点代表我们想添加到屏幕上的几何模型。这意味着创建一个SCNNode对象。因为我们将需要访问这个对象在不止一个方法中，创建这个作为一个IBOutlet属性，所以ViewController.swift文件顶部应当看起来像这样:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br><span class="line"><span class="keyword">import</span> GLKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> sceneView: <span class="type">ARSCNView</span>!</span><br><span class="line">    <span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br></pre></td></tr></table></figure><p>在viewDidLoad函数中，我们可以添加调试选项，将在屏幕上显示世界原点。你可能不想显示世界原点在最终的应用中，但是它可以当你开发应用时是有用的，显示给你虚拟物体出现在屏幕的位置。添加以下行在viewDidLoad函数中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br></pre></td></tr></table></figure><h2 id="存储和访问图形资产"><a href="#存储和访问图形资产" class="headerlink" title="存储和访问图形资产"></a>存储和访问图形资产</h2><p>现在我们需要创建一个几何模型。在这种情况下，我们想创建一个金字塔，所以我们将需要定义它的宽，高和长。另外，我们也想去应用一个纹理到我们的金字塔上。</p><p>增强现实应用项目引入了两个图像文件：ship.scn和texture.png。我们将不显示ship.scn文件，所以你可以删除代码，显示这个ship.scn在屏幕上。然而，我们想去使用texture.png文件。</p><p>在前一章节中，你看到了如何使用一个纹理图像图片通过简单地定义它的名字像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> material = <span class="type">SCNMaterial</span>()</span><br><span class="line">material.diffuse.contents = <span class="type">UIImage</span>(named: <span class="string">"stone.jpg"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在真实世界场景中显示虚拟物体可能是很有趣的，但是你想做得更多而不仅仅是在一个场景上覆盖静态图片。另外在场景中显示虚拟物体，ARKit也可以使得虚拟物体在屏幕上移动，给用户与虚拟物体交互的能力，通过触摸手势，例如点击或者滑动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AR" scheme="https://zhaolilong.com/tags/AR/"/>
    
      <category term="增强现实" scheme="https://zhaolilong.com/tags/%E5%A2%9E%E5%BC%BA%E7%8E%B0%E5%AE%9E/"/>
    
  </entry>
  
  <entry>
    <title>Metal编程指南</title>
    <link href="https://zhaolilong.com/2018/06/10/Metal%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <id>https://zhaolilong.com/2018/06/10/Metal编程指南/</id>
    <published>2018-06-10T02:03:53.000Z</published>
    <updated>2018-11-21T23:58:33.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>[Metal基础概念] 简明的描述Metal的主要特性。</li><li>[命令组成和执行模型] 解释如何创建和提交命令到GPU执行。</li><li>[资源对象:缓冲和纹理] 讨论设备内存管理，包括表现GPU内存分配的缓冲和纹理对象。</li><li>[函数和库] 描述Metal着色语言代码如何被呈现在一个Metal应用中，Metal着色语言代码在GPU上如何被加载和执行的。</li><li>[图像渲染:渲染命令编码器] 描述如何渲染3D图像，包括如何穿过多个线程来分配图形操作。</li><li>[数据并行计算处理:计算命令编码器] 阐述如何执行数据并行处理。</li><li>[缓冲和纹理操作:位命令编码器] 描述如何在纹理和缓冲之间拷贝数据。</li></ul><a id="more"></a><h2 id="Metal基本概念"><a href="#Metal基本概念" class="headerlink" title="Metal基本概念"></a>Metal基本概念</h2><p>Metal对于图像和数据并行计算工作量提供了一个单一的，统一的编程接口和语言。Metal使得你能够整合图像和计算任务更高效而不需要使用分离的API和着色语言。</p><blockquote><p>Metal框架提供了如下特性:</p></blockquote><ul><li><p><strong>低功耗接口。</strong>Metal被设计消除潜在的性能瓶颈，例如显式的状态校验。你可以控制GPU的异步行为，对于用来并行创建和提交命令缓冲有效的多线程。</p><p>关于Metal命令提交的细节，参见[命令组成和执行模型] 。</p></li><li><p><strong>内存和资源管理。</strong>Metal框架描述了表示GPU内存分配的缓冲和纹理对象。纹理对象有指定的纹理格式，可能用于纹理图像或附件。</p><p>关于Metal内存对象的细节，参见[资源对象:缓冲和纹理] 。</p></li><li><p><strong>对于图像和计算操作完整的支持。</strong>Metal对于图像和计算操作使用相同的数据结构和资源(例如缓冲，纹理，和命令队列)。另外，Metal着色语言支持图像和计算方法。Metal框架使得资源可以在运行时接口，图像着色器和计算方法中被共享。</p><p>关于使用Metal对于图形渲染或数据并行计算操作的细节，参见[图像渲染:渲染命令编码器]和[数据并行计算处理:计算命令编码器]。</p></li><li><p><strong>预编译着色器。</strong>Metal着色器可以和你应用的代码一起在构建时被编译，然后在运行时加载。这个工作流提供了更好的代码生成和着色器的代码更容易调试。(Metal也支持着色器运行时编译。)</p><p>关于来自Metal框架代码和Metal着色器一起工作的细节，参见[函数和库]。关于Metal着色语言本身的细节，参见Metal渲染语言指南。</p></li></ul><p>一个Metal应用不能在后台执行Metal命令，Metal应用会尝试终止这种行为。</p><h2 id="命令组成和执行模型"><a href="#命令组成和执行模型" class="headerlink" title="命令组成和执行模型"></a>命令组成和执行模型</h2><p>在Metal架构中，<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>协议定义了表示单GPU的接口。<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>协议提供了询问设备属性方法，创建其他设备指定对象，例如缓冲和纹理，编码和排队渲染以及被提交给GPU执行的计算命令。</p><p>命令队列由一个命令缓冲区队列组成，命令队列组织那些命令缓冲区的执行顺序。一个命令缓冲区包括打算在一个特定设备上执行的已编码的命令。命令编码器追加渲染、计算和位块传送命令到一个命令缓冲区，那些命令缓冲区最终被提交到设备上执行。</p><p><a href="https://developer.apple.com/documentation/metal/mtlcommandqueue" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandQueue</font></a>协议定义了一个命令队列的接口，创建命令缓冲对象的主要支持方法。<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>协议定义了一个命令缓冲区的接口并提供创建命令编码器，入队执行的命令缓冲区，检查状态以及其他操作的方法。<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>协议支持下列命令编码器类型，它们是编码不同种类GPU工作量进入一个命令缓冲区的接口。</p><ul><li><a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>协议编码单一渲染过程的图像(3D)渲染命令。</li><li><a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>协议编码数据并行计算工作量。</li><li><a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>协议编码在缓冲和纹理之间的简单拷贝操作，和类似mipmap产生的工具操作一样。</li></ul><p>在任何时候，只有一个命令编码器可以是活跃的，追加命令到一个命令缓冲区。每个命令编码器在创建用于使用相同命令缓冲区的另一个命令编码器之前必须结束。一个例外“每个命令缓冲区的一个活跃的命令编码器”的规则是<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>协议，在使用<a href="">使用多线程编码单一渲染通道</a>中讨论。</p><p>一旦所有的编码结束，提交<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象本身，它标记那个命令缓冲区准备由GPU执行。<a href="https://developer.apple.com/documentation/metal/mtlcommandqueue" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandQueue</font></a>协议控制提交到<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象的命令何时被执行，相对于其他<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象已经在命令队列。</p><p>图表2-1展示了命令队列，命令缓冲，命令编码器对象是如何紧密联系的。表格顶部的每列组件(缓冲，纹理，采样器，深度以及模板状态，管线状态)表示资源和状态，这些状态一个特殊命令编码器的特性。</p><p>图表 2-1 Metal对象关系</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/Cmd-Model-1_2x.png" alt="img-w600"></p><h3 id="设备对象表示一个GPU"><a href="#设备对象表示一个GPU" class="headerlink" title="设备对象表示一个GPU"></a>设备对象表示一个GPU</h3><p><a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象表示一个可以执行命令GPU。<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>协议有方法去创建一个新的命令队列，从内存分配缓冲区，创建纹理，以及设备兼容性查询。调用<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/1433401-mtlcreatesystemdefaultdevice" target="_blank" rel="noopener">MTLCreateSystemDefaultDevice</a></font>函数获取系统上首选的系统设备。</p><h3 id="Metal中的瞬态与非瞬态对象"><a href="#Metal中的瞬态与非瞬态对象" class="headerlink" title="Metal中的瞬态与非瞬态对象"></a>Metal中的瞬态与非瞬态对象</h3><p>Metal中的一些对象被设计成瞬态和极其轻量级的，而另一些可能对应用程序的生命周期则更昂贵并会持续很长时间。</p><p>命令缓冲区和命令编码器对象是瞬态的并用途单一。他们是非常便宜的分配和销毁，所以他们的创建方法返回自动释放对象。</p><p>下列对象不是瞬态的。重用这些对象在性能敏感的代码，避免重复创建它们。</p><ul><li>命令队列</li><li>数据缓冲区</li><li>纹理</li><li>采样器状态</li><li>库</li><li>计算状态</li><li>渲染管线状态</li><li>深度/模板状态</li></ul><h3 id="命令队列"><a href="#命令队列" class="headerlink" title="命令队列"></a>命令队列</h3><p>命令队列接受一个GPU将要执行的命令缓冲区的有序列表。所有命令缓冲区发送到一个队列，这保证了入队的命令缓冲区有序执行。通常，命令队列是线程安全的并且允许多个活跃的命令缓冲区被同时编码。</p><p>创建命令队列，调用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtldevice/1433388-newcommandqueue" target="_blank" rel="noopener">newCommandQueue</a></font>方法或<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtldevice/1433433-makecommandqueue" target="_blank" rel="noopener">newCommandQueueWithMaxCommandBufferCount:</a></font>方法。通常，命令队列希望长时间存活，所以他们不应当被反复创建和销毁。</p><h3 id="命令缓冲区"><a href="#命令缓冲区" class="headerlink" title="命令缓冲区"></a>命令缓冲区</h3><p>命令缓冲区存储被编码的命令直到缓冲区被提交到GPU执行。一个命令缓冲可以包含许多不同种类的被编码的命令，依赖于编码器的数量和类型，这些编码器被用来构建它。在一个典型的应用程序中，渲染的整个帧被编码进一个单独的命令缓冲区，即使渲染的帧包含多个帧渲染通道，计算处理功能，或者位块传送操作。</p><p>命令缓冲区是瞬态的一次性对象并且不支持重用。一旦一个命令缓冲区被提交执行，唯一有效的操作是去等待命令缓冲区被安排或者执行完成—-通过同步调用或者在<a href="">注册命令缓冲执行处理程序</a>中讨论的处理程序—-检查命令缓冲区执行状态。</p><p>命令缓冲区也表示了唯一独立地可跟踪的工作单元，并且他们定义了由Metal内存模型确定的一致性界限，详情见<a href="">资源对象:缓冲和纹理</a>。</p><h4 id="创建命令缓冲区"><a href="#创建命令缓冲区" class="headerlink" title="创建命令缓冲区"></a>创建命令缓冲区</h4><p>创建<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象，调用<a href="https://developer.apple.com/documentation/metal/mtlcommandqueue" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandQueue</font></a>的<font color="DeepSkyBlue">commandBuffer</font>方法。<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象只能被提交到创建的<a href="https://developer.apple.com/documentation/metal/mtlcommandqueue" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandQueue</font></a>对象中。</p><p>由<font color="DeepSkyBlue">commandBuffer</font>方法创建的命令缓冲区持有需要执行的数据。对于特定场景，在<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象执行期间在别处持有保留这些对象，你可以通过调用<a href="https://developer.apple.com/documentation/metal/mtlcommandqueue" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandQueue</font></a>的<font color="DeepSkyBlue">commandBufferWithUnretainedReferences</font>方法创建一个命令缓冲区。使用<font color="DeepSkyBlue">commandBufferWithUnretainedReferences</font>方法仅仅为了性能极其关键的应用程序，这可以确保关键对象在应用的别处有引用直到命令缓冲执行完成。否则，不再有其他引用的一个对象可能过早地被施放，命令缓冲执行结果是不明确的。</p><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>协议使用下列方法去确定命令缓冲在命令队列中的执行顺序。命令缓冲并未开始执行直到它被提交。一旦提交，命令缓冲会按照它们入队的顺序去执行。</p><ul><li><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443019-enqueue" target="_blank" rel="noopener">enqueue</a></font>方法在命令队列缓冲区上保留命令缓冲的一个地方,但不提交到命令缓冲区去执行。当这个命令缓冲区最后被提交，它将在任何以前入队相关队列的命令缓冲区后被执行。</li><li><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443003-commit" target="_blank" rel="noopener">commit</a></font>方法引起了命令缓冲区被尽快执行，但是在任何以前入队相同命令队列的命令缓冲区被提交之后。如果命令缓冲没有以前入队的，<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443003-commit" target="_blank" rel="noopener">commit</a></font>做一个隐含的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443019-enqueue" target="_blank" rel="noopener">enqueue</a></font>调用。</li></ul><p>多线程使用<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443019-enqueue" target="_blank" rel="noopener">enqueue</a></font>的例子，参见<a href="">多线程，命令缓冲区和命令编码器</a>。</p><h4 id="注册命令缓冲区执行的处理程序"><a href="#注册命令缓冲区执行的处理程序" class="headerlink" title="注册命令缓冲区执行的处理程序"></a>注册命令缓冲区执行的处理程序</h4><p>下面列出的<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>方法监控命令执行。计划和完成处理程序在一个不明确的线程上按执行顺序被调用。执行这些处理程序代码应很快完成；如果昂贵的或阻塞的工作需要被完成,推迟那个工作到另一个线程。</p><ul><li><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442991-addscheduledhandler" target="_blank" rel="noopener">addScheduledHandler:</a></font>方法注册一个当命令缓冲调度时被调用的代码块。在由其他的<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象递交的工作或者系统其他API的任何依赖被满足时命令缓冲被考虑调度。你可以为一个命令缓冲注册多个调度处理程序。</li><li><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443036-waituntilscheduled" target="_blank" rel="noopener">waitUntilScheduled</a></font>方法同步等待并且在命令缓冲被调度后返回，所有由<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442991-addscheduledhandler" target="_blank" rel="noopener">addScheduledHandler:</a></font>方法注册的调度程序被完成。</li><li><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442997-addcompletedhandler" target="_blank" rel="noopener">addCompletedHandler:</a></font>方法注册一个在设备完成命令缓冲执行后立刻被调用的代码块。你可以为一个命令缓冲注册多个完成处理代码块。</li><li><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443039-waituntilcompleted" target="_blank" rel="noopener">waitUntilCompleted</a></font>方法同步等待，在设备已经完成命令缓冲执行后返回，所有通过<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442997-addcompletedhandler" target="_blank" rel="noopener">addCompletedHandler:</a></font>方法注册的处理程序返回。</li></ul><font color="DeepSkyBlue">[presentDrawable:](https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443029-presentdrawable)</font>方法是一个完成处理程序的特例。这个方便的方法当命令缓冲被调度时显示一个可显示资源(一个<font color="Fuchsia">[CAMetalDrawable](https://developer.apple.com/documentation/quartzcore/cametaldrawable)</font>对象)的内容。关于<font color="DeepSkyBlue">[presentDrawable:](https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443029-presentdrawable)</font>方法的详情，参见[集成核心动画:CAMetalLayer]()。#### 监控命令缓冲区执行状态只读<font color="DarkGray">[status](https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443048-status)</font>属性包含一个列举在<font color="Fuchsia">[Command Buffer Status Codes](https://developer.apple.com/documentation/metal/mtlcommandbufferstatus)</font>中的<font color="Fuchsia">[MTLCommandBufferStatus](https://developer.apple.com/documentation/metal/mtlcommandbufferstatus)</font>的枚举值，这些反应了在这个命令缓冲声明周期中的当前调度阶段。如果执行成功完成，只读<font color="DarkGray">[error](https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443040-error)</font>属性值是nil。如果执行失败，那么status被设置为<font color="DarkGray">MTLCommandBufferStatusError</font>，<font color="DarkGray">error</font>属性可能包含一个被列举在<font color="Fuchsia">[Command Buffer Error Codes](https://developer.apple.com/documentation/metal/mtlcommandbuffererror.code)</font>中的值，它表明了失败的原因。### 命令编码器命令编码器是一个瞬态对象，你用一次写命令和状态到一个以一种GPU可执行格式的命令缓冲区。许多命令编码器对象方法追加命令到命令缓冲区。当一个缓冲编码器是活跃的，它有在其命令缓冲区追加命令的专属权。一旦你完成了编码命令，调用<font color="DeepSkyBlue">[endEncoding](https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding)</font>方法。继续写命令，创建一个新的命令编码器。#### 创建一个命令编码器对象由于一个命令编码器追加命令到一个指定的命令缓冲区，通过从你想使用的[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)对象请求创建一个命令编码器。使用下面的[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)方法来创建各类型的命令编码器:* <font color="DeepSkyBlue">[renderCommandEncoderWithDescriptor:](https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442999-rendercommandencoderwithdescript)</font>方法创建一个<font color="Fuchsia">[MTLRenderCommandEncoder](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)</font>]对象图像渲染在<font color="Fuchsia">[MTLRenderPassDescriptor](https://developer.apple.com/documentation/metal/mtlrenderpassdescriptor)</font>中的一个附件。* computeCommandEncoder方法创建一个[<font color="Fuchsia">MTLComputeCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlcomputecommandencoder)对象对于数据并行计算。* blitCommandEncoder方法创建一个[<font color="Fuchsia">MTLBlitCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlblitcommandencoder)对象对于内存操作。* parallelRenderCommandEncoderWithDescriptor:方法创建一个[<font color="Fuchsia">MTLParallelRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder)对象，它使得一些[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)对象运行在不同的线程上，当静止渲染一个附件时，它被指定到一个共享的<font color="Fuchsia">MTLRenderPassDescriptor</font>中。#### 渲染命令编码器图像渲染可以被描述依据一个渲染管道。一个[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)对象表示渲染状态和关联单一渲染通道的绘制指令。[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)需要一个相关联的<font color="Fuchsia">[MTLRenderPassDescriptor](https://developer.apple.com/documentation/metal/mtlrenderpassdescriptor)</font>(描述在创建一个渲染管道描述符)，它包含颜色，深度和模板附件，它们作为渲染命令的终点。[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)有下列方法:* 指定图像资源，例如缓冲区和纹理对象，包含顶点，片元，或者纹理图像数据* 指定<font color="Fuchsia">[MTLRenderPipelineState](https://developer.apple.com/documentation/metal/mtlrenderpipelinestate)</font>对象，包含已编译渲染状态，包括顶点和片元着色器* 指定固定功能状态，包括视口，三角形填充模式，剪刀矩形，深度和模板测试以及其他值* 绘制3D基元关于[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)协议的详细信息，请看[图像渲染：渲染命令编码器]()。#### 计算命令编码器对于数据并行计算，[<font color="Fuchsia">MTLComputeCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlcomputecommandencoder)协议提供了在命令缓冲区编码命令的方法，可以指定计算功能和它的参数(例如，纹理，缓冲，和采样器状态)，调度执行计算功能。创建一个计算命令编码器对象，使用[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)的<font color="DeepSkyBlue">[computeCommandEncoder](https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443044-makecomputecommandencoder)</font>方法。关于[<font color="Fuchsia">MTLComputeCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlcomputecommandencoder)的方法和属性的详细信息，请看[数据并行计算处理:计算命令编码器]()。#### 位块传送命令编码器[<font color="Fuchsia">MTLBlitCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlblitcommandencoder)协议有方法在缓冲(<font color="Fuchsia">[MTLBuffer](https://developer.apple.com/documentation/metal/mtlbuffer)</font>)和纹理(<font color="Fuchsia">[MTLTexture](https://developer.apple.com/documentation/metal/mtltexture)</font>)之间为内存拷贝操作追加命令。<font color="Fuchsia">[MTLBlitCommandEncoder](https://developer.apple.com/documentation/metal/mtlblitcommandencoder)</font>协议也提供了方法用纯色去填充纹理和产生纹理映射。创建一个位块传送命令编码器对象，使用[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)的<font color="DeepSkyBlue">[blitCommandEncoder](https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443001-makeblitcommandencoder)</font>方法。关于[<font color="Fuchsia">MTLBlitCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlblitcommandencoder)方法和属性的详细信息，请看[缓冲区和纹理操作:位块传送命令编码器]()。#### 多线程，命令缓冲，和命令编码器大多数应用使用单线程来编码在单一指令缓冲区中一帧的渲染命令。在每帧的末尾，提交编码缓冲区，计划和开始命令执行。如果你想去并行编码命令缓冲区，那么你可以同时创建多个命令缓冲区，用一个分开的线程编码每一个。如果你知道提前以什么顺序应该执行一个命令缓冲区，那么[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)的<font color="DeepSkyBlue">[enqueue](https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443019-enqueue)</font>方法可以声明在命令队列中的执行顺序，不需要等待命令被编码和提交。否则，当一个命令缓冲区被提交，在任何以前入队的命令缓冲以后它会被分配到命令队列的一个地方。有时仅仅一个CPU线程可以访问一个命令缓冲。多线程应用每个命令缓冲可以使用一个线程来创建多个并行的命令缓冲。图表2-2显示了一个三线程的例子。每个线程有它自己的命令缓冲区。对于每个线程，一个命令编码器在一次访问它相关的命令缓冲。图表2-2也显示了每个指令缓冲接收来自不同命令编码器的命令。当你结束编码时，调用命令编码器的<font color="DeepSkyBlue">[endEncoding](https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding)</font>方法，一个新的命令编码器对象可以开始编码指令到命令缓冲区。图表2-2 多线程Metal命令缓冲区![img-w600](https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/Cmd-Model-threads_2x.png)[<font color="Fuchsia">MTLParallelRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder)对象允许将一个渲染通过拆分到多个命令编码器和分配到单独的线程。关于[<font color="Fuchsia">MTLParallelRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder)更多信息，请看使用[多线程编码单一渲染管道]()。## 资源对象:缓冲和纹理这章描述Metal资源对象(MTLResource)存储未格式化的内存和格式化的图像数据。MTLResource对象有两个类型:* MTLBuffer表示未格式化内存的分配，它可以包含任意类型数据。缓冲区通常被用在顶点，着色器，和计算状态数据。* MTLTexture表示指定纹理类型和像素格式的格式化图像数据的分配。纹理对象被用作顶点，片元的源纹理，或者计算方法，和存储图像渲染输出一样(换言之，作为一个附件)。MTLSamplerState对象也在这章中被讨论。尽管采样器不是资源本身，他们当执行用纹理对象检查计算时被使用。### 缓冲是无类型的内存分配MTLBuffer对象表示一个可以包含任意类型数据的内存分配。#### 创建一个缓冲对象[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)的下列方法创建和返回一个MTLBuffer对象:* newBufferWithLength:options:方法用一个新的存储分配创建MTLBuffer对象。* newBufferWithBytes:length:options:方法通过从已存在的存储(位于CPU地址指针)拷贝进入一个新的存储分配来创建一个MTLBuffer对象。* newBufferWithBytesNoCopy:length:options:deallocator:方法用一个已存在的存储分配来创建一个MTLBuffer对象，对于这个对象不能分配任何新的存储。所有缓冲创建方法有输入值length来标明存储分配的大小，以字节来表示。对于可以修改创建缓冲区行为的options，所有方法也接受一个MTLResourceOptions对象。如果options的值时0，默认值被用作资源选项。#### 缓冲方法MTLBuffer协议有下列方法:* contents方法返回缓冲区的存储分配的CPU地址。* newTextureWithDescriptor:offset:bytesPerRow:方法创建一种特殊的纹理对象，该纹理对象引用缓冲区的数据。这个方法被详细讲解在创建一个纹理对象章节中。### 纹理是格式化的图像数据一个MTLTexture对象代笔爱哦一个格式化图像数据的分配，它可以被用作一个顶点着色器的资源，片元着色器，或者计算方法，或者作为一个附件被用作一个渲染的终点。MTLTexture对象可以有下列结构中的一个:* 一个1D，2D，或者3D的图像* 一个1D或者2D图像的数组* 六个2D图像的立方体MTLPixelFormat指定在一个MTLTexture对象个体像素构成。像素格式被更进一步讨论在纹理像素格式。#### 创建一个纹理对象下列方法创建并返回一个MTLTexture对象:* [<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)的newTextureWithDescriptor:方法用一个纹理图像数据的新存储分配来创建一个MTLTexture对象，使用<font color="Fuchsia">MTLTextureDescriptor</font>对象来描述纹理的属性。* MTLTexture的newTextureViewWithPixelFormat:方法来创建一个MTLTexture对象，这个对象共享相同的存储分配来调用MTLTexture对象。因为他们共享相同的存储，新纹理对象的像素的任何改变被反映在调用纹理对象上，反之亦然。对于最新创建的纹理，newTextureViewWithPixelFormat:方法重新解释了已存在的调用MTLTexture对象的存储分配的纹理图像数据，好像数据被被存储到一个指定的像素格式。新纹理对象MTLPixelFormat必须和原始纹理对象``的MTLPixelFormat是兼容的。(请看像素格式关于普通的纹理细节,包装,和压缩像素格式。)* MTLBuffer的newTextureWithDescriptor:offset:bytesPerRow:方法创建一个MTLTexture对象，调用MTLBuffer对象作为它的纹理图像数据来共享存储分配。当它们共享相同的存储，新纹理对象像素的任何改变都会被反映在调用纹理对象上，反之亦然。在纹理和缓冲之间共享存储可以防止指定纹理优化的使用，例如像素混合或平铺。#### 使用纹理描述符创建一个纹理对象<font color="Fuchsia">MTLTextureDescriptor</font>定义属性，这些属性被用来创建一个MTLTexture对象，包括它图像大小(宽，高，和深)，像素格式，排列(数组或者立方体类型)和纹理映射数量。<font color="Fuchsia">MTLTextureDescriptor</font>属性仅仅被使用在<font color="Fuchsia">MTLTexture</font>对象创建期间。在创建MTLTexture对象后，属性改变在它的<font color="Fuchsia">MTLTextureDescriptor</font>对象中而纹理上不再有任何效果。从描述符创建一个或者多个纹理:1. 创建一个自定义<font color="Fuchsia">MTLTextureDescriptor</font>对象，它包含描述纹理数据的纹理属性:   * textureType属性指定纹理维度和排列(例如，数组或立方体)。   * width，height和depth属性指定基准面纹理映射每个尺寸的像素大小。   * pixelFormat属性指定一个像素如何在纹理中存储的。   * arrayLength属性指定MTLTextureType1DArray或MTLTextureType2DArray类型纹理对象的数组元素的个数。   * mipmapLevelCount属性指定了每个像素采样的个数。   * resourceOptions属性指定了它内存分配的行为。2. 从<font color="Fuchsia">MTLTextureDescriptor</font>对象通过调用一个[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)对象的newTextureWithDescriptor:方法来创建一个纹理。纹理创建后，调用replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:方法加载纹理图像数据，详情见复制图像数据和纹理。3. 创建更多MTLTexture对象，你可以重用相同的<font color="Fuchsia">MTLTextureDescriptor</font>对象，修改需要的描述符的属性值。清单3-1 显示了创建一个纹理描述符txDesc和设置它对于一个3D，64×64×64的纹理属性的代码清单3-1 用一个自定义的纹理描述符创建一个纹理对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MTLTextureDescriptor* txDesc = [[MTLTextureDescriptor alloc] init];</span><br><span class="line">txDesc.textureType = MTLTextureType3D;</span><br><span class="line">txDesc.height = 64;</span><br><span class="line">txDesc.width = 64;</span><br><span class="line">txDesc.depth = 64;</span><br><span class="line">txDesc.pixelFormat = MTLPixelFormatBGRA8Unorm;</span><br><span class="line">txDesc.arrayLength = 1;</span><br><span class="line">txDesc.mipmapLevelCount = 1;</span><br><span class="line">id &lt;MTLTexture&gt; aTexture = [device newTextureWithDescriptor:txDesc];</span><br></pre></td></tr></table></figure>#### 使用纹理切片一个切片是一个单一的1D，2D，或3D纹理图像和所有关联的纹理映射。对于每个切片:* 基准面纹理映射大小被指定<font color="Fuchsia">MTLTextureDescriptor</font>对象的width,height,和depth属性。* 纹理映射级别缩放大小 *i* 被指定，max(1, floor(width/2<sup>i</sup>))×max(1,floor(height/2<sup>i</sup>))×max(1,floor(depth/2<sup>i</sup>))。最大纹理映射级别是第一个纹理映射获得的级别大小为1×1×1。* 纹理映射级别数量在一个切片中可以被决定floor(log<sub>2</sub>(max(width, height, depth)))+1。所有纹理对象有至少一个切片；立方体和数组纹理类型可能有数个切片。在复制图像数据和纹理章节中讨论读写纹理图像数据的规范方法，切片是一个零点输入值。对于一个1D，2D，或3D纹理，只有一个切片，所以切片的值必须是0.一个立方体纹理有6个完全的2D切片，地址从0到5.对于1DArray和2DArray纹理类型，每个数组元素表示一个切片。例如，对于一个2DArray纹理类型有arrayLength = 10，有10个完整的切片，地址从0到9.选择一个单一的1D，2D，或3D图像整体的纹理结构，首选选择一个切片，然后选择一个切片内的纹理映射级别。#### 用便利的方法创建一个纹理描述符对于普通2D和立方体纹理，使用下列便利的方法来创建一个<font color="Fuchsia">MTLTextureDescriptor</font>对象，几个属性值自动设置:* texture2DDescriptorWithPixelFormat:width:height:mipmapped:方法创建一个<font color="Fuchsia">MTLTextureDescriptor</font>对象对于2D纹理。width和height值定义了2D纹理的尺寸。type属性被自动设置为MTLTextureType2D， depth和arrayLength被设置成1.* textureCubeDescriptorWithPixelFormat:size:mipmapped: 方法创建一个立方体纹理的<font color="Fuchsia">MTLTextureDescriptor</font>对象，type属性被设置为MTLTextureTypeCube，width和height被设置为size，depth和arrayLength被设置为1.两个<font color="Fuchsia">MTLTextureDescriptor</font>便利方法接收一个输入值，pixelFormat，它定义了纹理的像素格式。这两种方法也接受输入值产生，这决定了是否产生纹理图像。(如果mipmapped是YES，纹理被贴图细化。)清单3-2 使用texture2DDescriptorWithPixelFormat:width:height:mipmapped:方法来创建一个64×64的2D纹理描述符对象，它不是纹理细化的。清单3-2 用便利的纹理描述符创建一个纹理对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MTLTextureDescriptor *texDesc = [MTLTextureDescriptor </span><br><span class="line">         texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm </span><br><span class="line">         width:64 height:64 mipmapped:NO];</span><br><span class="line">id &lt;MTLTexture&gt; myTexture = [device newTextureWithDescriptor:texDesc];</span><br></pre></td></tr></table></figure>#### 复制图像数据和纹理同步拷贝图像数据进入或从MTLTexture对象分配存储拷贝数据，使用下列方法:* replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:从调用者的指针拷贝一个区域的像素数据到一部分指定纹理切片的存储分配。replaceRegion:mipmapLevel:withBytes:bytesPerRow:是一个类似的便利方法拷贝一个区域的像素数据到默认切片，假设切片相关参数的默认值(例如，slice = 0 并且 bytesPerImage = 0)。* getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:从一个指定纹理切片获取一个区域的像素数据。getBytes:bytesPerRow:fromRegion:mipmapLevel:是一个类似的便利方法，从默认的切片获取一个区域的像素数据，假设切片相关的参数默认值(slice = 0和bytesPerImage = 0)。清单3-3 显示了如何调用replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:来指定从系统内存中的源数据的一个纹理图像，textureData，在切片0和纹理映射级别0。清单3-3 复制图像数据和纹理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//  pixelSize is the size of one pixel, in bytes</span><br><span class="line">//  width, height - number of pixels in each dimension</span><br><span class="line">NSUInteger myRowBytes = width * pixelSize;</span><br><span class="line">NSUInteger myImageBytes = rowBytes * height;</span><br><span class="line">[tex replaceRegion:MTLRegionMake2D(0,0,width,height)</span><br><span class="line">    mipmapLevel:0 slice:0 withBytes:textureData</span><br><span class="line">    bytesPerRow:myRowBytes bytesPerImage:myImageBytes];</span><br></pre></td></tr></table></figure>#### 纹理像素格式MTLPixelFormat指定存储在单个像素的MTLTexture对象的颜色，深度，和模板数据存储的组成。有三种像素格式:ordinary，packed和compressed。* Ordinary格式只有常规8，16或32位颜色组件。每个组件都是安排在增加内存地址，第一列组件在最低的地址。例如，MTLPixelFormatRGBA8Unorm是一个每个颜色组件8位的32位的格式；最低位地址包含红色，下一个地址包含绿色，等等。与此相反，MTLPixelFormatBGRA8Unorm，最低位地址包含蓝色，下一个地址包含绿色，等等。* Packed格式结合多个组件组合为一个16位或32位值，组件存储从最小最有效位(LSB MSB)。例如，MTLPixelFormatRGB0A2Unit是一个32位packed格式，它由3个10位通道和两位Alpha组成。* Compressed格式排列的像素块,每一块的布局是特定于该像素格式。压缩像素格式仅仅可以被用于2D，2D数组，或者立方体纹理类型。压缩格式不能被用于创建1D，2D多采样或3D纹理。MTLPixelFormatGBGR422和MTLPixelFormatBGRG422是特殊像素格式，这个格式是用来存储YUV色彩空间的像素。这些格式只支持2D纹理(但是既不是2D数组，也不是立方体类型)，没有纹理映射，偶数宽度。一些像素格式存储sRGB色彩空间的颜色组件(例如，MTLPixelFormatRGBA8Unorm_sRGB或MTLPixelFormatETC2_RGB8_sRGB)。当一个采样操作引用拥有sRGB像素格式的纹理，在采样操作发生之前，Metal实现转换sRGB色彩空间组件到一个线性颜色空间。sRGB转换，S，一个线性组件，L，如下:* If S <= 0.04045,="" l="S/12.92" *="" if="" s=""> 0.04045, L = ((S+0.055)/1.055)<sup>2.4</sup>相反地，当渲染一个色彩渲染附件，它使用sRGB像素格式的纹理，实现转换成想线性颜色值到sRGB，如下:* If L <= 0.0031308,="" s="L" *="" 12.92="" if="" l=""> 0.0031308, S = (1.055 * L<sup>0.41667</sup>) - 0.055关于渲染像素格式的更多信息，请看创建一个渲染通道描述符。#### 创建一个纹理查询的采样器状态对象MTLSamplerState对象定义了寻址，过滤和其他属性，当一个图像或者计算函数对MTLTexture对象执行纹理采样操作时这些属性被使用。采样器描述符定义了采样器状态对象的属性。创建一个采样器对象:1. 调用[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)的<font color="DeepSkyBlue">newSamplerStateWithDescriptor:</font>方法来创建一个MTLSamplerDescriptor对象。2. 在MTLSamplerDescriptor对象中设置期望的值，包括过滤选项，寻址方式，最大各向异性，和细节层次参数。3. 通过调用[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)对象的<font color="DeepSkyBlue">newSamplerStateWithDescriptor:</font>方法创建描述符，从采样器描述符创建MTLSamplerState对象。你可以重用采样器描述符对象来创建更多MTLSamplerState对象，修改所需的描述符的属性值。描述符属性仅在对象创建期间被使用。采样器状态已经被创建后，在采样器状态上改变其描述符的属性不再有效果。清单3-4 是一个代码例子创建一个MTLSamplerDescriptor和配置它为了创建一个MTLSamplerState。对于描述符对象的过滤和寻址方式属性设置为非默认值。然后<font color="DeepSkyBlue">newSamplerStateWithDescriptor:</font>方法。清单3-4 创建一个采样器状态对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// create MTLSamplerDescriptor</span><br><span class="line">MTLSamplerDescriptor *desc = [[MTLSamplerDescriptor alloc] init];</span><br><span class="line">desc.minFilter = MTLSamplerMinMagFilterLinear;</span><br><span class="line">desc.magFilter = MTLSamplerMinMagFilterLinear;</span><br><span class="line">desc.sAddressMode = MTLSamplerAddressModeRepeat;</span><br><span class="line">desc.tAddressMode = MTLSamplerAddressModeRepeat;</span><br><span class="line">//  all properties below have default values</span><br><span class="line">desc.mipFilter        = MTLSamplerMipFilterNotMipmapped;</span><br><span class="line">desc.maxAnisotropy    = 1U;</span><br><span class="line">desc.normalizedCoords = YES;</span><br><span class="line">desc.lodMinClamp      = 0.0f;</span><br><span class="line">desc.lodMaxClamp      = FLT_MAX;</span><br><span class="line">// create MTLSamplerState</span><br><span class="line">id &lt;MTLSamplerState&gt; sampler = [device newSamplerStateWithDescriptor:desc];</span><br></pre></td></tr></table></figure>#### 保持CPU和GPU内存之间的一致性MTLResource对象可以访问在CPU和GPU两者之间的底层存储。然而，GPU从主机CPU异步操作，所以记住以下当使用主机CPU访问这些资源的存储。当执行一个[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)对象,[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)对象只保证观察任何更改由[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)对象引用的任何MTLResource对象分配到主机CPU的存储，如果(且仅当)这些变化是由主机CPU在[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)对象被提交之前产生。就是说，[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)对象可能不观察在相应的[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)对象被提交后主机CPU资源产生的改变(例如，[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)对象的status属性是MTLCommandBufferStatusCommitted)。相似地，在[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)对象执行一个[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)对象之后，如果命令缓冲已经被执行完成，那么主机CPU只保证观察[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)对象产生的命令缓冲引用的任何资源存储分配的任何改变(也就是说，[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)对象的status属性是[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)StatusCompleted)。## 函数和库这章描述如何创建一个<font color="Fuchsia">MTLFunction</font>对象作为一个Metal着色器的参考或计算函数，如何组织和访问<font color="Fuchsia">MTLLibrary</font>对象的方法。### <font color="Fuchsia">MTLFunction</font>表示着色器或计算函数<font color="Fuchsia">MTLFunction</font>对象表示单一的函数，这个函数用Metal着色语言编写，作为图形或者计算管线的一部分在GPU上执行。Metal着色语言详情，参见Metal着色语言指导。在Metal运行时和图像或者用Metal着色语言编写的计算函数之间传递数据或状态，分配纹理，缓冲和采样器的索引参数。参数索引确定哪个纹理，缓冲或采样器正在被引用，通过Metal运行时和Metal着色代码。渲染通道，指定一个<font color="Fuchsia">MTLFunction</font>对象作为一个<font color="Fuchsia">MTLRenderPipelineDescriptor</font>对象的顶点或者片元着色器，详见创建一个渲染管线状态。计算管道，当在目标设备上创建一个MTLComputePipelineState对象时指定一个<font color="Fuchsia">MTLFunction</font>对象，详见指定命令编码器的计算状态和资源。### 库是函数的一个仓库<font color="Fuchsia">MTLLibrary</font>对象表示了一个或更多<font color="Fuchsia">MTLFunction</font>对象的一个仓库。一个<font color="Fuchsia">MTLFunction</font>对象表示了一个Metal函数，这个函数用着色语言编写。在Metal着色语言中源码中，任何函数使用Metal标识符(vertex，fragment或kernel)可以通过在库中的一个<font color="Fuchsia">MTLFunction</font>对象来显示。Metal函数没有这些函数标识符中的一个不能直接用一个<font color="Fuchsia">MTLFunction</font>对象来显示。库中的<font color="Fuchsia">MTLFunction</font>对象可以从这些资源中创建:* Metal着色语言代码在app编译过程中被编译成一个二进库格式。* 包含在Metal着色语言源码中的一个文本字符串在app运行时被编译。#### 从编译的代码创建一个库为了最佳性能，在你的应用程序在Xcode编译过程中Metal着色语言源码将被编译成为一个库文件，这避免了在应用程序运行时编译函数源码的消耗。创建一个<font color="Fuchsia">MTLLibrary</font>对象从一个二进制库，调用[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)的下列方法之一:* <font color="DeepSkyBlue">newDefaultLibrary</font>获取为main bundle构建的一个库，它包含所有共享和计算函数在应用程序的xCode项目中。* <font color="DeepSkyBlue">newLibraryWithFile:error:</font>获取库文件的路径并返回一个<font color="Fuchsia">MTLLibrary</font>对象，这个对象包含了所有存储在库文件中的所有函数。* <font color="DeepSkyBlue">newLIbraryWithData:error:</font>获取二进制大对象包含在库中的函数源码并返回一个<font color="Fuchsia">MTLLibrary</font>对象。更多关于在构建过程中编译Metal着色语言源码的信息，参见创建应用程序过程中创建库。#### 从源码创建一个库调用下列[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)方法中的一个，从一个包含数个函数的Metal着色语言源码的字符串来创建一个<font color="Fuchsia">MTLLibrary</font>。当库被创建时这些函数编译源码。指定使用的编译器选项，设置MTLCompileOptions对象的属性。* newLibraryWithSource:options:error:从输入字符串同步编译源码创建<font color="Fuchsia">MTLFunction</font>对象，返回包含他们的一个<font color="Fuchsia">MTLLibrary</font>对象。* newLibraryWithSource:options:completionHandler:从输入字符串异步编译源码创建<font color="Fuchsia">MTLFunction</font>对象，随后返回包含他们的一个<font color="Fuchsia">MTLLibrary</font>对象。completionHandler是一个当对象创建完成时被调用的代码块。#### 从库中获取函数<font color="Fuchsia">MTLLibrary</font>的newFunctionWithName:方法返回一个带有请求名字的<font color="Fuchsia">MTLFunction</font>对象。如果函数名在库中没有发现使用Metal着色语言函数标识符，那么newFunctionWithName:返回nil。清单4-1 使用[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)的<font color="DeepSkyBlue">newLibraryWithFile:error:</font>方法通过它的全名来查找一个库文件，使用它的内容来创建一个带有一个或者多个<font color="Fuchsia">MTLFunction</font>对象的<font color="Fuchsia">MTLLibrary</font>对象。加载文件中的任何错误都被返回在error中。接下来<font color="Fuchsia">MTLLibrary</font>的newFunctionWithName:方法创建一个<font color="Fuchsia">MTLFunction</font>对象，这个对象表示了在源码中名叫my_func的函数。返回的函数对象myFunc可以在应用中被使用。清单4-1 从库中获取函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSError *errors;</span><br><span class="line">id &lt;MTLLibrary&gt; library = [device newLibraryWithFile:@&quot;myarchive.metallib&quot;</span><br><span class="line">                          error:&amp;errors];</span><br><span class="line">id &lt;MTLFunction&gt; myFunc = [library newFunctionWithName:@&quot;my_func&quot;];</span><br></pre></td></tr></table></figure>### 在运行时决定函数细节由于<font color="Fuchsia">MTLFunction</font>对象的实际内容通过一个图像着色器或者计算函数定义，这些可能在<font color="Fuchsia">MTLFunction</font>对象创建前被编译，对于应用其源码可能不是直接可用的。在运行时可以查询下列<font color="Fuchsia">MTLFunction</font>属性:* name，函数名称字符串* functionType，表明函数是被声明为顶点，片源还是计算方法。* vertexAttributes，MTLVertexAttribute对象的一个数组，其描述顶点属性数据在内存中是如何被组织的，它是如何被映射到顶点函数参数的。对于更多细节，参见数据组织顶点描述符。<font color="Fuchsia">MTLFunction</font>不提供函数参数的访问。一个映射对象(或者MTLRenderPipelineReflection或者MTLComputePipelineReflection，依赖于命令编码器的类型)揭示了在管线状态创建时的着色器细节或计算方法参数获取。创建管线状态和映射对象的细节，参见创建一个渲染管线状态或创建一个计算管线状态。避免获取映射数据如果它没有被使用。映射对象包含一组命令编码器支持的各种类型函数的MTLArgument对象。对于[<font color="Fuchsia">MTLComputeCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlcomputecommandencoder)，在MTLComputePipelineReflection的arguments属性为一组MTLArgument对象，对应其计算函数的参数。对于[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)，MTLRenderPipelineReflection有两个属性，vertexArguments和fragmentArguments，它们各自对应顶点函数参数和片元函数参数的数组。并不是函数的所有参数都表示一个映射对象。映射对象只包含有一个关联资源的参数，但不是用[[ stage_in ]]标识符或者内建的[[ vertex_id ]]或[[ attribute_id ]]标识符声明的参数。清单4-2 展示了如何获取一个映射对象(在这个例子中，MTLComputePipelineReflection)和接下来通过MTLArgument在其arguments属性进行迭代。清单4-2 通过函数参数迭代<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MTLComputePipelineReflection* reflection;</span><br><span class="line">id &lt;MTLComputePipelineState&gt; computePS = [device</span><br><span class="line">              newComputePipelineStateWithFunction:func</span><br><span class="line">              options:MTLPipelineOptionArgumentInfo</span><br><span class="line">              reflection:&amp;reflection error:&amp;error];</span><br><span class="line">for (MTLArgument *arg in reflection.arguments) &#123;</span><br><span class="line">    //  处理每一个MTLArgument</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>MTLArgument属性揭示了着色语言函数参数的细节。* name属性是简单的参数名。* active是一个布尔值表明参数是否可以被忽略。* index在其对应的参数表中是零基准位置。例如，对于[[ buffer(2) ]], index是2.* access描述任何访问限制，例如，读或写访问标识符。* type是通过着色语言标识符来表明的，例如，[[ buffer(n) ]], [[ texture(n) ]], [[ sampler(n) ]]或[[ threadgroup(n) ]]。type决定其他MTLArgument属性哪些是相关联的。* 如果type是MTLArgumentTypeTexture，那么textureType属性表明整个纹理类型(例如在着色语言中的texture1d_array, texture2d_msh以及texturecube类型)和textureDataType属性表明组件数据类型(例如half，float，int或uint)。* 如果type是MTLArgumentTypeThreadGroupMemory，threadgrouopMemoryAlignment和threadgroupMemoryDataSize属性是相关的。* 如果type是MTLArgumentTypeBuffer，<font color="DarkGray">bufferAlignment</font>，<font color="DarkGray">bufferDataSize</font>，<font color="DarkGray">bufferDataType</font>以及<font color="DarkGray">bufferStructType</font>属性是相关联的。如果缓冲参数是一个结构体(也就是说，bufferDataType是MTLDataTypeStruct)，bufferStructType属性包含MTLStructType，其表示结构体，bufferDataSize包含结构体的大小，以字节计算。如果缓冲参数是一个数组(或指向数组的指针)，那么bufferDataType表明元素的数据类型，bufferDataSize包含一个数组元素的大小，以字节计算。清单4-3 深度探讨MTLStructType对象检查结构体成员的细节，每一个成员由一个MTLStructMember对象表示。结构体成员可能是一个简单类型，一个数组，或者一个嵌套结构体。如果成员是一个嵌套结构体，那么调用MTLStructMember的structType方法来获取一个MTLStructType对象，这个对象表示结构体，接下来递归深度探讨来分析它。如果成员是一个数组，使用MTLStructMember的arrayType方法来获取一个MTLArrayType对象来表示它。然后检查MTLArrayType的elementType属性。如果elementType是MTLDataTypeStruct，调用elementStructType方法来获取结构体，继续深入探讨进它的成员。如果elementType是MTLDataTypeArray，调用elementArrayType方法来获取字数组并进一步分析它。清单4-3 处理结构体参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MTLStructType *structObj = [arg.bufferStructType];</span><br><span class="line">for (MTLStructMember *member in structObj.members) &#123;</span><br><span class="line">    //  process each MTLStructMember</span><br><span class="line">    if (member.dataType == MTLDataTypeStruct) &#123;</span><br><span class="line">       MTLStructType *nestedStruct = member.structType;</span><br><span class="line">       // recursively drill down into the nested struct</span><br><span class="line">    &#125;</span><br><span class="line">    else if (member.dataType == MTLDataTypeArray) &#123;</span><br><span class="line">       MTLStructType *memberArray = member.arrayType;</span><br><span class="line">       // examine the elementType and drill down, if necessary</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">       // member is neither struct nor array</span><br><span class="line">       // analyze it; no need to drill down further</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>## 图形渲染:渲染命令编码器这章描述如何创建使用[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)和MTLParalledlRenderCommandEncoder对象，他们被用来编码图像渲染指令到命令缓冲。[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)命令描述图像渲染管线，像图表5-1看的。图表 5-1 Metal图像渲染管线![img-w600](https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/gfx-pipeline_2x.png)[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)表示了一个单独的渲染命令编码器。[<font color="Fuchsia">MTLParallelRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder)对象使单一渲染通道能够分解成大量离散的[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)对象，它们每个可能分配在不同的线程上。来自不同渲染命令编码器的命令链接在一起并一起一致的执行，可预见的顺序，正如在多线程渲染通道章节中描述的。### 创建并使用渲染命令编码器创建，初始化和使用一个渲染命令编码器:1. 创建一个<font color="Fuchsia">MTLRenderPassDescriptor</font>对象来定义附件集合，对于渲染通道这些附件担任命令缓冲区中图形命令渲染终点的角色。表示性地，一旦你创建一个<font color="Fuchsia">MTLRenderPassDescriptor</font>对象并你的应用每次重用它渲染帧。2. 使用指定渲染管线通过调用[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)的renderCommandEncoderWithDescriptor方法来创建一个[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)对象。参见使用渲染管道描述符来创建一个渲染命令编码器。3. 创建一个[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)对象来定义对于一次或多次绘制调用图像渲染管线的状态(包括着色器，混合，多采样和可视化测试)。为了使用这个绘制基元渲染管线状态，调用[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)的setRenderPipelineState:方法。相关详细信息，参见创建渲染管线状态。4. 通过渲染命令编码器设置纹理，缓冲和被使用的采样器，如指定渲染着色器资源中描述的。5. 调用[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)方法来指定额外的固定功能状态，包括深度和模板状态，在固定功能状态操作中解释。6. 最终，调用[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)方法来绘制图像基元，如绘制几何基元中描述的。#### 创建渲染管道描述符MTLResourcePassDescriptor对象表示编码的渲染命令终点，它是一个附件的集合。渲染描述符的属性可能包含色彩像素数据四个附件的一个数组，深度像素数据的一个附件，模板像素数据的一个附件。renderPassDescriptor便利的方法用默认附件状态的颜色，深度和模板附件创建一个<font color="Fuchsia">MTLRenderPassDescriptor</font>对象。visibilityResultBuffer属性指定了一个缓冲，这个缓冲指定一个缓冲区，设备可以更新指示是否任何采样通过了深度和模板测试---相关详细信息，参见固定功能状态操作。每个独立的附件，包含纹理，这个纹理将通过一个附件描述符被编写和表现。对于一个附件描述符，必须选择合适关联的纹理像素格式来存储颜色，深度或者模板数据。对于颜色附件描述符，MTLRenderPassColorAttachmentDescriptor，使用一个颜色可渲染的像素格式。对于深度附件描述符，MTLRenderPassDepthAttachmentDescriptor，使用一个深度可渲染的像素格式，例如MTLPixelFormatDepth32Float。对于一个模板缓冲描述符，使用一个模板可渲染的像素格式，例如MTLPixelFormatStencil8。在设备上每个像素实际使用纹理内存的数量不总是匹配Metal框架代码的纹理像素格式的大小。因为设备添加了对齐的填料或者其他的目的。参见Metal特性表集章节对于每种像素格式实际使用了多少内存，同样大小的限制和附件的数量。##### 加载和存储动作附件描述符的loadAction和storeAction属性指定了一个动作，这个动作执行在渲染通道的开始或结束。([<font color="Fuchsia">MTLParallelRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder)，加载和存储动作出现在整个命令边界，而不是每个[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)对象。相关详细信息，参见多线程渲染通道)。可能的loadAction值包括:* MTLLoadActionClear，写相同的值到指定附件描述符的每个像素。关于这个动作的详细信息，参见指定清除加载动作。* MTLLoadActionLoad，保留现有的纹理内容。* MTLLoadActionDontCare，允许附件的每个像素获得在渲染通道初始任意值。如果你的应用程序将渲染给定帧的附件的所有像素，使用默认加载动作MTLLoadActionDontCare。MTLLoadActionDontCare动作允许GPU避免加载已存在的纹理内容，确保最佳的新能。否则，你可以使用MTLLoadActionClear动作来清除附件以前的内容，或者MTLLoadActionLoad动作来保留他们。MTLLoadActionClear动作也避免了加载已存在的纹理内容，但是它引发了用纯色填充终点的消耗。可能的storeAction值包括:* MTLStoreActionStore，保存渲染通道的最终结果到附件。* MTLStoreActionMultisampleResovle，解决来自渲染目标多采样数据到单一采样值，通过附件属性resolveTexture来指定他们存储的纹理，保留未定义附件内容。相关详细信息，参见例子:创建一个多采样渲染的渲染管道描述符。* MTLStoreActionDontCare，在渲染通道完成时以未定义状态保留附件。这可能提高性能，它使避免任何保存渲染结果的必要工作的实现成为可能。对于颜色附件，MTLStoreActionStore动作是默认存储动作，由于应用程序几乎总是保存渲染管道末尾附件的最终颜色值。对于深度和模板附件，MTLStoreActionDontCare是默认存储动作，因为那些附件表示性地不需要被保存在渲染通道完成时。##### 指定清除加载动作如果附件描述符的加载动作属性设置为MTLLoadActionClear，那么清除值被写入渲染通道起始位置指定附件描述符的每个像素。清除值依赖于附件类型。* MTLRenderPassColorAttachmentDescriptor，clearColor包含一个MTLClearColor值，该值包含四个双精度浮点数RGBA组件并用来清除颜色附件。MTLClearColorMake函数创建了一个来自红，绿，蓝和透明组件的清除颜色值。默认清除颜色值为(0.0, 0.0, 0.0, 1.0),或者不透明黑色。* MTLRenderPassDepthAttachmentDescriptor，clearDepth包含一个在[0.0, 1.0]之间的双精度浮点数，这个值用于清除深度附件。默认值是1.0。* MTLRenderPassStencilAttachmentDescriptor，clearStencil包含一个32位无符号整形数，它被用来去清除模板附件。默认值是0。例子:用加载和存储动作创建一个渲染通道描述符清单5-1 用颜色和深度附件创建一个简单的渲染通道描述符。首先，两个纹理对象被创建，一个是有颜色可渲染的像素格式和另外一个深度像素格式。其次<font color="Fuchsia">MTLRenderPassDescriptor</font>的renderPassDescriptor便利方法创建一个默认的渲染管道描述符。然后通过<font color="Fuchsia">MTLRenderPassDescriptor</font>的属性访问颜色和深度附件。纹理和动作被设置在colorAttachments[0]，其表示了第一个颜色附件(在数组索引0)和深度附件。清单5-1 用颜色和深度附件创建一个渲染管道描述符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MTLTextureDescriptor *colorTexDesc = [MTLTextureDescriptor</span><br><span class="line">           texture2DDescriptorWithPixelFormat:MTLPixelFormatRGBA8Unorm</span><br><span class="line">           width:IMAGE_WIDTH height:IMAGE_HEIGHT mipmapped:NO];</span><br><span class="line">id &lt;MTLTexture&gt; colorTex = [device newTextureWithDescriptor:colorTexDesc];</span><br><span class="line"> </span><br><span class="line">MTLTextureDescriptor *depthTexDesc = [MTLTextureDescriptor</span><br><span class="line">           texture2DDescriptorWithPixelFormat:MTLPixelFormatDepth32Float</span><br><span class="line">           width:IMAGE_WIDTH height:IMAGE_HEIGHT mipmapped:NO];</span><br><span class="line">id &lt;MTLTexture&gt; depthTex = [device newTextureWithDescriptor:depthTexDesc];</span><br><span class="line"> </span><br><span class="line">MTLRenderPassDescriptor *renderPassDesc = [MTLRenderPassDescriptor renderPassDescriptor];</span><br><span class="line">renderPassDesc.colorAttachments[0].texture = colorTex;</span><br><span class="line">renderPassDesc.colorAttachments[0].loadAction = MTLLoadActionClear;</span><br><span class="line">renderPassDesc.colorAttachments[0].storeAction = MTLStoreActionStore;</span><br><span class="line">renderPassDesc.colorAttachments[0].clearColor = MTLClearColorMake(0.0,1.0,0.0,1.0);</span><br><span class="line"> </span><br><span class="line">renderPassDesc.depthAttachment.texture = depthTex;</span><br><span class="line">renderPassDesc.depthAttachment.loadAction = MTLLoadActionClear;</span><br><span class="line">renderPassDesc.depthAttachment.storeAction = MTLStoreActionStore;</span><br><span class="line">renderPassDesc.depthAttachment.clearDepth = 1.0;</span><br></pre></td></tr></table></figure>##### 例子：创建一个多采样渲染的渲染管道描述符为了使用MTLStoreActionMultisampleResolve动作，你必须设置texture属性为一个多采样类型的纹理，resovleTexture属性将包含多采样解决操作的结果。(如果纹理不支持多采样，那么一个多采样解决动作是未定义的结果。)resolveLevel，resolveSlice和resolveDepthPlane属性可能也被用于多采样解决操作去分别指定纹理映射级别，立方体切片，多采样纹理的深度表面。大多数情况，resolveLevel默认值，resovleSlice和resolveDepthPlain是可用的。在清单5-2，附件被初始化创建并它的loadAction，storeAction，texture和resovleTexture属性被设置支持多采样解决。清单5-2 设置多采样解决附件属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MTLTextureDescriptor *colorTexDesc = [MTLTextureDescriptor</span><br><span class="line">           texture2DDescriptorWithPixelFormat:MTLPixelFormatRGBA8Unorm</span><br><span class="line">           width:IMAGE_WIDTH height:IMAGE_HEIGHT mipmapped:NO];</span><br><span class="line">id &lt;MTLTexture&gt; colorTex = [device newTextureWithDescriptor:colorTexDesc];</span><br><span class="line"> </span><br><span class="line">MTLTextureDescriptor *msaaTexDesc = [MTLTextureDescriptor</span><br><span class="line">           texture2DDescriptorWithPixelFormat:MTLPixelFormatRGBA8Unorm</span><br><span class="line">           width:IMAGE_WIDTH height:IMAGE_HEIGHT mipmapped:NO];</span><br><span class="line">msaaTexDesc.textureType = MTLTextureType2DMultisample;</span><br><span class="line">msaaTexDesc.sampleCount = sampleCount;  //  must be &gt; 1</span><br><span class="line">id &lt;MTLTexture&gt; msaaTex = [device newTextureWithDescriptor:msaaTexDesc];</span><br><span class="line"> </span><br><span class="line">MTLRenderPassDescriptor *renderPassDesc = [MTLRenderPassDescriptor renderPassDescriptor];</span><br><span class="line">renderPassDesc.colorAttachments[0].texture = msaaTex;</span><br><span class="line">renderPassDesc.colorAttachments[0].resolveTexture = colorTex;</span><br><span class="line">renderPassDesc.colorAttachments[0].loadAction = MTLLoadActionClear;</span><br><span class="line">renderPassDesc.colorAttachments[0].storeAction = MTLStoreActionMultisampleResolve;</span><br><span class="line">renderPassDesc.colorAttachments[0].clearColor = MTLClearColorMake(0.0,1.0,0.0,1.0);</span><br></pre></td></tr></table></figure>##### 使用渲染管道描述符创建渲染命令编码器在你创建一个渲染管道描述符后并指定它的属性，使用[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)对象的<font color="DeepSkyBlue">renderCommandEncoderWithDescriptor:</font>方法来创建一个渲染命令编码器，如清单5-3所示:清单5-3 用渲染管道描述符创建渲染命令编码器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id &lt;MTLRenderCommandEncoder&gt; renderCE = [commandBuffer</span><br><span class="line">                    renderCommandEncoderWithDescriptor:renderPassDesc];</span><br></pre></td></tr></table></figure>### 用核心动画显示渲染内容核心动画定义了CAMetalLayer类，它为一个使用Metal渲染的层支持视图的专业行为而设计。CAMetalLayer对象表示关于内容(位置和大小)的几何结构信息，它的可视化属性(背景色，边界和阴影)，并且资源使用Metal来表现颜色附件内容。它也封装了内容呈现的时机以便在可用或者在指定时间尽可能快的显示。核心动画的更多信息，参见核心动画编程指南。核心动画也定义了显示资源对象的CAMetalDrawable协议。扩展MTLDrawable的CAMetalDrawable协议提供了遵循MTLTexture协议的对象，所以它可以被用作渲染命令的终点。渲染CAMetalLayer对象，你应当获取一个新的CAMetalDrawable对象对于每个渲染通道，获取它提供的MTLTexture对象，并使用哪个纹理来创建颜色附件。不像颜色附件，深度或者模板附件的创建和销毁是代价很高的。如果你需要深度或模板附件，创建他们一次并在帧渲染时重用他们。表示性地，你使用<font color="DeepSkyBlue">layerClass</font>方法来指定CAMetalLayer作为你自己自定义的UIView子类的支持层，如清单5-4所示。否则，你可以用它的<font color="DeepSkyBlue">init</font>方法来创建一个CAMetalLayer，已存在的视图中包含这个层。清单5-4 使用CAMetalLayer作为UIView子类的支持层<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id) layerClass &#123;</span><br><span class="line">    return [CAMetalLayer class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>为了用Metal渲染层的内容，你必须获取一个来自CAMetalLayer对象可显示的资源(一个<font color="Fuchsia">CAMetalDrawable</font>对象)，然后通过附加它到一个<font color="Fuchsia">MTLRenderPassDescriptor</font>对象源渲染纹理的这个资源。为此，你首先设置<font color="Fuchsia">CAMetalLayer</font>对象的属性，它们描述了其提供的可绘制资源，然后每次在你开始渲染一个新帧时调用它的<font color="DeepSkyBlue">nextDrawable</font>方法。如果<font color="Fuchsia">CAMetalLayer</font>属性不设置，<font color="DeepSkyBlue">nextDrawable</font>方法会调用失败。<font color="Fuchsia">CAMetalLayer</font>的下列属性描述可绘制对象:* <font color="DarkGray">device</font>属性声明了[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)对象创建资源。* <font color="DarkGray">pixelFormat</font>属性声明纹理像素格式。支持的值时MTLPixelFormatBGRA8Unorm(默认)和MTLPixelFormatBGRA8Unorm_sRGB。* <font color="DarkGray">drawableSize</font>属性声明了设备像素的纹理尺寸。确保你应用以精准的尺寸显示渲染内容(在相同的设备上不需要额外采样阶段)，当计算你的层期望的尺寸时考虑目标屏幕的nativeScale或nativeBounds属性。* <font color="DarkGray">framebufferOnly</font>属性声明是否纹理可以被仅仅用作附件(YES)或者是否它可以被用作纹理采样和像素读/写操作(NO)。如果YES，层对象可以优化纹理显示。对于大多数应用，推荐值为YES。* <font color="DarkGray">presentsWithTransaction</font>属性声明了是否用核心动画事务机制(YES)改变层的渲染资源更新或者被异步更新到普通层(NO，默认值)。如果<font color="DeepSkyBlue">nextDrawable</font>方法成功，它返回一个带有下列只读属性的<font color="Fuchsia">CAMetalDrawable</font>对象:* <font color="DarkGray">texture</font>属性持有纹理对象。当创建你的渲染管线(<font color="Fuchsia">MTLRenderPipelineColorAttachmentDescriptor</font>)时使用这个作为一个附件。* 指向<font color="Fuchsia">CAMetalLayer</font>对象的<font color="DarkGray">layer</font>属性负责显示几何体。> 重要说明:只有一套小的几何体资源，所以一个长的帧渲染时间可以临时耗尽那些资源并引起<font color="DeepSkyBlue">nextDrawable</font>方法调用它的CPU线程直到这个方法完成。避免昂贵的CPU停转，在调用CAMetalLayer对象的<font color="DeepSkyBlue">nextDrawable</font>方法之前执行不需要可绘制资源的所有每帧操作。在渲染完成后显示几何体的内容，你必须通过调用可绘制对象的present方法提交它到核心动画。随着负责它渲染的命令缓冲的完成来同步显示几何体，你可以调用[<font color="Fuchsia">MTLCommandBuffer</font>](https://developer.apple.com/documentation/metal/mtlcommandbuffer)的<font color="DeepSkyBlue">[presentDrawable:](https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443029-presentdrawable)</font>或<font color="DeepSkyBlue">presentDrawable:atTime:</font>便利方法。这些方法使用预定的处理程序(参见注册命令缓冲执行的处理程序块)来调用几何体的<font color="DeepSkyBlue">present</font>方法，它覆盖了大多数场景。<font color="DeepSkyBlue">presentDrawable:atTime:</font>方法提供了当几何体被显示时更进一步的控制。### 创建一个渲染管线状态使用一个[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)对象来编码渲染命令，你必须首先指定一个<font color="Fuchsia">MTLRenderPipelineState</font>对象来定义每次绘制调用的图形状态。渲染管线状态对象是一个可以在渲染命令编码器外部被创建的长时间持久化对象，提前缓存和穿过多个渲染命令编码器被重用。当描述同一套图形状态时，重用一个以前创建的渲染管线状态对象可能避免再求值和转化CPU命令指定状态的高耗费操作。渲染管线状态是一个不可变对象。创建一个渲染管线状态，首先创建和配置一个可变的描述渲染管线状态属性的<font color="Fuchsia">MTLRenderPipelineDescriptor</font>对象。然后，使用描述符来创建一个<font color="Fuchsia">MTLRenderPipelineState</font>对象。#### 创建和配置一个渲染管线描述符创建渲染管线状态，首先创建一个<font color="Fuchsia">MTLRenderPipelineDescriptor</font>对象，其有属性来描述在渲染过程中你想使用的图像渲染管线状态，如图表5-2所示。新的<font color="Fuchsia">MTLRenderPipelineDescriptor</font>的<font color="DarkGray">colorAttachment</font>属性包含一组<font color="Fuchsia">MTLRenderPipelineColorAttachmentDescript</font>对象，每个描述符表示一个颜色附件状态，其指定混合操作和那个附件因子，详见配置渲染管线附件描述符的混合。附件描述符也指定了附件的像素格式，它必须匹配渲染管线描述符的像素格式，使用相应的附件索引，或者一个错误的出现。图表 5-2 从描述符创建一个渲染描述状态![img-w360](https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/PipelineState_2x.png)除了配置颜色附件之外，设置<font color="Fuchsia">MTLRenderPipelineDescriptor</font>对象的这些属性* 设置<font color="DarkGray">depthAttachmentPixelFormat</font>属性用<font color="Fuchsia">MTLRenderPassDescriptor</font>来匹配<font color="DarkGray">depthAttachment</font>纹理像素格式。* 设置<font color="DarkGray">stencilAttachmentPixelFormat</font>属性用<font color="Fuchsia">MTLRenderPassDescriptor</font>来匹配<font color="DarkGray">stencilAttachment</font>纹理像素格式。* 指定在渲染管线状态的顶点或片元着色器，分别设置<font color="DarkGray">vertexFunction</font>或<font color="DarkGray">fragmentFunction</font>属性，设置<font color="DarkGray">fragmentFunction</font>为nil禁用像素光栅化到指定颜色附件，其表示性地使用仅仅深度渲染或对于输出数据从顶点着色器进入一个缓冲对象。* 如果顶点着色器有一个带有每个顶点输入属性的参数，设置<font color="DarkGray">vertexDescriptor</font>属性来设置描述顶点数据的组成在那个参数，如数据组成顶点描述符所述。* <font color="DarkGray">reasteriazationEnabled</font>属性的默认值YES对于大多数典型渲染任务是足够的。只使用图形管线的顶点阶段(例如，收集顶点数据转换)，设置这个属性为NO。* 如果附件支持多采样(就是说，附件是一个<font color="Fuchsia">MTLTextureTypeDMultisample</font>类型纹理)，那么每个像素多采样可以被创建。决定片元如何结合提供的像素覆盖，使用<font color="Fuchsia">MTLRenderPipelineDescriptor</font>的下列属性。    * <font color="DarkGray">sampleCount</font>属性决定每个像素采样数量。当[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)被创建，对于所有附件纹理的<font color="DarkGray">sampleCount</font>必须匹配这个<font color="DarkGray">sampleCount</font>属性。如果附件不支持多采样，那么<font color="DarkGray">sampleCount</font>是1，这也是默认值。    * 如果<font color="DarkGray">alphaToCoverageEnabled</font>被设置为YES，那么<font color="DarkGray">colorAttachments[0]</font>透明通道片元输出被读并用来决定覆盖面。    * 如果<font color="DarkGray">alphaToOneEnabled</font>被设置为YES，那么<font color="DarkGray">colorAttachment[0]</font>透明通道片元被强制设置为1，这是最大的可表示的值。(其他附件不受影响。)#### 从描述符创建一个渲染管线状态在创建一个渲染管线描述符和指定其属性后，用它来创建MTLRenderPipelineState对象。因为创建一个渲染管线状态可能需要图形状态的一个昂贵的估价和指定图形着色器的可能的编译，你可以使用一个代码块或一个异步方法以一种最适合你应用的方式来安排这样的工作。* 同步创建渲染管线状态对象，调用[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)对象的newRenderPipelineStateWithDescriptor:error:或newRenderPipelineStateWithDescriptor:options:reflections:error:方法。这些方法阻塞了当前线程，当Metal评估描述符图像状态信息和编译着色器代码来创建管线状态对象。* 异步创建着色器管线状态对象，调用[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)对象的newRenderPipelineStateWithDescriptor:completionHandler:或newRenderPipelineStateWithDescriptor:options:completionHandler:方法。这些方法立即返回---Metal异步评估描述符的图像状态信息和编译着色器代码来创建管线状态对象，然后调用完成回调提供新的MTLRenderPipelineState对象。当你创建一个MTLRenderPipelineState对像时，你也可以选择去创建揭示管线着色器函数及其参数的反射数据。newRenderPipelineStateWithDescriptor:options:reflection:error:和newRenderPipelineStateWithDescriptor:options:completionHandler:方法提供了这个数据。避免获取反射数据如果它将不被使用。更多关于如何分析反射数据的细节，参见运行时决定功能细节。在你创建一个MTLRenderPipelineState对象后，调用[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)的setRenderPipelineState:方法来关联的渲染管线状态和渲染使用的命令编码器。清单5-5 演示渲染管线状态被称为pipeline的对象的创建。清单5-5 创建一个简单的管线状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MTLRenderPipelineDescriptor *renderPipelineDesc =</span><br><span class="line">                             [[MTLRenderPipelineDescriptor alloc] init];</span><br><span class="line">renderPipelineDesc.vertexFunction = vertFunc;</span><br><span class="line">renderPipelineDesc.fragmentFunction = fragFunc;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatRGBA8Unorm;</span><br><span class="line"> </span><br><span class="line">// Create MTLRenderPipelineState from &lt;font color=Fuchsia&gt;MTLRenderPipelineDescriptor&lt;/font&gt;</span><br><span class="line">NSError *errors = nil;</span><br><span class="line">id &lt;MTLRenderPipelineState&gt; pipeline = [device</span><br><span class="line">         newRenderPipelineStateWithDescriptor:renderPipelineDesc error:&amp;errors];</span><br><span class="line">assert(pipeline &amp;&amp; !errors);</span><br><span class="line"> </span><br><span class="line">// Set the pipeline state for [&lt;font color=Fuchsia&gt;MTLRenderCommandEncoder&lt;/font&gt;](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)</span><br><span class="line">[renderCE setRenderPipelineState:pipeline];</span><br></pre></td></tr></table></figure>变量vertFunc和fragFunc是着色器函数，他们被指定作为渲染管线状态描述符的属性被称作renderPipelineDesc。调用[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)对象的newRenderPipelineStateWithDescriptor:error:方法同步地使用管线状态描述符来创建管线状态对象。调用[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)的setRenderPipelineState:方法指定MTLRenderPipelineState对象和渲染命令编码器一起使用。> 注意:因为创建一个MTLRenderPipelineState对象是昂贵的，无论何时你打算使用相同图像状态应该重用它。#### 配置渲染管线附件描述符混合使用一个高可配置的缓和操作的混合来混合通过带有附件(终点)像素值的片元函数(来源)返回的输出。混合操作决定来源和终点的值是如何与混合因子结合起来的。配置颜色附件的混合，设置MTLRenderPipelineColorAttachmentDescriptor的下列属性:* 开启混合，设置blendingEnabled为YES。混合默认是关闭的。* writeMask识别哪个颜色通道被混合。默认值MTLColorWriteMaskAll允许所有颜色通道被混合。* rgbBlendOperation和alphaBlendOperation分别用一个MTLBlendOperation值分配RGB和透明片元数据的混合操作。两个属性默认值是MTLBlendOperationAdd。* sourceRGBBlendFactor，sourceAlphaBlendFactor，destinationRGBBlendFactor和destinationAlphaBlendFactor分配来源和终点混合因子。#### 理解混合因子和操作四个混合因子指向一个常量混合颜色值:MTLBlendFactorBlendColor，MTLBlendFactorOneMinusBlendColor，MTLBlendFactorBlendAlpha和MTLBlendFactorOneMinusBlendAlpha。调用[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)的setBlendColorRed:green:blue:alpha:方法用这些混合因子来指定常量颜色和透明值，如固定功能状态操作所述。一些混合操作结合片元值通过源值乘以MTLBlendFactor值(缩写SBF)，通过终点混合因子(DBF)乘以终点值并结合使用算术MTLBlendOperation表示的值的结果。(如果混合操作是MTLBlendOperationMin或MTLBlendOperationMax，SBF和DBF混合因子被忽略。)例如，MTLBlendOperationAdd对于如果被BlendOperation和alphaBlendOperation属性定义在下列RGB和透明值的添加剂混合操作:* RGB = (Source.rgb * sourceRGBBlendFactor) + (Dest.rgb * destinationRGBBlendFactor)* Alpha = (Source.a * sourceAlphaBlendFactor) + (Dest.a * destinationAlphaBlendFactor)在默认的混合行为中，来源完全重写终点。这种行为等价于设置sourceRGBBlendFactor和sourceAlphaBlendFactor为MTLBlendFactorOne，destinationRGBBlendFactor和destinationAlphaBlendFactor为MTLBlendFactorZero。用数学表达这种行为:* RGB = (Source.rgb * 1.0) + (Dest.rgb * 0.0)* A = (Source.a * 1.0) + (Dest.a * 0.0)另一个正常的使用混合操作，源透明定义了保留多少终点颜色，用数学表达为:* RGB = (Source.rgb * 1.0) + (Dest.rgb * (1 - Source.a))* A = (Source.a * 1.0) + (Dest.a * (1 - Source.a))#### 使用自定义混合配置清单5-6显示了自定义混合配置的代码，使用混合操作MTLBlendOperationAdd，源混合因子MTLBlendFactorOne，终点混合因子MTLBlenderOneMinusSourceAlpha。colorAttachments[0]是一个带有指定混合配置属性的MTLRenderPipelineColorAttachmentDescriptor对象。清单5-6 指定一个自定义混合配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MTLRenderPipelineDescriptor *renderPipelineDesc = </span><br><span class="line">                             [[MTLRenderPipelineDescriptor alloc] init];</span><br><span class="line">renderPipelineDesc.colorAttachments[0].blendingEnabled = YES; </span><br><span class="line">renderPipelineDesc.colorAttachments[0].rgbBlendOperation = MTLBlendOperationAdd;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].destinationRGBBlendFactor = </span><br><span class="line">       MTLBlendFactorOneMinusSourceAlpha;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = </span><br><span class="line">       MTLBlendFactorOneMinusSourceAlpha;</span><br><span class="line"></span><br><span class="line">NSError *errors = nil;</span><br><span class="line">id &lt;MTLRenderPipelineState&gt; pipeline = [device </span><br><span class="line">         newRenderPipelineStateWithDescriptor:renderPipelineDesc error:&amp;errors];</span><br></pre></td></tr></table></figure>### 指定渲染命令编码器资源在这部分讨论的[<font color="Fuchsia">MTLRenderCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)方法指定被用做顶点和片元着色器函数参数的资源，它们被指定通过在MTLRenderPipelineState对象的vertexFunction和fragmentFunction属性。这些方法分配了一个着色器资源(缓冲，纹理和采样器)到相应的参数表索引(atIndex)在渲染命令编码器中，如图表5-3所示。图表 5-3 渲染指令编码器的参数表![img-w600](https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/ArgTable-render_2x.png)下列setVertex*方法分配顶点着色器函数的相应参数的一个或多个资源。* <font color="DeepSkyBlue">setVertexBuffer:offset:atIndex:</font>* <font color="DeepSkyBlue">setVertexBuffers:offsets:withRange:</font>* <font color="DeepSkyBlue">setVertexTexture:atIndex:</font>* <font color="DeepSkyBlue">setVertexTextures:withRange:</font>* <font color="DeepSkyBlue">setVertexSamplerState:atIndex:</font>* <font color="DeepSkyBlue">setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:</font>* <font color="DeepSkyBlue">setVertexSamplerStates:withRange:</font>* <font color="DeepSkyBlue">setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:</font><p>setFragment*方法同样的分配一个或多个资源对于相应的片元着色器函数的参数。</p><ul><li><font color="DeepSkyBlue">setFragmentBuffer:offset:atIndex:</font></li><li><font color="DeepSkyBlue">setFragmentBuffers:offsets:withRange:</font></li><li><font color="DeepSkyBlue">setFragmentTexture:atIndex:</font></li><li><font color="DeepSkyBlue">setFragmentTextures:withRange:</font></li><li><font color="DeepSkyBlue">setFragmentSamplerState:atIndex:</font></li><li><font color="DeepSkyBlue">setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:</font></li><li><font color="DeepSkyBlue">setFragmentSamplerStates:withRange:</font></li><li><font color="DeepSkyBlue">setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:</font></li></ul><p>缓冲参数表的有31个条目，纹理参数表有31个条目，采样器状态参数表有16个条目。</p><p>属性限定符指定Metal着色语言源码的资源位置必须匹配Metal框架方法的参数表索引。在清单5-7中，各自被定义在顶点着色器中有索引0和1的两个缓冲区(posBuf和texCoordBuf)</p><p>清单5-7 Metal框架:指定顶点函数资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[renderEnc setVertexBuffer:posBuf offset:0 atIndex:0];</span><br><span class="line">[renderEnc setVertexBuffer:texCoordBuf offset:0 atIndex:1];</span><br></pre></td></tr></table></figure><p>清单5-8 Metal着色语言:顶点函数参数匹配框架参数表索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vertex VertexOutput metal_vert(float4 *posData [[ buffer(0) ]],</span><br><span class="line">                               float2 *texCoordData [[ buffer(1) ]])</span><br></pre></td></tr></table></figure><p>相似地，在清单5-9中，缓冲，纹理和采样器(分别的fragmentColorBuf，shadeTex和sampler)，所有索引为0的，被定义在片元着色器。</p><p>清单5-9 Metal框架:指定片元函数资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[renderEnc setFragmentBuffer:fragmentColorBuf offset:0 atIndex:0];</span><br><span class="line">[renderEnc setFragmentTexture:shadeTex atIndex:0];</span><br><span class="line">[renderEnc setFragmentSamplerState:sampler atIndex:0];</span><br></pre></td></tr></table></figure><p>在清单5-10中，函数签名有带有属性限定符<font color="DarkMagenta">buffer(0)</font>， <font color="DarkMagenta">texture(0)</font>和<font color="DarkMagenta">sampler(0)</font>相应的参数。</p><p>清单5-10 Metal着色语言:片元函数参数匹配框架参数表索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fragment float4 metal_frag(VertexOutput in [[stage_in]],</span><br><span class="line">                           float4 *fragColorData [[ buffer(0) ]],</span><br><span class="line">                           texture2d&lt;float&gt; shadeTexValues [[ texture(0) ]],</span><br><span class="line">                           sampler samplerValues [[ sampler(0) ]] )</span><br></pre></td></tr></table></figure><h4 id="数据组织的顶点描述符"><a href="#数据组织的顶点描述符" class="headerlink" title="数据组织的顶点描述符"></a>数据组织的顶点描述符</h4><p>在Metal框架代码中，对于每个管线状态可以有一个MTLVertexDescriptor，它描述了顶点着色函数输入数据的组织和在着色语言和框架代码之间共享资源位置信息。</p><p>在Metal着色语言代码中，每个顶点输入(例如整型活浮点型值的标量或矢量)可以被组织在一个结构体中，它可以被传递进一个用<font color="DarkMagenta">[[ stage_in ]]</font>声明属性限定符声明的参数，正如清单5-11中顶点函数vertexMath例子中看到的VertexInput结构体。每个顶点的输入结构体的各个域有<font color="DarkMagenta">[[ attribute(index) ]]</font>限定符，它指定了顶点属性参数表的索引。</p><p>清单5-11 Metal着色语言:带有属性索引的顶点函数输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct VertexInput &#123;</span><br><span class="line">    float2    position [[ attribute(0) ]];</span><br><span class="line">    float4    color    [[ attribute(1) ]];</span><br><span class="line">    float2    uv1      [[ attribute(2) ]];</span><br><span class="line">    float2    uv2      [[ attribute(3) ]];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct VertexOutput &#123;</span><br><span class="line">    float4 pos [[ position ]];</span><br><span class="line">    float4 color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vertex VertexOutput vertexMath(VertexInput in [[ stage_in ]])</span><br><span class="line">&#123;</span><br><span class="line">  VertexOutput out;</span><br><span class="line">  out.pos = float4(in.position.x, in.position.y, 0.0, 1.0);</span><br><span class="line"></span><br><span class="line">  float sum1 = in.uv1.x + in.uv2.x;</span><br><span class="line">  float sum2 = in.uv1.y + in.uv2.y;</span><br><span class="line">  out.color = in.color + float4(sum1, sum2, 0.0f, 0.0f);</span><br><span class="line">  return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定着色器函数功能输入使用<font color="DarkMagenta">[[ stage_in ]]</font>限定符，描述MTLVertexDescriptor对象，设置它作为MTLRenderPipelineState的vertexDescriptor属性。MTLVertexDescriptor有两个属性:attributes和layouts。</p><p>MTLVertexDescriptor的attributes属性是一个MTLVertexAttributeDescriptorArray对象，它定义了每个顶点属性在被纹理映射到顶点函数参数的缓冲中是如何组织的。attributes属性可以支持存取多个属性(例如顶点坐标，表面法线和纹理顶点)在相同缓冲区内是交叉的。在着色语言代码中成员的顺序没有必要被保存在框架代码的缓冲区中。数组中的每个顶点属性描述符有一下属性，提供一个顶点着色函数信息去定位和加载参数数据:</p><ul><li>bufferIndex，是一个缓冲参数表的索引，指定哪个MTLBuffer被访问。缓冲参数表在渲染命令编码器的指定资源章节中被讨论。</li><li>format，指定在框架代码中的数据应当如何被解释。如果数据类型不是一个精确的类型匹配，它可能被转换或扩展。例如，如果着色语言类型是half4，框架format是MTLVertexFormatFloat2，那么当数据被用作一个顶点函数的参数时，它可能被从浮点数转换到half并且扩展从2到4个元素(用0.0, 1.0在最后两个元素)。</li><li>offset，指定数据从顶点的起点开始被发现的位置。</li></ul><p>图表 5-4 在Metal框架代码中阐明MTLVertexAttributeDescriptorArray，实现一个交叉缓冲区，和在清单5-11中的着色器语言代码中的顶点函数vertexMath的输入一致。</p><p>图表 5-4 带有顶点属性描述符的缓冲区组织</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/vertex-layout_2x.png" alt="img-w600"></p><p>清单5-12 和图表 5-4中显示的交叉缓冲区相对应的Metal框架代码。</p><p>清单5-12 Metal框架:使用一个顶点描述符访问交叉数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">id &lt;&lt;font color=Fuchsia&gt;MTLFunction&lt;/font&gt;&gt; vertexFunc = [library newFunctionWithName:@&quot;vertexMath&quot;];            </span><br><span class="line">&lt;font color=Fuchsia&gt;MTLRenderPipelineDescriptor&lt;/font&gt;* pipelineDesc =      </span><br><span class="line">                             [[&lt;font color=Fuchsia&gt;MTLRenderPipelineDescriptor&lt;/font&gt; alloc] init];</span><br><span class="line">MTLVertexDescriptor* vertexDesc = [[MTLVertexDescriptor alloc] init];</span><br><span class="line"></span><br><span class="line">vertexDesc.attributes[0].format = MTLVertexFormatFloat2;</span><br><span class="line">vertexDesc.attributes[0].bufferIndex = 0;</span><br><span class="line">vertexDesc.attributes[0].offset = 0;</span><br><span class="line">vertexDesc.attributes[1].format = MTLVertexFormatFloat4;</span><br><span class="line">vertexDesc.attributes[1].bufferIndex = 0;</span><br><span class="line">vertexDesc.attributes[1].offset = 2 * sizeof(float);  // 8 bytes</span><br><span class="line">vertexDesc.attributes[2].format = MTLVertexFormatFloat2;</span><br><span class="line">vertexDesc.attributes[2].bufferIndex = 0;</span><br><span class="line">vertexDesc.attributes[2].offset = 8 * sizeof(float);  // 32 bytes</span><br><span class="line">vertexDesc.attributes[3].format = MTLVertexFormatFloat2;</span><br><span class="line">vertexDesc.attributes[3].bufferIndex = 0;</span><br><span class="line">vertexDesc.attributes[3].offset = 6 * sizeof(float);  // 24 bytes</span><br><span class="line">vertexDesc.layouts[0].stride = 10 * sizeof(float);    // 40 bytes</span><br><span class="line">vertexDesc.layouts[0].stepFunction = MTLVertexStepFunctionPerVertex;</span><br><span class="line"></span><br><span class="line">pipelineDesc.vertexDescriptor = vertexDesc;</span><br><span class="line">pipelineDesc.vertexFunction = vertFunc;</span><br></pre></td></tr></table></figure><p>在MTLVertexDescriptor对象的attributes数组中的每个MTLVertexAttributeDescriptor对象和着色函数中VertexInput的索引结构体成员相对应。attributes[1].bufferIndex = 0指定参数表索引是0的缓冲的使用。(在这个例子中，每个MTLVertexAttributeDescriptor有相同的bufferIndex，所以每个指向参数表中的索引为0的相同顶点缓冲。)offset值指定在顶点中数据的位置，所以attributes[1].offset = 2 * sizeof(float)位于来自缓冲区起始位置的相应数据的8个字节的开头。format值被选择匹配着色函数的数据类型，所以attributes[1].format = MTLVertexFormatFloat4指定使用四个浮点数值。</p><p>MTLVertexDescriptor的layouts属性是一个MTLVertexBufferLayoutDescriptorArray。对于在layouts中的每个MTLVertexBufferLayoutDescriptor，属性指定当Metal绘制基元时顶点和属性数据是如何从相应的位于参数表中的MTLBuffer中获取的。(对于更多关于绘制基元的内容，参见绘制几何基元。)MTLVertexBufferLayoutDescriptor的stepFunction属性决定是否去获取每个顶点的属性数据，对于一些数量的实例，或仅此一次。如果stepFunction被设置来获取一些数量实例的属性数据，那么MTLVertexBufferLayoutDescriptor的stepRate属性决定多少实例。stride属性指定两顶点的数据之间的距离，以字节计算。</p><p>图表 5-5 描述MTLVertexBufferLayoutDescriptor对应的diamante在清单5-12中。layout[0]指定如何从缓冲区参数表对应索引0的位置获取顶点数据。layouts[0].stride指定在两个顶点数据之间的40个字节的一个距离。layout[0].stepFunction的值MTLVertexStepFunctionPerVertex，指定绘制时每个顶点获取到的属性数据。如果stepFunction的值时MTLVertexStepFunctionPerInstance，stepRate属性决定了属性数据多久获取一次。例如，如果stepRate是1，数据被获取对于每个实例；如果stepRate是2，对于每两个实例，等等。</p><p>图表 5-5 缓冲区组织用顶点缓冲布局描述符</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/vertex-layout_detailed_2x.png" alt="img-w600"></p><h3 id="执行固定功能渲染命令编码器操作"><a href="#执行固定功能渲染命令编码器操作" class="headerlink" title="执行固定功能渲染命令编码器操作"></a>执行固定功能渲染命令编码器操作</h3><p>使用这些<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>方法设置固定功能图形状态值:</p><ul><li>setViewport:指定在屏幕坐标中的区域，它是虚拟3D世界投影的终点。视口是3D，所以它包含深度值；详情请见与视口和像素坐标系统一起工作。</li><li>setTriangleFillMode:决定是否光栅化三角形和有皱纹的三角形带基元(MTLTriangleFillModeLines)或作为填充三角形(MTLLTriangleFillModeFill)。默认值是MTLTriangleFillModeFill。</li><li><p>setCullMode:和setFrontFacingWinding:被一起使用去决定是否和如何挑选被应用。你可以使用挑选在一些几何模型上除去隐藏表面，例如一个用填充三角形渲染的可定向的球体。(表面是可定向的如果它的基元被一致地绘制按照顺时针或逆时针顺序)</p><ul><li>setFrontFacingWinding的值:表明是否一个正面基元有它的顶点按照顺时针(MTLWindingClockWise)被绘制或逆时针(MTLWindingCounterClockwise)顺序。默认值是MTLWindingClockWise。</li><li>setCullMode的值:表明是否去执行选择(MTLCullModeNone，如果选择被禁用)或去选择哪个基元类型(MTLCullModeFront或MTLCullModeBack)。</li></ul></li></ul><p>使用以下<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>方法去编码固定功能状态改变命令:</p><ul><li>setScissorRect:指定一个2D剪刀矩形。位于指定剪刀矩形外面的片元被丢弃。</li><li>setDepthStencilState:设置深度和模板测试状态如深度和模板状态中描述。</li><li>setStencilReferenceValue:指定模板引用值。</li><li>setDepthBias:slopeScale:clamp:指定一个对比阴影映射和来自片元着色器的深度值输出的调整。</li><li><p>setVisibilityResultMode:offset:决定是否去监控如果任何采样器通过深度和模板测试。如果设置MTLVisibilityResultModeBoolean，那么如果任何采样器通过深度和模板测试，一个非零值被写入一个由<font color="Fuchsia">MTLRenderPassDescriptor</font>的visibilityResultBuffer属性指定的缓冲区，如创建一个渲染通道描述符所述。</p><p>你可以使用这个模式去执行遮挡测试。如果你绘制一个边界盒子并且没有样本通过，那么你可以得出结论，在该边界盒子里面的任何对象被遮挡，因此不需要渲染。</p></li></ul><h4 id="使用视口和像素坐标系统"><a href="#使用视口和像素坐标系统" class="headerlink" title="使用视口和像素坐标系统"></a>使用视口和像素坐标系统</h4><p>Metal定义了其规格化设备坐标(NDC)系统作为中心在(0，0，0.5)的2×2×1立方体。左侧和底部的x和y分别被NDC系统指定为-1。右侧和顶部的x和y分别被NDC系统设置为+1。</p><p>视口指定来自NDC到窗口系统的转换。Metal视口是一个由<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>得setViewport:方法指定的3D转换。窗口原点坐标是在左上角。</p><p>在Metal中，像素中心偏移(0.5，0.5)。例如，原点像素有它的中心在(0.5，0.5)；其右边相邻像素的中心是(1.5，0.5)。这也是真实的纹理。</p><h4 id="执行深度和模板操作"><a href="#执行深度和模板操作" class="headerlink" title="执行深度和模板操作"></a>执行深度和模板操作</h4><p>深度和模板操作是如下指定的片段操作:</p><ol><li>指定一个自定义MTLDepthStencilDescriptor对象包含深度/模板状态的设置。创建一个自定义MTLDepthStencilDescriptor对象可能需要创建一个或两个MTLStencilDescriptor对象，适用于正面和背面基元。</li><li>通过调用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象的newDepthStencilStateWithDescriptor:方法来创建一个带有深度/模板状态描述符的MTLDepthStencilState对象.</li><li>设置深度/模板状态，调用支持MTLDepthStencilState的<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的setDepthStencilState:方法。</li><li>如果模板测试在使用，调用setStencilReferenceValue:来制定模板参考值。</li></ol><p>如果深度测试被启用，渲染管线状态必须包含一个深度附件来支持写深度值。执行模板测试，渲染管线状态必须包含一个模板附件。配置附件，参见创建和配置一个渲染管线描述符。</p><p>如果你经常改变深度/模板状态，那么你可能想重用状态描述符对象，修改其属性值需要创建更多的状态对象。</p><blockquote><p>注意: 从着色器函数中的深度格式纹理采样，着色器中实现采样操作不使用MTLSamplerState。</p></blockquote><p>使用如下所示的MTLDepthStencilDescriptor对象的属性来设置深度和模板状态:</p><ul><li>对深度附件开启写深度值，设置depthWriteEnabled为YES。</li><li>depthCompareFunction指定深度测试如何被执行。如果一个片元的深度值在深度测试中失败，该片元被丢弃。例如，通常被用到的MTLComapreFunctionLess函数引起比(以前写入的)像素深度距离观察者更远的片元值在深度测试中失败；换言之，该片段被认为是由早期的深度值闭塞。</li><li>frontFaceStencil和backFaceStencil属性分别指定一个各自的MTLStencilDescriptor对象对于正面和背面基元。对于正面和背面基元使用相同模板状态，你可以分配同一个MTLStencilDescriptor到frontFaceStencil和backFaceStencil属性。显式地禁用模板测试对于一个或两个表面，设置相应的属性为nil，默认值。</li></ul><p>显式地禁用模板状态是没有必要的。Metal基于模板描述符是否被配置到一个有效模板操作来决定是否去开启一个模板测试。</p><p>清单5-13 显示了一个创建的例子和对于MTLDepthStencilState对象的创建使用MTLDepthStencilDescriptor对象，然后使用渲染命令编码器。在这个例子中，正面基元的模板状态从深度/模板状态描述符的frontFaceStencil属性被存取。对于背面基元模板测试被显式地禁用。</p><p>清单5-13 创建和使用一个深度/模板描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MTLDepthStencilDescriptor *dsDesc = [[MTLDepthStencilDescriptor alloc] init];</span><br><span class="line">if (dsDesc == nil)</span><br><span class="line">     exit(1);   //  if the descriptor could not be allocated</span><br><span class="line">dsDesc.depthCompareFunction = MTLCompareFunctionLess;</span><br><span class="line">dsDesc.depthWriteEnabled = YES;</span><br><span class="line"> </span><br><span class="line">dsDesc.frontFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;</span><br><span class="line">dsDesc.frontFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;</span><br><span class="line">dsDesc.frontFaceStencil.depthFailureOperation = MTLStencilOperationIncrementClamp;</span><br><span class="line">dsDesc.frontFaceStencil.depthStencilPassOperation =</span><br><span class="line">                          MTLStencilOperationIncrementClamp;</span><br><span class="line">dsDesc.frontFaceStencil.readMask = 0x1;</span><br><span class="line">dsDesc.frontFaceStencil.writeMask = 0x1;</span><br><span class="line">dsDesc.backFaceStencil = nil;</span><br><span class="line">id &lt;MTLDepthStencilState&gt; dsState = [device</span><br><span class="line">                          newDepthStencilStateWithDescriptor:dsDesc];</span><br><span class="line"> </span><br><span class="line">[renderEnc setDepthStencilState:dsState];</span><br><span class="line">[renderEnc setStencilReferenceValue:0xFF];</span><br></pre></td></tr></table></figure><p>以下属性在MTLStencilDescriptor中定义模板测试:</p><ul><li>readMask是一个位掩码；GPU计算的按位“与”这个掩码与模板参考值与存储的模板值。模板测试时一个在作为结果的掩饰性参考和掩饰性存储值得对比。</li><li>writeMask是一个位掩码，约束通过模板操作被写到模板附件中的模板值。</li><li>stencilCompareFunction指定对于片元模板测试是如何被执行的。在清单5-13中，模板对照函数是MTLCompareFunctionEqual，所以模板测试通过掩饰性参考值是等于掩饰性模板值已经存储在一个片元的位置。</li><li>stencilFailureOperation，depthFailureOperation和depthStencilPassOperation指定存储到模板附件的模板值对于三个不同的测试结果该做什么:分别地，如果模板测试失败，如果模板测试通过但深度测试失败，或者模板和深度测试都成功。在前面的例子中，如果模板测试失败模板值是不变的(MTLStencilOperationKeep)，但是它是增加的如果模板测试通过，除非模板值可能已经是最大值(MTLStencilOperationIncrementClamp)。</li></ul><h3 id="绘制几何基元"><a href="#绘制几何基元" class="headerlink" title="绘制几何基元"></a>绘制几何基元</h3><p>在你已经确定管线状态和固定功能状态后，你可以调用下列<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>方法来绘制几何基元。这些绘制方法引用资源(例如包含顶点坐标，纹理坐标，表面法线及其他数据的缓冲区)与着色器函数和以前用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>确定的其他状态一起执行管线。</p><ul><li>drawPrimitives:vertexStart:vertexCount:instanceCount:渲染大量(instanceCount)使用连续数组元素的顶点数据基元的实例，开始于数组元素的索引vertexStart并结束于数组元素索引vertexStart + vertexCount - 1。</li><li>drawPrimitives:vertexStart:vertexCount:和以前的有一个instanceCount为1的方法相同。</li><li>drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:渲染大量(instanceCount)使用一个在MTLBuffer对象indexBuffer指定的索引列表基元实例。indexCount决定的数量指标。索引表开始于indexBuffer里的数据内indexBufferOffset字节偏移的索引。indexBufferOffset必须是索引大小的倍数，它由indexType决定。</li><li>drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:和以前的有一个instanceCount为1的方法类似。</li></ul><p>对于上述的每个基元渲染方法，第一个输入值用MTLPrimitiveType值中的一个来决定基元类型。其他输入值决定顶点被用来聚集基元。对于所有这些输入方法，instanceStart输入值决定绘制的第一个实例，instanceCount输入值决定绘制多少个实例。</p><p>像先前讨论的，setTriangleFillMode:决定是否三角形被渲染为填满或线框，setCullMode:和setFrontFacingWinding:设置决定是否GPU在渲染期间剔除三角形。对于更多信息，参见固定功能状态操作。</p><p>当渲染一个点基元时，顶点函数的着色器语言代码必须提供[[ point_size ]]属性，或点大小是未定义的。</p><p>当扁平渲染一个三角形基元时，第一个顶点(又称为引发顶点)的属性被整个三角形使用。顶点函数的着色语言代码必须提供<font color="DarkMagenta">[[ flat ]]</font>的插值限定符。</p><p>关于所有Metal着色语言属性和限定符更多细节，参见Metal着色语言指南。</p><h3 id="结束渲染过程"><a href="#结束渲染过程" class="headerlink" title="结束渲染过程"></a>结束渲染过程</h3><p>结束渲染过程，调用在渲染命令编码上的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>函数。在结束以前的命令编码器后，你可以创建一个任何类型新的命令编码器来编码额外的命令进入到命令缓冲区。</p><h3 id="代码例子-绘制一个三角形"><a href="#代码例子-绘制一个三角形" class="headerlink" title="代码例子:绘制一个三角形"></a>代码例子:绘制一个三角形</h3><p>清单5-14阐述的下列步骤描述了一个渲染三角形基本的过程。</p><ol><li>创建一个<a href="https://developer.apple.com/documentation/metal/mtlcommandqueue" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandQueue</font></a>并用它创建一个<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>。</li><li><p>创建一个<font color="Fuchsia">MTLRenderPassDescriptor</font>，它指定了一个附件集合，这些附件作为命令缓冲区中编码的渲染命令的终点。</p><p>在这个例子中，仅仅第一个颜色附件被建立和使用。(变量currentTexture假定包含一个MTLTexture，它被用作一个颜色附件。)然后<font color="Fuchsia">MTLRenderPassDescriptor</font>被用来创建一个新的<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>。</p></li><li><p>创建两个MTLBuffer对象，posBuf和colBuf，调用newBufferWithBytes:length:options:来拷贝顶点坐标和顶点颜色数据，posData和colData，分别进入缓冲区存储。</p></li><li><p>调用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的<font color="DeepSkyBlue">setVertexBuffer:offset:atIndex:</font>方法两次去指定坐标和颜色。</p><p><font color="DeepSkyBlue">setVertexBuffer:offset:atIndex:</font>方法的输入值atIndex对应顶点函数源码中的属性buffer(atIndex)。</p></li><li><p>创建一个<font color="Fuchsia">MTLRenderPipelineDescriptor</font>并确定在管线描述符中的顶点和片元函数:</p><ul><li>用来自progSrc的源码创建一个<font color="Fuchsia">MTLLibrary</font>，它被假定为一个字符串，该字符串包含Metal着色器源码。</li><li>然后调用<font color="Fuchsia">MTLLibrary</font>的newFunctionWithName:方法来创建<font color="Fuchsia">MTLFunction</font> verFunc表示hello_vertex的函数，创建<font color="Fuchsia">MTLFunction</font> fragFunc表示hello_fragment的函数。</li><li>最终，用这些<font color="Fuchsia">MTLFunction</font>对象设置<font color="Fuchsia">MTLRenderPipelineDescriptor</font>的vertexFunction和fragmentFunction属性。</li></ul></li><li><p>通过调用newRenderPipelineStateWithDescriptor:error:或<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>的一个相似方法从<font color="Fuchsia">MTLRenderPipelineDescriptor</font>创建一个MTLRenderPipelineState。然后使用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的setRenderPipelineState:方法创建渲染管线状态。</p></li><li>调用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的drawPrimitives:vertexStart:vertexCount:方法追加命令去执行一个填充三角形(MTLPrimitvieTypeTriangle类型)的渲染。</li><li>调用<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>方法来结束这个渲染过程的编码。调用<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443003-commit" target="_blank" rel="noopener">commit</a></font>方法来执行设备上的命令。</li></ol><p>清单5-14 绘制三角形的Metal代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">id MTLDevice device = MTLCreateSystemDefaultDevice();</span><br><span class="line"> </span><br><span class="line">id MTLCommandQueue commandQueue = [device newCommandQueue];</span><br><span class="line">id MTLCommandBuffer commandBuffer = [commandQueue commandBuffer];</span><br><span class="line"> </span><br><span class="line">MTLRenderPassDescriptor *renderPassDesc</span><br><span class="line">                               = [MTLRenderPassDescriptor renderPassDescriptor];</span><br><span class="line">renderPassDesc.colorAttachments[0].texture = currentTexture;</span><br><span class="line">renderPassDesc.colorAttachments[0].loadAction = MTLLoadActionClear;</span><br><span class="line">renderPassDesc.colorAttachments[0].clearColor = MTLClearColorMake(0.0,1.0,1.0,1.0);</span><br><span class="line">id &lt;MTLRenderCommandEncoder&gt; renderEncoder =</span><br><span class="line">           [commandBuffer renderCommandEncoderWithDescriptor:renderPassDesc];</span><br><span class="line"> </span><br><span class="line">static const float posData[] = &#123;</span><br><span class="line">        0.0f, 0.33f, 0.0f, 1.f,</span><br><span class="line">        -0.33f, -0.33f, 0.0f, 1.f,</span><br><span class="line">        0.33f, -0.33f, 0.0f, 1.f,</span><br><span class="line">&#125;;</span><br><span class="line">static const float colData[] = &#123;</span><br><span class="line">        1.f, 0.f, 0.f, 1.f,</span><br><span class="line">        0.f, 1.f, 0.f, 1.f,</span><br><span class="line">        0.f, 0.f, 1.f, 1.f,</span><br><span class="line">&#125;;</span><br><span class="line">id &lt;MTLBuffer&gt; posBuf = [device newBufferWithBytes:posData</span><br><span class="line">        length:sizeof(posData) options:nil];</span><br><span class="line">id &lt;MTLBuffer&gt; colBuf = [device newBufferWithBytes:colData</span><br><span class="line">        length:sizeof(colData) options:nil];</span><br><span class="line">[renderEncoder setVertexBuffer:posBuf offset:0 atIndex:0];</span><br><span class="line">[renderEncoder setVertexBuffer:colBuf offset:0 atIndex:1];</span><br><span class="line"> </span><br><span class="line">NSError *errors;</span><br><span class="line">id &lt;MTLLibrary&gt; library = [device newLibraryWithSource:progSrc options:nil</span><br><span class="line">                           error:&amp;errors];</span><br><span class="line">id &lt;MTLFunction&gt; vertFunc = [library newFunctionWithName:@&quot;hello_vertex&quot;];</span><br><span class="line">id &lt;MTLFunction&gt; fragFunc = [library newFunctionWithName:@&quot;hello_fragment&quot;];</span><br><span class="line">MTLRenderPipelineDescriptor *renderPipelineDesc</span><br><span class="line">                                   = [[MTLRenderPipelineDescriptor alloc] init];</span><br><span class="line">renderPipelineDesc.vertexFunction = vertFunc;</span><br><span class="line">renderPipelineDesc.fragmentFunction = fragFunc;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].pixelFormat = currentTexture.pixelFormat;</span><br><span class="line">id &lt;MTLRenderPipelineState&gt; pipeline = [device</span><br><span class="line">             newRenderPipelineStateWithDescriptor:renderPipelineDesc error:&amp;errors];</span><br><span class="line">[renderEncoder setRenderPipelineState:pipeline];</span><br><span class="line">[renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle</span><br><span class="line">               vertexStart:0 vertexCount:3];</span><br><span class="line">[renderEncoder endEncoding];</span><br><span class="line">[commandBuffer commit];</span><br></pre></td></tr></table></figure><p>在清单5-14中，一个<font color="Fuchsia">MTLFunction</font>对象表示叫做hello_vertex的着色器函数。<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的<font color="DeepSkyBlue">setVertexBuffer:offset:atIndex:</font>的方法被用来指定顶点资源(在这个实例中，两个buffer对象)作为参数被传递进hello_vertex中。<font color="DeepSkyBlue">setVertexBuffer:offset:atIndex:</font>方法的输入值atIndex对应顶点函数源码中的属性buffer(atIndex)，如清单5-15所示。</p><p>清单5-15 对应的着色器函数声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vertex VertexOutput hello_vertex(</span><br><span class="line">                    const global float4 *pos_data [[ buffer(0) ]],</span><br><span class="line">                    const global float4 *color_data [[ buffer(1) ]])</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用多线程编码单一渲染通道"><a href="#使用多线程编码单一渲染通道" class="headerlink" title="使用多线程编码单一渲染通道"></a>使用多线程编码单一渲染通道</h3><p>在一些情况下，你应用的性能可能被单一渲染通道编码命令的单CPU工作量限制。然而，尝试避免这个瓶颈通过分离的工作量进入到多个CPU线程进行编码的多个渲染通道也可能会影响性能，因为每个渲染通道需要其本身中间附件存储和保存渲染目标内容的加载动作。</p><p>相反地，使用一个<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>对象，它管理多个附属的<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>对象，这些对象共享相同命令缓冲和渲染通道描述符。并行渲染命令编码器保证附件加载和存储动作只发生在整个渲染通道的开始和结尾，而不是每个附属渲染命令编码器的指令集合的开头和结尾。在这种体系结构下，你可以并行、安全以及高效地方式分配每个<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>对象到它自己的线程。</p><p>使用<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象的paralleleRenderCommandEncoderWithDescriptor:方法创建一个并行渲染命令编码器。从你想去执行命令编码的每个CPU线程调用一次<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>对象的renderCommandEncoder方法创建附属命令编码器。所有来自相同并行渲染命令编码器创建的附属命令编码器进行编码相同命令缓冲的命令。按顺序被编码到命令缓冲区的命令，在该命令中，渲染命令编码器被创建。调用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的<font color="DeepSkyBlue">endEncoding</font>方法来结束指定渲染命令编码。在所有由并行渲染命令编码器创建的渲染命令编码器结束编码以后，调用<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>的<font color="DeepSkyBlue">endEncoding</font>方法去结束渲染过程。</p><p>清单5-16 展示<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>创建三个<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>对象:rCE1，rCE2和rCE3。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MTLRenderPassDescriptor *renderPassDesc </span><br><span class="line">                     = [MTLRenderPassDescriptor renderPassDescriptor];</span><br><span class="line">renderPassDesc.colorAttachments[0].texture = currentTexture;</span><br><span class="line">renderPassDesc.colorAttachments[0].loadAction = MTLLoadActionClear;</span><br><span class="line">renderPassDesc.colorAttachments[0].clearColor = MTLClearColorMake(0.0,0.0,0.0,1.0);</span><br><span class="line"></span><br><span class="line">id &lt;MTLParallelRenderCommandEncoder&gt; parallelRCE = [commandBuffer </span><br><span class="line">                     parallelRenderCommandEncoderWithDescriptor:renderPassDesc];</span><br><span class="line">id &lt;MTLRenderCommandEncoder&gt; rCE1 = [parallelRCE renderCommandEncoder];</span><br><span class="line">id &lt;MTLRenderCommandEncoder&gt; rCE2 = [parallelRCE renderCommandEncoder];</span><br><span class="line">id &lt;MTLRenderCommandEncoder&gt; rCE3 = [parallelRCE renderCommandEncoder];</span><br><span class="line"></span><br><span class="line">//  not shown: rCE1, rCE2, and rCE3 call methods to encode graphics commands</span><br><span class="line">//</span><br><span class="line">//  rCE1 commands are processed first, because it was created first</span><br><span class="line">//  even though rCE2 and rCE3 end earlier than rCE1</span><br><span class="line">[rCE2 endEncoding];</span><br><span class="line">[rCE3 endEncoding];</span><br><span class="line">[rCE1 endEncoding];</span><br><span class="line"></span><br><span class="line">//  all [&lt;font color=Fuchsia&gt;MTLRenderCommandEncoder&lt;/font&gt;](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)s must end before [&lt;font color=Fuchsia&gt;MTLParallelRenderCommandEncoder&lt;/font&gt;](https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder)</span><br><span class="line">[parallelRCE endEncoding];</span><br></pre></td></tr></table></figure><p>命令编码器的调用<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>的顺序与命令被编码和追加进<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>的顺序无关。<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>，<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>总是按附属渲染命令编码器被创建的顺序包含命令，如图表5-6所示。</p><p>图表 5-6 并行渲染通道中渲染命令编码器的排序</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/Parallel-Pass_2x.png" alt=""></p><h2 id="数据并行计算处理-计算命令编码器"><a href="#数据并行计算处理-计算命令编码器" class="headerlink" title="数据并行计算处理:计算命令编码器"></a>数据并行计算处理:计算命令编码器</h2><p>这章解释如何创建和使用一个<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>对象去编码数据并行计算处理状态，命令以及提交他们到设备执行。</p><p>执行一个数据并行计算，主要有下面这些步骤:</p><ol><li>使用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>方法来创建一个计算状态(MTLComputePipelineState)，其包含来自<font color="Fuchsia">MTLFunction</font>对象编译的代码，如创建计算状态中讨论的。<font color="Fuchsia">MTLFunction</font>对象表示Metal着色语言中的编写的一个计算函数，如函数和库中描述的。</li><li>通过计算命令编码器来使用指定的MTLComputePipelineState对象，正如在指定计算状态和计算命令编码器资源中讨论的。</li><li>指定资源和相关对象(MTLBuffer，MTLTexture和可能的MTLSamplerState)可能包含被处理的数据和通过计算状态返回的数据，正如在指定计算状态和计算命令编码器资源中讨论的。也设置他们的参数表指数，以便Metal框架代码可以定位一个在着色器代码中相应的资源。在任何给定时刻，<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>可以被关联到许多资源对象。</li><li>调度指定次数的计算函数，正如执行计算命令中解释的。</li></ol><h3 id="创建计算管线状态"><a href="#创建计算管线状态" class="headerlink" title="创建计算管线状态"></a>创建计算管线状态</h3><font color="Fuchsia">MTLFunction</font>对象表示数据并行代码可以通过MTLComputePipelineState对象被执行。[<font color="Fuchsia">MTLComputeCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlcomputecommandencoder)对象编码命令，这些命令设置参数和执行计算功能。因为创建一个计算管线状态可能需要一个Metal着色语言代码的昂贵的编译，你可以使用一种最适合你应用设计的块或者异步方法来安排这样的工作。* 同步创建计算管线状态对象，调用[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)的<font color="DeepSkyBlue">newComputePipelineStateWithFunction:error:</font>或<font color="DeepSkyBlue">newComputePipelineStateWithFunction:options:reflection:error:</font>方法。当Metal编译着色器代码来创建管线状态对象时这些方法阻塞了当前线程。* 异步创建计算管线状态对象，调用[<font color="Fuchsia">MTLDevice</font>](https://developer.apple.com/documentation/metal/mtldevice)的<font color="DeepSkyBlue">newComputePipelineStateWithFunction:completionHandler:</font>或<font color="DeepSkyBlue">newComputePipelineStateWithFunction:options:completionHandler:</font>方法。这些方法立即返回---Metal异步编译着色器代码来创建管线状态对象，然后调用完成回调去提供新的MTLComputePipelineState对象。当你创建一个MTLComputePipelineState对象时，你也可以选择去创建反射数据，这些数据揭示了计算函数的细节及其参数。<font color="DeepSkyBlue">newComputePipelineStateWithFunction:options:reflection:error:</font>和<font color="DeepSkyBlue">newComputePipelineStateWithFunction:options:completionHandler:</font>方法提供了这个数据。避免获取反射数据如果它不被使用。更多关于如何分析反射数据的信息，参见决定运行时函数细节。### 指定计算状态和计算命令编码器的资源[<font color="Fuchsia">MTLComputeCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlcomputecommandencoder)对象的setComputePipelineState:方法指定其状态，包括一个编译的计算渲染函数，使用数据并行计算通道。在任何给定时刻，计算命令编码器可以被关联到仅有的一个计算函数。下列[<font color="Fuchsia">MTLComputeCommandEncoder</font>](https://developer.apple.com/documentation/metal/mtlcomputecommandencoder)方法指定资源(就是说，缓冲，纹理，采样器状态或线程组内存)作为通过MTLComputePipelineState对象表现的计算函数的一个参数。* <font color="DeepSkyBlue">setBuffer:offset:atIndex:</font>* <font color="DeepSkyBlue">setBuffers:offsets:withRange:</font>* <font color="DeepSkyBlue">setTexture:atIndex:</font>* <font color="DeepSkyBlue">setTextures:withRange:</font>* <font color="DeepSkyBlue">setSamplerState:atIndex:</font>* <font color="DeepSkyBlue">setSamplerState:lodMinClamp:lodMaxClamp:atIndex:</font>* <font color="DeepSkyBlue">setSamplerStates:withRange:</font>* <font color="DeepSkyBlue">setSamplerStates:lodMinClamps:lodMaxClamps:withRange:</font>* <font color="DeepSkyBlue">setThreadgroupMemoryLength:atIndex:</font><p>每个方法分配一个或多个资源到对应的参数，如图表6-1所示。</p><p>图标 6-1 计算命令编码器的参数表</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/ArgTable-compute_2x.png" alt="img-w400"></p><p>缓冲、纹理或采样状态参数表的最大条目数的限制被列在实现限制表中。</p><p>整个线程组内存分配的最大限制也被列在实现限制表中。</p><h3 id="执行计算命令"><a href="#执行计算命令" class="headerlink" title="执行计算命令"></a>执行计算命令</h3><p>编码一个执行计算函数的命令，调用<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>的dispatchThreadgroups:threadsPerThreadgroup:方法并指定线程组尺寸和线程组的数量。你可以查询MTLComputePipelineState的threadExecutionWidth和maxTotalThreadPerThreadgroup属性来优化设备计算函数的执行。</p><p>在线程组中的线程总数是threadsPerThreadgroup: threadsPerThreadgroup.width <em> threadsPerThreadgroup.height </em> threadsPerThreadgroup.depth组件的乘积。maxTotalThreadsPerThreadgroup属性指定线程最大数量，它可能是一个单一的线程组去在设备上执行这个计算函数。</p><p>调用<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>方法结束计算命令编码器的编码命令。结束以前命令编码器以后，你可以创建一个任意类型的新的命令编码器来编码额外的命令进入到命令缓冲区。</p><h3 id="代码样例-执行数据并行函数"><a href="#代码样例-执行数据并行函数" class="headerlink" title="代码样例:执行数据并行函数"></a>代码样例:执行数据并行函数</h3><p>清单6-1显示了一个样例，这个样例创建和使用<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>对象来执行一个指定数据图像变换的并行计算。(这个例子未展示设备，库，命令队列和资源对象被创建和初始化。)样例创建一个命令缓冲区，然后使用它来创建<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>对象。接下来<font color="Fuchsia">MTLFunction</font>对象被创建，其表示从<font color="Fuchsia">MTLLibrary</font>对象加载的入口点filter_main，如清单6-2所示。函数对象被用来创建一个被叫做filterState的MTLComputePipelineState对象。</p><p>计算函数在图像inputImage上执行一个图像变换和过滤操作，使用outputImage返回结果。首先<font color="DeepSkyBlue">setTexture:atIndex:</font>和<font color="DeepSkyBlue">setBuffer:offset:atIndex:</font>方法分配纹理和缓冲对象到指定参数表的指数。paramsBuffer指定值用来执行图像变换，inputTableData指定滤镜权重。计算函数被执行作为一个各个尺寸的16×16像素大小的2D线程组。<font color="DeepSkyBlue">dispatchThreadgroups:threadsPerThreadgroup:</font>方法排队命令来调度线程执行计算函数，<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>方法终止<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>。最终，<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443003-commit" target="_blank" rel="noopener">commit</a></font>方法引起了尽快地去执行命令。</p><p>清单6-1 在计算状态指定和运行一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">id &lt;MTLDevice&gt; device;</span><br><span class="line">id &lt;MTLLibrary&gt; library;</span><br><span class="line">id &lt;MTLCommandQueue&gt; commandQueue;</span><br><span class="line"> </span><br><span class="line">id &lt;MTLTexture&gt; inputImage;</span><br><span class="line">id &lt;MTLTexture&gt; outputImage;</span><br><span class="line">id &lt;MTLTexture&gt; inputTableData;</span><br><span class="line">id &lt;MTLBuffer&gt; paramsBuffer;</span><br><span class="line"> </span><br><span class="line">// ... Create and initialize device, library, queue, resources</span><br><span class="line"> </span><br><span class="line">// Obtain a new command buffer</span><br><span class="line">id &lt;MTLCommandBuffer&gt; commandBuffer = [commandQueue commandBuffer];</span><br><span class="line"> </span><br><span class="line">// Create a compute command encoder</span><br><span class="line">id &lt;MTLComputeCommandEncoder&gt; computeCE = [commandBuffer computeCommandEncoder];</span><br><span class="line"> </span><br><span class="line">NSError *errors;</span><br><span class="line">id &lt;MTLFunction&gt; func = [library newFunctionWithName:@&quot;filter_main&quot;];</span><br><span class="line">id &lt;MTLComputePipelineState&gt; filterState</span><br><span class="line">              = [device newComputePipelineStateWithFunction:func error:&amp;errors];</span><br><span class="line">[computeCE setComputePipelineState:filterState];</span><br><span class="line">[computeCE setTexture:inputImage atIndex:0];</span><br><span class="line">[computeCE setTexture:outputImage atIndex:1];</span><br><span class="line">[computeCE setTexture:inputTableData atIndex:2];</span><br><span class="line">[computeCE setBuffer:paramsBuffer offset:0 atIndex:0];</span><br><span class="line"> </span><br><span class="line">MTLSize threadsPerGroup = &#123;16, 16, 1&#125;;</span><br><span class="line">MTLSize numThreadgroups = &#123;inputImage.width/threadsPerGroup.width,</span><br><span class="line">                           inputImage.height/threadsPerGroup.height, 1&#125;;</span><br><span class="line"> </span><br><span class="line">[computeCE dispatchThreadgroups:numThreadgroups</span><br><span class="line">                                threadsPerThreadgroup:threadsPerGroup];</span><br><span class="line">[computeCE endEncoding];</span><br><span class="line"> </span><br><span class="line">// Commit the command buffer</span><br><span class="line">[commandBuffer commit];</span><br></pre></td></tr></table></figure><p>清单6-2 显示了前面样例的相应着色器代码。(read_and_transform和filter_table函数是用户定义代码的占位符)。</p><p>清单6-2 着色语言计算函数声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kernel void filter_main(</span><br><span class="line">  texture2d&lt;float,access::read&gt;   inputImage   [[ texture(0) ]],</span><br><span class="line">  texture2d&lt;float,access::write&gt;  outputImage  [[ texture(1) ]],</span><br><span class="line">  uint2 gid                                    [[ thread_position_in_grid ]],</span><br><span class="line">  texture2d&lt;float,access::sample&gt; table        [[ texture(2) ]],</span><br><span class="line">  constant Parameters* params                  [[ buffer(0) ]]</span><br><span class="line">  )</span><br><span class="line">&#123;</span><br><span class="line">  float2 p0          = static_cast&lt;float2&gt;(gid);</span><br><span class="line">  float3x3 transform = params-&gt;transform;</span><br><span class="line">  float4   dims      = params-&gt;dims;</span><br><span class="line">  </span><br><span class="line">  float4 v0 = read_and_transform(inputImage, p0, transform);</span><br><span class="line">  float4 v1 = filter_table(v0,table, dims);</span><br><span class="line">  </span><br><span class="line">  outputImage.write(v1,gid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓冲和纹理操作-位块传送命令编码器"><a href="#缓冲和纹理操作-位块传送命令编码器" class="headerlink" title="缓冲和纹理操作:位块传送命令编码器"></a>缓冲和纹理操作:位块传送命令编码器</h2><p><a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>提供了在资源(缓冲和纹理)之间拷贝数据方法。数据拷贝操作对于图像处理和纹理效果可能是必要的，例如迷糊或反射。他们可能被用来访问被离屏渲染的图像数据。</p><p>执行数据拷贝操作，首先通过调用<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象的<font color="DeepSkyBlue">blitCommandEncoder</font>方法创建一个<a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>对象。然后调用下面描述的编码指定到命令缓冲区的<a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>的方法。</p><h3 id="在资源对象之间的GPU内存拷贝数据"><a href="#在资源对象之间的GPU内存拷贝数据" class="headerlink" title="在资源对象之间的GPU内存拷贝数据"></a>在资源对象之间的GPU内存拷贝数据</h3><p>下列<a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>方法在资源对象之间拷贝图像数据:两个缓冲对象之间，两个纹理对象之间，一个缓冲和一个纹理之间。</p><h4 id="两个缓冲之间的拷贝数据"><a href="#两个缓冲之间的拷贝数据" class="headerlink" title="两个缓冲之间的拷贝数据"></a>两个缓冲之间的拷贝数据</h4><p><font color="DeepSkyBlue">copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:</font>方法在两个缓冲之间拷贝数据:从源缓冲到目标缓冲toBuffer。如果源和目标是相同的缓冲，被拷贝重叠的范围，结果是未定义的。</p><h4 id="缓冲到纹理的拷贝数据"><a href="#缓冲到纹理的拷贝数据" class="headerlink" title="缓冲到纹理的拷贝数据"></a>缓冲到纹理的拷贝数据</h4><p><font color="DeepSkyBlue">copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:</font>方法从源缓冲到目标纹理toTexture拷贝图像数据。</p><h4 id="两个纹理之间的拷贝数据"><a href="#两个纹理之间的拷贝数据" class="headerlink" title="两个纹理之间的拷贝数据"></a>两个纹理之间的拷贝数据</h4><p><font color="DeepSkyBlue">copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:</font>方法拷贝两个纹理图像数据范围:从单一立方体切片和源纹理映射级别到纹理终点toTexture。</p><h4 id="纹理到缓冲的数据拷贝"><a href="#纹理到缓冲的数据拷贝" class="headerlink" title="纹理到缓冲的数据拷贝"></a>纹理到缓冲的数据拷贝</h4><p><font color="DeepSkyBlue">copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:</font>方法拷贝图像数据范围从单一立方体切片和源纹理映射级别到缓冲终点toBuffer。</p><h3 id="产生纹理映射"><a href="#产生纹理映射" class="headerlink" title="产生纹理映射"></a>产生纹理映射</h3><p><a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>的generateMipmapsForTexture:方法对于给定纹理自动产生纹理映射，从基本层次纹理图像开始。<font color="DeepSkyBlue">generateMipmapsForTexture:</font>创建所有纹理映射级别到达最高级别的缩放图像。</p><h3 id="填充缓冲内容"><a href="#填充缓冲内容" class="headerlink" title="填充缓冲内容"></a>填充缓冲内容</h3><p><a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>的<font color="DeepSkyBlue">fillBuffer:range:value:</font>方法在给定缓冲指定的range上每个字节存储8位常量。</p><h3 id="结束位块传送命令编码器"><a href="#结束位块传送命令编码器" class="headerlink" title="结束位块传送命令编码器"></a>结束位块传送命令编码器</h3><p>调用<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>来结束位块传送命令编码器的命令编码。在结束前一个命令编码器后，你可以创建一个任意类型的新的命令编码器来编码额外命令进入命令缓冲区。</p><h2 id="Metal工具"><a href="#Metal工具" class="headerlink" title="Metal工具"></a>Metal工具</h2><p>这章列出了可用的工具来帮助你自定义和改善你开发的工作流。</p><h3 id="在应用构建过程期间创建库"><a href="#在应用构建过程期间创建库" class="headerlink" title="在应用构建过程期间创建库"></a>在应用构建过程期间创建库</h3><p>在应用构建过程期间编译着色语言源文件和构建库(.metallib文件)比运行时编译着色器源码能实现更好的应用性能。你可以用Xcode构建一个库或者通过使用命令行工具。</p><h4 id="使用Xcode构建一个库"><a href="#使用Xcode构建一个库" class="headerlink" title="使用Xcode构建一个库"></a>使用Xcode构建一个库</h4><p>任何在你工程中的着色器源文件自动被使用去产生默认的库，你可以用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>的<font color="DeepSkyBlue">newDefaultLibrary</font>方法从Metal框架代码存取。</p><h4 id="使用命令行工具去构建一个库"><a href="#使用命令行工具去构建一个库" class="headerlink" title="使用命令行工具去构建一个库"></a>使用命令行工具去构建一个库</h4><p>图表8-1展示了产生Metal着色器源码编译器工具链的命令行工具。当你工程中包含.metal文件时，Xcode调用这些工具来构建一个库文件，这个文件你可以在应用运行时存取。</p><p>不使用Xcode编译着色器源码进入一个库:</p><ol><li>使用metal工具来编译每个.metal文件进入单独的.air文件，它存储了着色语言代码的中间表示(IR)。</li><li>可选择地，使用metal-ar工具来把若干个.air文件归档到一起成为一个.metalar文件。(metal-ar和Unix ar类似。)</li><li>使用metallib工具来构建一个Metal的.metallib库文件从IR .air文件或从归档的.metalar文件。</li></ol><p>图表 8-1 使用命令行工具构建一个库文件</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/library_2x.png" alt="img-w600"></p><p>清单8-1 展示了编译和构建一个.metal文件成为一个.metallib文件需要的最少命令行。</p><p>清单8-1 用命令行工具构建一个库文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk macosx metal MyLibrary.metal -o MyLibrary.air</span><br><span class="line">xcrun -sdk macosx metallib MyLibrary.air -o MyLibrary.metallib</span><br></pre></td></tr></table></figure><p>在框架代码中使用结果库，调用<font color="DeepSkyBlue">newLibraryWithFile:error:</font>方法，如清单8-2所示。</p><p>清单8-2 在你的应用中使用一个库文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSError *libraryError = NULL;</span><br><span class="line">NSString *libraryFile = [[NSBundle mainBundle] pathForResource:@&quot;MyLibrary&quot; ofType:@&quot;metallib&quot;];</span><br><span class="line">id &lt;&lt;font color=Fuchsia&gt;MTLLibrary&lt;/font&gt;&gt; myLibrary = [_device newLibraryWithFile:libraryFile error:&amp;libraryError];</span><br><span class="line">if (!myLibrary) &#123;</span><br><span class="line">    NSLog(@&quot;Library error: %@&quot;, libraryError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></=></=>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;[Metal基础概念] 简明的描述Metal的主要特性。&lt;/li&gt;
&lt;li&gt;[命令组成和执行模型] 解释如何创建和提交命令到GPU执行。&lt;/li&gt;
&lt;li&gt;[资源对象:缓冲和纹理] 讨论设备内存管理，包括表现GPU内存分配的缓冲和纹理对象。&lt;/li&gt;
&lt;li&gt;[函数和库] 描述Metal着色语言代码如何被呈现在一个Metal应用中，Metal着色语言代码在GPU上如何被加载和执行的。&lt;/li&gt;
&lt;li&gt;[图像渲染:渲染命令编码器] 描述如何渲染3D图像，包括如何穿过多个线程来分配图形操作。&lt;/li&gt;
&lt;li&gt;[数据并行计算处理:计算命令编码器] 阐述如何执行数据并行处理。&lt;/li&gt;
&lt;li&gt;[缓冲和纹理操作:位命令编码器] 描述如何在纹理和缓冲之间拷贝数据。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Metal" scheme="https://zhaolilong.com/tags/Metal/"/>
    
      <category term="图形学" scheme="https://zhaolilong.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>理解ARKit</title>
    <link href="https://zhaolilong.com/2018/06/03/%E7%90%86%E8%A7%A3ARKit/"/>
    <id>https://zhaolilong.com/2018/06/03/理解ARKit/</id>
    <published>2018-06-03T05:46:41.000Z</published>
    <updated>2018-11-21T23:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>近些年最流行的手游之一是Pokemon Go(精灵宝可梦Go), 它展示通过iPhone相机查看覆盖在真实地点的宝可梦角色。将iPhone摄像头对准公园长椅或灌木丛，你可以看到一个宝可梦卡通角色，好像它真的在那。</p><p>这种在实际物理对象上显示虚拟对象的技术被称为增强现实（AR）。增强现实背后的想法是让您将真实世界的物体与出现在iPhone屏幕上的虚拟物体相结合。</p><a id="more"></a><p>增强现实的一个用途是将iPhone指向街道，以便您可以看到周边地区的街道名称和企业名称。另一个用途是向您展示带箭头的步行路线，向您展示如何在大型公共场所（如机场航站楼或博物馆）进行导航。</p><p>以前，创建增强现实应用需要编写数学方程式来跟踪真实世界物体和虚拟物体在真实世界中的位置。幸运地，苹果已经通过一个新的叫做ARKit的软件框架使得增强现实更简单地去创建。通过使用ARKit和其他框架，例如SceneKit，你可以简单快捷地创建增强现实应用。</p><blockquote><p><strong>注意</strong> 你仅可以测试和运行ARKit应用在iPhone6s或者更高，或者一台iPad Pro上。</p></blockquote><h2 id="ARKit如何工作"><a href="#ARKit如何工作" class="headerlink" title="ARKit如何工作"></a>ARKit如何工作</h2><p>在最简单的层面上，ARKit通过识别称为特征点的周围区域来工作。一旦ARKit了解iOS设备摄像头查看的物理对象，它就可以将虚拟对象叠加在摄像头显示的实际图像的顶部。</p><p>查看实例中的ARKit示例，创建一个新的iOS项目。但是，请确保您单击了增强现实应用程序项目，如图1所示。然后点击下一步。</p><p><img src="https://i.loli.net/2018/06/10/5b1cc34f55d74.jpg" alt=""></p><p><strong>图 1</strong> 增强现实应用模板</p><p>当Xcode对于你的项目要求一个产品名称，输入ARTest。确保Content Technology弹出菜单显示SceneKit。（Content Technology的其他两个选项是Metal和SpriteKit。SpriteKit为2D图像而设计，然而Metal专为喜欢创建自己的代码来创建图形的高级用户而设计。在大多数情况下，你将使用SceneKit来显示3D图像。）</p><p>当你点击Finish按钮时，Xcode创建了一个标准的iOS项目，它包含一个AppDelegate.swift文件，一个ViewController.swift文件，和一个Main.storyboard用户界面文件。</p><p>点击ViewController.swift文件，你将看到已经为你编写好创建增强现实应用的代码。注意ViewController.swift包含三个重要的语句：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br></pre></td></tr></table></figure><p>UIKit创建一个iOS应用。使用SceneKit可以显示三维物体。ARKit可让您将增强现实添加到您的应用中。</p><p>接下来，注意ViewController累采用ARSCNViewDelegate：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>该协议允许您将SceneKit图像显示为覆盖真实世界对象的增强现实对象。然后，注意ViewController.swift文件已经包含一个单独的名为sceneView的IBOutlet：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">var</span> sceneView : <span class="type">ARSCNView</span></span><br></pre></td></tr></table></figure><p>如果你点击了Main.storyboard文件，你会看到一个ARKit SceneKit View已经在用户界面中，如图2所示。此ARSCNView在相机背景上显示3D SceneKit图像。</p><p><img src="https://i.loli.net/2018/06/10/5b1cc84dc3ca5.jpg" alt=""></p><p><strong>图 2</strong> 一个ARKit SceneKit View已经出现在用户界面上</p><p>在ViewController.swift文件中，请查看viewWillAppear函数，您将看到两行代码可帮助在应用程序中创建增强现实。第一行代码创建了一个叫做configuration的常量，它代表一个ARWorldTrackingConfiguration对象。该对象跟踪iOS设备的方向和位置，以及检测真实世界的表面。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingConfiguration</span>()</span><br></pre></td></tr></table></figure><p>第二行实际显示叠加在相机显示的视图上的增强现实图像：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneView.session.run(configuration)</span><br></pre></td></tr></table></figure><p>现在来看ViewController.swift文件中的viewDidLoad方法。首先，在ViewController.swift文件中有一行定义了其delegate（代理）。其次，有一行显示了在屏幕底部的每秒帧数（fps）和时间数据。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneView.showStatistics = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果你看Navigator面板，你将会看到art.scnassets文件夹。如果你展开这个文件夹，你将会看到它包含了两个文件：ship.scn和texture.png。ship.scn文件包含了一个三维的对象，你可以通过修改来改变其外观。texture。png文件包含了出现在ship.scn模型中的图像，如图3.</p><p><img src="https://i.loli.net/2018/06/10/5b1ccb2f458d4.jpg" alt=""></p><p><strong>图 3</strong> 查看Xcode中的ship.scn文件</p><blockquote><p><strong>注意</strong> .scn文件代表了一个SceneKit文件格式。大多数3D数字图像程序可以保存文件为一个.dae（数字资产交换）文件格式。如果你添加一个.dae文件到Xcode中，你可以转换它成为一个.scn文件格式，通过添加一个.dae文件到Navigator面板，然后选择File ➤ Export，保存文件为一个.scn文件。如果你想创建.dae文件，你可以使用免费，开源的Blender程序（<a href="">www.blender.org</a>）。你也同样可以在互联网上找到免费的公共域的.dae文件。</p></blockquote><p>虚拟对象由一个模型（在这种情况下，ship.scn文件）和一个纹理（texture.png）组成，并应用于该模型。如果你点击texture.png文件，你将看到出现在ship.scn文件中的颜色和图像。</p><p>点击ship.scn文件，点击Xcode窗口中的飞机图像。点击Show the Materials Inspector图标（或者选择View ➤ Utilities ➤ Show the Materials Inspector)。这将显示“材质检查器”窗格，该窗格允许您修改模型的外观。</p><p>在Properties中点击Diffuse弹出菜单，你可以看到texture.png被选择如果4所示。点击黑或者白来移除纹理，以便于你可以看到如何从模型中移除texture.png文件来改变ship.scn文件的外观。</p><p><img src="https://i.loli.net/2018/06/10/5b1cce952bed5.jpg" alt=""></p><p><strong>图 4</strong> “漫反射“弹出菜单定义ship.scn文件的外观</p><p>确保Diffuse弹出菜单再次先吃了texture.png.通过USB线连接一台iOS设备到你的Mac电脑并将您的iOS设备相机指向任何地方。ship.scn文件的虚拟镜像现在应该出现在摄像机查看的真实世界对象上，如图5所示。</p><p><img src="https://i.loli.net/2018/06/10/5b1d081d2fb1b.jpg" alt=""></p><p><strong>图5</strong> 在iPhone上运行ARTest项目</p><p>当你四处移动iOS设备时，你应当看到了ship.scn的不同角度图像好像它是你面前的一个真实物体一样。注意屏幕底部显示的关于增强显示图像的统计，比如它的帧率（fps）。</p><p>回到Xcode，选择Product ➤ Stop或者点击停止图标来停止运行中的ARTest项目。在此刻，你已经看到了增强现实如何工作的一个简单的演示。通过添加不同纹理文件或者使用不同的图片替换ship.scn文件，你可以显示通过iOS设备摄像头看到的自定义图像。</p><p>返回并且编辑ViewController.swift文件。首先，注释掉定义ship.scn文件的两行，然后加载该场景：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let scene = SCNScene(named: "art.scnassets/ship.scn")!</span></span><br><span class="line"><span class="comment">// sceneView.scene = scene</span></span><br></pre></td></tr></table></figure><p>现在添加下面的行来显示覆盖在相机图像上的特征点和世界原点：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneView.debugOptions = [<span class="type">ARSCNDebugOpitions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br></pre></td></tr></table></figure><p>特征点显示为突出显示ARKit识别的表面区域的黄色点。世界原点显示为x轴，y轴，z轴，其中x轴向右，y轴向上，并且z轴指向用户的屏幕外。</p><blockquote><p><strong>注意</strong> ARKit在清晰的照明条件下工作得最好，多个物体可见，因此它可以检测桌子，地板和墙壁的表面区域。较差的照明条件会阻碍ARKit识别表面区域并将摄像机指向空白墙壁或地板的能力。</p></blockquote><p>你的整个viewDidLoad方法应该看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置视图的代理</span></span><br><span class="line">    sceneView.<span class="type">Delegate</span> = <span class="keyword">self</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示统计例如fps和时间信息</span></span><br><span class="line">    sceneView.showStatistics = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个新的场景</span></span><br><span class="line">    <span class="comment">// let scene = SCNScene(named:"art.scnassets/ship.scn")!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置视图的场景</span></span><br><span class="line">    <span class="comment">// sceneView.scene = scen</span></span><br><span class="line">    </span><br><span class="line">    sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你运行这个ARTest项目的修改版本时，你将在附近区域看到原点显示以及黄点，表示特征点，如图6所示。</p><p><img src="https://i.loli.net/2018/06/10/5b1d0c2c95bcb.jpg" alt=""></p><p><strong>图 6</strong> debugOptions行显示原点和特征点</p><h2 id="绘制增强现实物体"><a href="#绘制增强现实物体" class="headerlink" title="绘制增强现实物体"></a>绘制增强现实物体</h2><p>通过用你自己的图像替换ship.scn文件，你可以显示任何你想作为一个增强现实的物体。然而，你也可以现实简单的几何体。一些你可以绘制的可用模型包括：</p><ul><li>SCNBox - 绘制一个盒子</li><li>SCNCapsule - 绘制一个圆柱体，其两端用半球盖住</li><li>SCNCone - 绘制一个圆锥体</li><li>SCNCylinder - 绘制一个圆柱体</li><li>SCNFloor - 绘制一个可以选择反映场景的无限平面</li><li>SCNPlane - 绘制一个指定宽高的矩形平面</li><li>SCNPyramid - 绘制一个角锥体</li><li>SCNSphere - 绘制一个球体</li><li>SCNTorus - 绘制一个圆环状的物体</li><li>SCNTube - 沿其中心轴绘制一个带有孔的圆柱体<br>显示几何模型时，您需要定义三个特征：</li><li>物体的物理尺寸例如宽高</li><li>物体的外观例如颜色</li><li>物体相对于世界原点的位置</li></ul><p>一旦你定义一个物体的大小，外观，和位置，您需要将其放置在相机显示的视图上。为了做到这点，你需要去定义一个节点。要查看它是如何工作的，我们需要将以下代码添加到ViewController.swift文件中现有的viewDidLoad函数中：</p><p>在sceneView.debugOptions行的下面，添加以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">node.geometry = <span class="type">SCNPyramid</span>(width: <span class="number">0.1</span>, height: <span class="number">0.2</span>, length: <span class="number">0.1</span>)</span><br><span class="line">node.geometry?.firstMaterial?.diffuse.contents = <span class="type">UIColor</span>.cyan</span><br><span class="line">node.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, -<span class="number">0.2</span>, <span class="number">0</span>)</span><br><span class="line">sceneView.scene.rootNode.addChildNode(node)</span><br></pre></td></tr></table></figure><p>第一行创建一个节点，它定义几何模型将会出现在哪里。<br>第二行定义了一个有宽，高和长的角锥体。<br>第三行定义了模型的颜色，它是青色。<br>第四行定义了角锥体相对于世界原点的位置。在这种情况下，金字塔底部出现在原点下面-0.2处。<br>第五行将节点添加到场景中，以便青色金字塔直接出现在世界原点的下方如图7所示。</p><p><img src="https://i.loli.net/2018/06/10/5b1d10f979470.jpg" alt=""></p><p><strong>图7</strong> 显示一个角锥体作为增强现实物体</p><p>通过更改node.position的值以及角锥体的宽度，高度和长度来进行实验。还要将其颜色从青色更改为红色或黄色。选择不同的模型，如SCNBox，SCNTub或SCNCone，而不是显示角锥体，</p><h2 id="重置世界原点"><a href="#重置世界原点" class="headerlink" title="重置世界原点"></a>重置世界原点</h2><p>我们创建ARTest项目使用增强现实应用模板，但是我们可以通过添加ARKit和SceneKit框架轻松地为任何项目提供增强现实功能。创建一个新的项目并创建一个新的单视图应用。给它一个ARRest的名字。</p><p>当你第一次运行任何AR应用时，它会在您的iPhone或iPad的当前位置定义世界原点。如果稍后退出，您会看到屏幕上显示的原点（请参见图6）。不幸地，世界原点将仍然固定直到你再次运行应用。</p><p>为了修复这个问题，你将创建的下一个项目将显示一个重置按钮，该按钮可让你将iPhone / iPad移动到新位置并在新位置重新定义原点。这样，你可以重新定义世界原点位置，而无需重新启动应用程序。</p><p>点击ViewController.swift文件并添加SceneKit和ARKit框架像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br></pre></td></tr></table></figure><p>像这样采用ARSCNViewDelegate修改ViewController类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>点击Info.plist文件并添加一个Privacy – Camera Usage Description的键。如果你没有做到这一点，您的应用将无法访问相机，并且无法运行。</p><p>点击Main.storyboard文件并添加一个ARKit SceneKit View到用户界面如图8所示。</p><p><img src="https://i.loli.net/2018/06/10/5b1d3ef4a9b00.jpg" alt=""></p><p><strong>图 8</strong> ARKit SceneKit View现实增强现实物体</p><p>将UIButton拖放到ARKit SceneKit下面的屏幕底部查看以便延伸视图的宽度。给这个按钮一个“复位”的标题，如图9所示。然后选择Editor ➤ Resolve Auto Layout Issue ➤ Reset to Suggested Constraints。</p><p><img src="https://i.loli.net/2018/06/10/5b1d3faa7c584.jpg" alt=""></p><p><strong>图 9</strong> 在用户界面上放置一个UIButton</p><p>打开Assistant Editor并按住Control从ARSCNView拖拽到创建的名为sceneView的IBOutlet:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">var</span> sceneView : <span class="type">ARSCNView</span>!</span><br></pre></td></tr></table></figure><p>现在，从UIButton拖动Control来创建一个名为resetAR的IBAction方法，并添加如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">resetAR</span><span class="params">(<span class="number">_</span> sender : UIButton)</span></span> &#123;</span><br><span class="line">    sceneView.session.pause()</span><br><span class="line">    sceneView.session.run(configuration, options : [.resetTracking, .removeExistingAnchors])</span><br></pre></td></tr></table></figure><p>整个ViewController.swift文件应当看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> sceneView: <span class="type">ARSCNView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个session配置</span></span><br><span class="line">    <span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingConfiguration</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        sceneView.delegate = <span class="keyword">self</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 显示统计例如fps和时间信息</span></span><br><span class="line">        sceneView.showsStatistics = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 显示原点和特征点</span></span><br><span class="line">        sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//运行视图的会话</span></span><br><span class="line">        sceneView.session.run(configuration)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillDisappear(animated)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 暂停视图的会话</span></span><br><span class="line">        sceneView.session.pause()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">resetAR</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">        sceneView.session.pause()</span><br><span class="line">        sceneView.session.run(configuration, options: [.resetTracking, .removeExistingAnchors])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你运行这个应用时，稍后退一步，你会看到世界的起源显示在你面前。移至新位置并点击重置按钮，然后向后退出。 您现在应该看到在新位置定义的世界原点。</p><h2 id="绘制自定义模型"><a href="#绘制自定义模型" class="headerlink" title="绘制自定义模型"></a>绘制自定义模型</h2><p>ARKit提供了可以创建的常见几何模型，例如圆柱体，锥体，金字塔，盒子和球体。如果这些几何模型都不符合您的需求，您可以通过定义一个起点并添加线条来创建一个模型来绘制自己的图形。绘制线来定义模型创建了所谓的贝塞尔路径。</p><p>创建贝塞尔路径的四个主要步骤包括：</p><ul><li>定义贝塞尔路径</li><li>定义绘制起点</li><li>绘制一条或多条线</li><li>根据您定义的Bezier路径定义SCNShape</li></ul><p>为了创建一个贝塞尔路径，你需要定义一个BezierPath对象像这样:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">UIBezierPath</span>()</span><br></pre></td></tr></table></figure><p>一旦你已经创建了一个贝塞尔路径，你需要定义它的起点像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>现在我们需要绘制一条或者多条线使用addLine方法，它定义了终点像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">0.2</span>, y: <span class="number">0.2</span>))</span><br></pre></td></tr></table></figure><p>最终我们需要将贝塞尔曲线变成一个图形：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shape = <span class="type">SCNShape</span>(path: path, extrusionDepth: <span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><p>一旦我们有一个图形，我们可以显示它作为一个增强现实物体，通过定义它作为一个带有颜色和位置的节点。然后我们可以最终添加节点到增强现实视图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">node.geometry = shape</span><br><span class="line">node.geometry?.firstMaterial?.diffuse.contents = <span class="type">UIColor</span>.yellow</span><br><span class="line">node.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">0.4</span>)</span><br><span class="line">sceneView.scene.rootNode.addChildNode(node)</span><br></pre></td></tr></table></figure><p>在你的ARReset项目中修改ViewController.swift文件，它的全部内容看起来像下面这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> sceneView: <span class="type">ARSCNView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个会话配置</span></span><br><span class="line">    <span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingConfiguration</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        sceneView.delegate = <span class="keyword">self</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 显示统计例如帧率和时间信息</span></span><br><span class="line">        sceneView.showStatistics = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 显示原点和特征点</span></span><br><span class="line">        sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>()</span><br><span class="line">        path.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>))</span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">0.2</span>, y: <span class="number">0.2</span>))</span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">0.4</span>, y: -<span class="number">0.2</span>))</span><br><span class="line">        <span class="keyword">let</span> shape = <span class="type">SCNShape</span>(path: path, extrusionDepth: <span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">        node.geometry = shape</span><br><span class="line">        node.geometry?.firstMaterial?.diffuse.contents = <span class="type">UIColor</span>.yellow</span><br><span class="line">        node.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">0.4</span>)</span><br><span class="line">        sceneView.scene.rootNode.addChildNode(node)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 运行视图的会话</span></span><br><span class="line">        sceneView.session.run(configuration)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillDisappear(animated)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 暂停视图会话</span></span><br><span class="line">        sceneView.session.pause()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// 处置任何可以重新创建的资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">resetAR</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">        sceneView.session.pause()</span><br><span class="line">        sceneView.session.run(configuration, options: [.resetTracking, .removeExistingAnchors])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你运行这个修改过的ARReset项目在连接到你的Mac的一台iOS设备上，你应当看到一个黄色的三角形超过了世界原点如图10所示。</p><p><img src="https://i.loli.net/2018/06/13/5b2056ffc51ad.jpg" alt=""></p><p><strong>图 10</strong> 使用贝塞尔曲线绘制一个自定义图形</p><h2 id="修改模型外观"><a href="#修改模型外观" class="headerlink" title="修改模型外观"></a>修改模型外观</h2><p>到现在为止，我们仅仅创建了一个图形和应用颜色到它上面，但是有其他方式修改模型的外观。修改一个模型的外观一些方式包括改变光照，透明度，或者文理。光照使得模型看起来不同，这取决于光照的类型和光源的位置。透明度定义了模型是否显示为实心或透明。纹理在模型的两侧应用图形图像，例如使模型看起来像用砖块或沙子制成。通过修改模型的外观，可以使该模型在视觉上更有趣。</p><p>要试验修改模型的外观，请创建一个新的增强现实应用项目并将其命名为ARAppearance。确保Content Technology使用SceneKit。我们要修改对象外观的第一种方法是使用显示在该模型上的图形图像。</p><p>在互联网上搜索“公共领域纹理图像”，你会发现许多图像，你可以自由下载和使用。纹理图像通常显示一个规则图案，如砖，水，田地，或如图11所示的材料，如木头或石头。</p><p><img src="https://i.loli.net/2018/06/14/5b21aa8771c7f.jpg" alt=""></p><p><strong>图 11</strong> 搜索公共领域的纹理图像</p><p>下载一个纹理图片并确保他被存储为png或者jpg文件格式。然后拖拽它到Navigator面板如图12所示。</p><p><img src="https://i.loli.net/2018/06/14/5b21aabac5519.jpg" alt=""></p><p><strong>图 12</strong> 放置一张文理图片文件在Navigator面板</p><p>修改ViewController.swift文件显示如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> sceneView: <span class="type">ARSCNView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Set the view's delegate</span></span><br><span class="line">        sceneView.delegate = <span class="keyword">self</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Show statistics such as fps and timing information</span></span><br><span class="line">        sceneView.showsStatistics = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> box = <span class="type">SCNBox</span>(width: <span class="number">0.1</span>, height: <span class="number">0.1</span>, length: <span class="number">0.2</span>, chamferRadius: <span class="number">0.01</span>);</span><br><span class="line">        <span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">        <span class="keyword">let</span> material = <span class="type">SCNMaterial</span>()</span><br><span class="line">        material.diffuse.contents = <span class="type">UIImage</span>(named: <span class="string">"stone.jpg"</span>)</span><br><span class="line">        box.materials = [material]</span><br><span class="line">        </span><br><span class="line">        node.geometry = box</span><br><span class="line">        node.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">0.3</span>)</span><br><span class="line">        </span><br><span class="line">        sceneView.scene.rootNode.addChildNode(node)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Create a new scene</span></span><br><span class="line">        <span class="keyword">let</span> scene = <span class="type">SCNScene</span>(named: <span class="string">"art.scnassets/ship.scn"</span>)!</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Set the scene to the view</span></span><br><span class="line">        sceneView.scene = scene</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Create a session configuration</span></span><br><span class="line">        <span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingConfiguration</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the view's session</span></span><br><span class="line">        sceneView.session.run(configuration)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillDisappear(animated)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Pause the view's session</span></span><br><span class="line">        sceneView.session.pause()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Release any cached data, images, etc that aren't in use.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - ARSCNViewDelegate</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // Override to create and configure nodes for anchors added to the view's session.</span></span><br><span class="line"><span class="comment">    func renderer(_ renderer: SCNSceneRenderer, nodeFor anchor: ARAnchor) -&gt; SCNNode? &#123;</span></span><br><span class="line"><span class="comment">        let node = SCNNode()</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">        return node</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: ARSession, didFailWithError error: Error)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Present an error message to the user</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sessionWasInterrupted</span><span class="params">(<span class="number">_</span> session: ARSession)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Inform the user that the session has been interrupted, for example, by presenting an overlay</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sessionInterruptionEnded</span><span class="params">(<span class="number">_</span> session: ARSession)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Reset tracking and/or remove existing anchors if consistent tracking is required</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这份代码定义了一个SCNBox的几何模型，同时也定义了一个SCNMaterial的数组。那是因为一个模型可以有多个材质。然后代码定义了图形文件叫做”stone.jpg”作为它的第一材质，创建一个石头图像在模型周围如图13所示：</p><p><img src="https://i.loli.net/2018/06/14/5b21b9b7477dc.jpg" alt=""></p><p><strong>图 13</strong> 一块石头图像以包围盒子模型的材料形式出现</p><p>另外一种修改模型外观的方式是改变它的透明度，使用一个0（不可见）到1（纯色）。添加一行代码来定义一个透明度值，所以你整个viewDidLoad方法看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Set the view's delegate</span></span><br><span class="line">    sceneView.delegate = <span class="keyword">self</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Show statistics such as fps and timing information</span></span><br><span class="line">    sceneView.showsStatistics = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> box = <span class="type">SCNBox</span>(width: <span class="number">0.1</span>, height: <span class="number">0.1</span>, length: <span class="number">0.2</span>, chamferRadius: <span class="number">0.01</span>);</span><br><span class="line">    <span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">    <span class="keyword">let</span> material = <span class="type">SCNMaterial</span>()</span><br><span class="line">    material.diffuse.contents = <span class="type">UIImage</span>(named: <span class="string">"stone.jpg"</span>)</span><br><span class="line">    material.transparency = <span class="number">0.7</span></span><br><span class="line">    box.materials = [material]</span><br><span class="line">    </span><br><span class="line">    node.geometry = box</span><br><span class="line">    node.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">0.3</span>)</span><br><span class="line">    </span><br><span class="line">    sceneView.scene.rootNode.addChildNode(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>上面的代码用材质数组定义了两个特性。首先，它显示了“stone.jpg”图像在盒子周围。其次，它定义了一个0.7的透明度，所以盒子如果14所示出现半透明。![](https://i.loli.net/2018/06/14/5b21b9b7477dc.jpg)</code></pre><p><strong>图 14</strong> 改变透明度使得图形看起来减少纯色</p><p>另外应用纹理和定义一个透明度层次，另外一种去改变模型外观的方式是通过光照。光照让你创建一个光源，它照亮附近的模型。依赖你选择的光照和光照位置，你可以在一个图形上创建不同类型可视效果。</p><p>创建一个光源，你需要做以下这些：</p><ul><li>定义一个SCNLight对象</li><li>定义SCNLight类型</li><li>分配SCNLight对象到一个SCNNode上</li><li>定义SCNNode位置</li><li>添加SCNNode到场景</li></ul><p>定义一个SCNLight对象，你只需要像这样创建一个常量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spotLight = <span class="type">SCNLight</span>()</span><br></pre></td></tr></table></figure></p><p>现在定义下列光照类型中的一个：</p><ul><li>ambient</li><li>directional</li><li>IES</li><li>probe</li><li>spot</li></ul><p>每种光照类型以不同的方式突出模型，所以让我们通过直射光类型来开始实验：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spotLight.type = .directional</span><br></pre></td></tr></table></figure><p>既然你已经定义了一个光照类型，你需要像这样创建一个SCNNode：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spotNode = <span class="type">SCNNode</span>()</span><br><span class="line">spotNode.light = spotLight</span><br></pre></td></tr></table></figure><p>第一行创建一个SCNNode对象，第二行定义了它的光源作为一个聚光灯（SCNLight）我们前面创建的对象。</p><p>最终，我们可以防止一个SNNode对象基于世界原点。那意味着你需要定义一个X，Y和Z值像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spotNode.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上述代码放置光源在原点上面0.2米的位置，所以光照耀下来在我们将要创建的盒子上。</p><p>最后一步是添加这个光源节点到增强现实场景上：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneView.scene.rootNode.addChildNode(spotNode)</span><br></pre></td></tr></table></figure><p>整个viewDidLoad函数应该看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Set the view's delegate</span></span><br><span class="line">    sceneView.delegate = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Show statistics such as fps and timing information</span></span><br><span class="line">    sceneView.showStatistics = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> box = <span class="type">SCNBox</span>(width: <span class="number">0.1</span>, height: <span class="number">0.1</span>, length: <span class="number">0.1</span>, chamferRadius: <span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">    <span class="keyword">let</span> material = <span class="type">SCNMaterial</span>()</span><br><span class="line">    <span class="comment">// material.diffuse.contents = UIImage(named: "stone.jpg")</span></span><br><span class="line">    <span class="comment">// material.transparency = 0.7</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> spotLight = <span class="type">SCNLight</span>()</span><br><span class="line">    spotLight.type = .directional</span><br><span class="line">    <span class="keyword">let</span> spotNode = <span class="type">SCNNode</span>()</span><br><span class="line">    spotNode.light = spotLight</span><br><span class="line">    spotNode.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    material.diffuse.contents = <span class="type">UIColor</span>.orange</span><br><span class="line">    box.materials = [material]</span><br><span class="line">    </span><br><span class="line">    node.geometry = box</span><br><span class="line">    node.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">0.3</span>)</span><br><span class="line">    </span><br><span class="line">    sceneView.scene.rootNode.addChildNode(node)</span><br><span class="line">    sceneView.scene.rootNode.addChildNode(spotNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你运行这个项目，它将创建一个橙色的盒子放置在原点后面0.3米的地方。然后光源将出现在原点上面0.2米的地方照耀下来到这个橙色的盒子上。因为光照类型是directional，它仅仅照亮了盒子的表面如果15所示。</p><pre><code>![](https://i.loli.net/2018/06/14/5b21b9b7477dc.jpg)</code></pre><p><strong>图 15</strong> 定向光聚焦在橙色盒子前面</p><p>查看不同类型光如何改变模型外观，改变光源类型从directional到omni像这样：<br>// spotLight.type = .directional // 只照亮盒子前面<br>spotLight.type = .omni //照亮盒子的顶部和前面</p><p>现在如果你运行这个项目，omni光照类型照亮盒子的前面和顶部如果16所示：</p><pre><code>![](https://i.loli.net/2018/06/14/5b21b9b7477dc.jpg)</code></pre><p><strong>图 16</strong> omni光照类型照亮橙色盒子前面和顶部</p><p>苹果的文档定义了不同光照类型应有的表现，所以用改变光照类型和光源位置来实验。通过改变光源位置，你可以照亮模型的不同区域。通过简单的改变光照类型，你可以用不同的方式照亮一个物体如图17所示。</p><pre><code>![](https://i.loli.net/2018/06/14/5b21b9b7477dc.jpg)</code></pre><p><strong>图 16</strong> 不同光照类型在照亮模型上起不同的作用</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这个章节，你已经学习了使用ARKit创建增强现实物体的基础。你已经学会了如果放置一个增强现实物体在一个场景和如何改变一个物体外观，通过改变它们的颜色，透明度和纹理。另外，你也学习了如何绘制你自己的物体和使用一个光源照亮一个物体。</p><p>增强现实给予你的应用在一个真实场景中覆盖真实物体的能力。在下一章中，你将学习如何用增强现实对象去交互，以便于你可以控制和操作他们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近些年最流行的手游之一是Pokemon Go(精灵宝可梦Go), 它展示通过iPhone相机查看覆盖在真实地点的宝可梦角色。将iPhone摄像头对准公园长椅或灌木丛，你可以看到一个宝可梦卡通角色，好像它真的在那。&lt;/p&gt;
&lt;p&gt;这种在实际物理对象上显示虚拟对象的技术被称为增强现实（AR）。增强现实背后的想法是让您将真实世界的物体与出现在iPhone屏幕上的虚拟物体相结合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AR" scheme="https://zhaolilong.com/tags/AR/"/>
    
      <category term="增强现实" scheme="https://zhaolilong.com/tags/%E5%A2%9E%E5%BC%BA%E7%8E%B0%E5%AE%9E/"/>
    
  </entry>
  
</feed>
