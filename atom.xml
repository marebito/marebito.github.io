<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博伊卡の楼閣</title>
  
  <subtitle>逆水行舟，不进则退</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhaolilong.com/"/>
  <updated>2020-09-11T08:13:24.093Z</updated>
  <id>https://zhaolilong.com/</id>
  
  <author>
    <name>Boyka·Yuri</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker删除镜像和容器</title>
    <link href="https://zhaolilong.com/2020/09/11/Docker%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8/"/>
    <id>https://zhaolilong.com/2020/09/11/Docker删除镜像和容器/</id>
    <published>2020-09-11T08:12:31.000Z</published>
    <updated>2020-09-11T08:13:24.093Z</updated>
    
    <content type="html"><![CDATA[<p>当一个host中镜像和容器较多，需要重置时可选择删除其中部分或全部的镜像和容器。那么你就需要下面的操作了。</p><p>1、删除容器</p><p>1）首先需要停止所有的容器</p><p>docker stop $(docker ps -a -q)</p><p>2）删除所有的容器（只删除单个时把后面的变量改为image id即可）</p><p>docker rm $(docker ps -a -q)</p><p>2、删除镜像</p><p>1）查看host中的镜像</p><p>docker images</p><p>2）删除指定id的镜像</p><p>docker rmi <image id=""></image></p><p>想要删除untagged images，也就是那些id为的image的话可以用</p><p>docker rmi $(docker images | grep “^” | awk “{print $3}”)</p><p>3）删除全部的images</p><p>docker rmi $(docker images -q)</p><p>3、当要删除的iamges和其他的镜像有关联而无法删除时</p><p>可通过 -f 参数强制删除</p><p>docker rmi -f $(docker images -q)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当一个host中镜像和容器较多，需要重置时可选择删除其中部分或全部的镜像和容器。那么你就需要下面的操作了。&lt;/p&gt;
&lt;p&gt;1、删除容器&lt;/p&gt;
&lt;p&gt;1）首先需要停止所有的容器&lt;/p&gt;
&lt;p&gt;docker stop $(docker ps -a -q)&lt;/p&gt;
&lt;p&gt;2）删
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>U8G2自定义中文字库的方法</title>
    <link href="https://zhaolilong.com/2020/09/03/U8G2%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E6%96%87%E5%AD%97%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://zhaolilong.com/2020/09/03/U8G2自定义中文字库的方法/</id>
    <published>2020-09-03T06:40:02.000Z</published>
    <updated>2020-09-03T06:41:00.276Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000022324409" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022324409</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000022324409&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000022324409&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="-U8G2 -字库" scheme="https://zhaolilong.com/tags/U8G2-%E5%AD%97%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>《Arduino》开发之用u8g2库给0.96寸OLED刷bmp图片，OLED图片取模</title>
    <link href="https://zhaolilong.com/2020/09/03/%E3%80%8AArduino%E3%80%8B%E5%BC%80%E5%8F%91%E4%B9%8B%E7%94%A8u8g2%E5%BA%93%E7%BB%990-96%E5%AF%B8OLED%E5%88%B7bmp%E5%9B%BE%E7%89%87%EF%BC%8COLED%E5%9B%BE%E7%89%87%E5%8F%96%E6%A8%A1/"/>
    <id>https://zhaolilong.com/2020/09/03/《Arduino》开发之用u8g2库给0-96寸OLED刷bmp图片，OLED图片取模/</id>
    <published>2020-09-03T06:38:46.000Z</published>
    <updated>2020-09-03T06:39:12.342Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_41868901/article/details/104221495" target="_blank" rel="noopener">https://blog.csdn.net/qq_41868901/article/details/104221495</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41868901/article/details/104221495&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_41868901/ar
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OLED/LCD/12864_WEB在线图片取模工具</title>
    <link href="https://zhaolilong.com/2020/09/03/OLED-LCD-12864-WEB%E5%9C%A8%E7%BA%BF%E5%9B%BE%E7%89%87%E5%8F%96%E6%A8%A1%E5%B7%A5%E5%85%B7/"/>
    <id>https://zhaolilong.com/2020/09/03/OLED-LCD-12864-WEB在线图片取模工具/</id>
    <published>2020-09-03T06:36:20.000Z</published>
    <updated>2020-09-03T06:36:51.355Z</updated>
    
    <content type="html"><![CDATA[<p>工具地址：<br><a href="http://tools.clz.me/" target="_blank" rel="noopener">http://tools.clz.me/</a></p><p>源代码：<br><a href="https://github.com/coloz/image-to-bitmap-array" target="_blank" rel="noopener">https://github.com/coloz/image-to-bitmap-array</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工具地址：&lt;br&gt;&lt;a href=&quot;http://tools.clz.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://tools.clz.me/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;br&gt;&lt;a href=&quot;https://github.co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IDEA模板的内置变量</title>
    <link href="https://zhaolilong.com/2020/09/03/IDEA%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F/"/>
    <id>https://zhaolilong.com/2020/09/03/IDEA模板的内置变量/</id>
    <published>2020-09-03T06:29:34.000Z</published>
    <updated>2020-09-03T06:30:07.333Z</updated>
    
    <content type="html"><![CDATA[<p>${PACKAGE_NAME} name of the package in which the new file is created</p><p>${USER} current user system login name</p><p>${DATE} current system date</p><p>${TIME} current system time</p><p>${YEAR} current year</p><p>${MONTH} current month</p><p>${MONTH_NAME_SHORT} first 3 letters of the current month name. Example: Jan, Feb, etc.</p><p>${MONTH_NAME_FULL} full name of the current month. Example: January, February, etc.</p><p>${DAY} current day of the month</p><p>${HOUR} current hour</p><p>${MINUTE} current minute</p><p>${PROJECT_NAME} the name of the current project</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;${PACKAGE_NAME} name of the package in which the new file is created&lt;/p&gt;
&lt;p&gt;${USER} current user system login name&lt;/p&gt;
&lt;p&gt;${DATE} current
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac版本软件崩溃解决方案</title>
    <link href="https://zhaolilong.com/2020/09/03/Mac%E7%89%88%E6%9C%AC%E8%BD%AF%E4%BB%B6%E5%B4%A9%E6%BA%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://zhaolilong.com/2020/09/03/Mac版本软件崩溃解决方案/</id>
    <published>2020-09-03T06:16:15.000Z</published>
    <updated>2020-09-03T06:16:56.305Z</updated>
    
    <content type="html"><![CDATA[<p>codesign -f -s - –deep /Applications/xxx.app</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;codesign -f -s - –deep /Applications/xxx.app&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="破解" scheme="https://zhaolilong.com/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Modbus寄存器种类说明</title>
    <link href="https://zhaolilong.com/2020/09/03/Modbus%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%8D%E7%B1%BB%E8%AF%B4%E6%98%8E/"/>
    <id>https://zhaolilong.com/2020/09/03/Modbus寄存器种类说明/</id>
    <published>2020-09-03T03:43:53.000Z</published>
    <updated>2020-09-03T03:46:56.049Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>寄存器种类</th><th>说明</th><th>PLC类比</th><th>举例说明</th></tr></thead><tbody><tr><td>线圈状态</td><td>输出端口。可设定端口的输出状态，也可以读取该位的输出状态。可分为两种不同的执行状态，例如保持型或边沿触发型。</td><td>DO数字量输出</td><td>电磁阀输出，MOSFET输出，LED显示等。</td></tr><tr><td>离散输入状态</td><td>输入端口。通过外部设定改变输入状态，可读但不可写。</td><td>DI数字量输入</td><td>拨码开关，接近开关等。</td></tr><tr><td>保持寄存器</td><td>输出参数或保持参数，控制器运行时被设定的某些参数。可读可写。</td><td>AO模拟量输出</td><td>模拟量输出设定值，PID运行参数，变量阀输出大小，传感器报警上限下限。</td></tr><tr><td>输入寄存器</td><td>输入参数。控制器运行时从外部设备获得的参数。可读但不可写。</td><td>AI模拟量输入</td><td>模拟量输入</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;寄存器种类&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;PLC类比&lt;/th&gt;
&lt;th&gt;举例说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;线圈状态&lt;/td&gt;
&lt;td&gt;输出端口。可设定端口的输出状态，也可
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ModbusTCP报文格式说明</title>
    <link href="https://zhaolilong.com/2020/09/03/ModbusTCP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/"/>
    <id>https://zhaolilong.com/2020/09/03/ModbusTCP报文格式说明/</id>
    <published>2020-09-03T02:20:07.000Z</published>
    <updated>2020-09-03T06:07:09.487Z</updated>
    
    <content type="html"><![CDATA[<p>modbus tcp数据报文结构</p><p>请求：00 00 00 00 00 06 09 03 00 00 00 01</p><p>响应：00 00 00 00 00 05 09 03 02 12 34</p><p>　　一次modbus tcp读取保持寄存器的通信分析(省略了ip/tcp头)：从左向右分析该数据报文：</p><p>请求：</p><p>00 00为此次通信事务处理标识符，一般每次通信之后将被要求加1以区别不同的通信数据报文;</p><p>00 00表示协议标识符，00 00为modbus协议;</p><p>00 06为数据长度，用来指示接下来数据的长度，单位字节;</p><p>09为设备地址，用以标识连接在串行线或者网络上的远程服务端的地址。以上七个字节也被称为modbus报文头；</p><p>03为功能码，此时代码03为读取保持寄存器数据；</p><p>00 00为起始地址；</p><p>00 01为寄存器数量，（word数量）。</p><p>响应：</p><p>00 00为此次通信事务处理标识符，应答报文要求与先前对应的请求保持一致;</p><p>00 00为协议标识符，与先前对应的请求保持一致;</p><p>00 05为数据长度，用来指示接下来数据的长度，单位字节;</p><p>09为设备地址，应答报文要求与先前对应的请求保持一致；</p><p>03为功能码，正常情况下应答报文要求与先前对应的请求保持一致，如果出错则返回80h+先前的功能码；</p><p>02指示接下来数据的字节长度;</p><p>12 34为被读取的保持寄存器中的数据值，即要求被读取的地址为00 00的保持寄存器中的数值为1234h。</p><p>参考资料：<a href="https://www.cnblogs.com/ioufev/articles/10830028.html" target="_blank" rel="noopener">https://www.cnblogs.com/ioufev/articles/10830028.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;modbus tcp数据报文结构&lt;/p&gt;
&lt;p&gt;请求：00 00 00 00 00 06 09 03 00 00 00 01&lt;/p&gt;
&lt;p&gt;响应：00 00 00 00 00 05 09 03 02 12 34&lt;/p&gt;
&lt;p&gt;　　一次modbus tcp读取保持寄存器的通信
      
    
    </summary>
    
    
      <category term="ModbusTCP" scheme="https://zhaolilong.com/tags/ModbusTCP/"/>
    
  </entry>
  
  <entry>
    <title>Modbus常用功能码备查</title>
    <link href="https://zhaolilong.com/2020/09/03/Modbus%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E7%A0%81%E5%A4%87%E6%9F%A5/"/>
    <id>https://zhaolilong.com/2020/09/03/Modbus常用功能码备查/</id>
    <published>2020-09-03T01:48:13.000Z</published>
    <updated>2020-09-03T03:42:50.327Z</updated>
    
    <content type="html"><![CDATA[<p>Modbus功能码</p><table><thead><tr><th>功能码</th><th>名称</th><th>寄存器PLC地址</th><th>位操作/字操作</th><th>作用</th><th>操作数量</th></tr></thead><tbody><tr><td>01</td><td>读线圈状态</td><td>00001-09999</td><td>位</td><td>取得一组逻辑线圈的当前状态（ON/OFF）</td><td>单个或多个</td></tr><tr><td>02</td><td>读离散输入状态</td><td>10001-19999</td><td>位</td><td>取得一组开关输入的当前状态（ON/OFF）</td><td>单个或多个</td></tr><tr><td>03</td><td>读保持寄存器</td><td>40001-49999</td><td>整型、字符型、状态字、浮点型</td><td>在一个或多个保持寄存器中取得当前的二进制值</td><td>单个或多个</td></tr><tr><td>04</td><td>读输入寄存器</td><td>30001-39999</td><td>整型、状态字、浮点型</td><td>在一个或多个输入寄存器中取得当前的二进制值</td><td>单个或多个</td></tr><tr><td>05</td><td>写单个线圈</td><td>00001-09999</td><td>位</td><td>强置一个逻辑线圈的通断状态</td><td>单个</td></tr><tr><td>06</td><td>写单个寄存器</td><td>40001-49999</td><td>整型、字符型、状态字、浮点型</td><td>把二进制值装入一个保持寄存器</td><td>单个</td></tr><tr><td>15</td><td>写多个线圈</td><td>00001-09999</td><td>位</td><td>强置一串连续逻辑线圈的通断</td><td>多个</td></tr><tr><td>16</td><td>写多个保持寄存器</td><td>40001-49999</td><td>整型、字符型、状态字、浮点型</td><td>把具体的二进制值装入一串连续的保持寄存器</td><td>多个</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Modbus功能码&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能码&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;寄存器PLC地址&lt;/th&gt;
&lt;th&gt;位操作/字操作&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;操作数量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Modbus" scheme="https://zhaolilong.com/tags/Modbus/"/>
    
  </entry>
  
  <entry>
    <title>Modbus寄存器地址规则</title>
    <link href="https://zhaolilong.com/2020/09/03/Modbus%E5%AF%84%E5%AD%98%E5%99%A8%E5%9C%B0%E5%9D%80%E8%A7%84%E5%88%99/"/>
    <id>https://zhaolilong.com/2020/09/03/Modbus寄存器地址规则/</id>
    <published>2020-09-03T01:45:04.000Z</published>
    <updated>2020-09-03T01:45:52.220Z</updated>
    
    <content type="html"><![CDATA[<p>Modbus协议定义的寄存器地址是5位十进制地址，即：</p><p>线圈（DO）地址：00000~09999</p><p>触点（DI）地址：10000~19999</p><p>输入寄存器（AI）地址：30000~39999</p><p>输出寄存器（AO）地址：40000~49999</p><p>由于上述各类地址是唯一对应的，因此有些资料就以其第一个数字区分各类地址，即：0x代表线圈（DO）类地址，1x代表触点（DI）类地址、 3x代表输入寄存器（AI）类地址、4x代表输出寄存器（AO）类地址。</p><p>在实际编程中，由于前缀的区分作用，所以只需说明后4位数，而且需转换为4位十六进制地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Modbus协议定义的寄存器地址是5位十进制地址，即：&lt;/p&gt;
&lt;p&gt;线圈（DO）地址：00000~09999&lt;/p&gt;
&lt;p&gt;触点（DI）地址：10000~19999&lt;/p&gt;
&lt;p&gt;输入寄存器（AI）地址：30000~39999&lt;/p&gt;
&lt;p&gt;输出寄存器（AO）地址：400
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Arduino中字符串常见操作</title>
    <link href="https://zhaolilong.com/2020/06/11/Arduino%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
    <id>https://zhaolilong.com/2020/06/11/Arduino中字符串常见操作/</id>
    <published>2020-06-11T03:12:37.000Z</published>
    <updated>2020-06-11T03:21:46.464Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">isAlphaNumeric()  // 判断是否为字母数字</span><br><span class="line"></span><br><span class="line">isAlpha()        // 判断是否为字母</span><br><span class="line"></span><br><span class="line">isAscii()        // 判断是否为 ASCII 码</span><br><span class="line"></span><br><span class="line">isWhitespace()    // 判断是否为空格符</span><br><span class="line"></span><br><span class="line">isControl()          // 判断是否为控制字符</span><br><span class="line"></span><br><span class="line">isDigit()              // 判断是否为数字</span><br><span class="line"></span><br><span class="line">isGraph()            // 判断是否为可打印的字符，不是空格</span><br><span class="line"></span><br><span class="line">isLowerCase()       // 判断是否为小写</span><br><span class="line"></span><br><span class="line">isPrintable()        // 判断是否为可打印的字符</span><br><span class="line"></span><br><span class="line">isPunct()            // 判断是否为标点符号</span><br><span class="line"></span><br><span class="line">isSpace()            // 判断是否为空格</span><br><span class="line"></span><br><span class="line">isUpperCase()     // 判断是否为大写</span><br><span class="line"></span><br><span class="line">isHexadecimalDigit()  // 判断是否为十六进制数字(i.e. 0 - 9, a - F, or A - F)</span><br></pre></td></tr></table></figure><ol><li>字符串转char *</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello&quot;;</span><br><span class="line">int str_len = str() + 1; </span><br><span class="line">char str_char[str_len];</span><br><span class="line">str.toCharArray(str_char, str_len);</span><br></pre></td></tr></table></figure><ol start="2"><li>字符串转整型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;65535&quot;;</span><br><span class="line">int intValue = str.toInt();</span><br></pre></td></tr></table></figure><ol start="3"><li>字符串切割</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, World&quot;;</span><br><span class="line">int str_len = str() + 1; </span><br><span class="line">char str_char[str_len];</span><br><span class="line">strcpy(str_char, str());</span><br><span class="line">const char split_token[2] = &quot;.&quot;;</span><br><span class="line">int charArray[str_len];</span><br><span class="line">int i = 0;</span><br><span class="line">char *charValue = strtok(str_char, split_token);                 </span><br><span class="line">while( charValue != NULL ) &#123;</span><br><span class="line">    charArray[i++] = charValue;</span><br><span class="line">    charValue = strtok(NULL, split_token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考连接: <a href="https://www.jianshu.com/p/5d4c5f318b73" target="_blank" rel="noopener">https://www.jianshu.com/p/5d4c5f318b73</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jenkins更新新版本速度慢</title>
    <link href="https://zhaolilong.com/2020/06/04/jenkins%E6%9B%B4%E6%96%B0%E6%96%B0%E7%89%88%E6%9C%AC%E9%80%9F%E5%BA%A6%E6%85%A2/"/>
    <id>https://zhaolilong.com/2020/06/04/jenkins更新新版本速度慢/</id>
    <published>2020-06-04T01:53:53.000Z</published>
    <updated>2020-06-04T01:55:44.895Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Linux<br>cd /root/.jenkins/updates/</p></li><li><p>OSX<br>cd /Users/Shared/Jenkins/Home/updates<br>cd ~/.jenkins/updates</p></li></ul><p>sed -i ‘s/http://updates.jenkins-ci.org/download/https://mirrors.tuna.tsinghua.edu.cn/jenkins/g’ default.json &amp;&amp; sed -i ‘s/http://<a href="http://www.google.com/https:\/\/www.baidu.com/g&#39;" target="_blank" rel="noopener">www.google.com/https:\/\/www.baidu.com/g&#39;</a> default.json</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linux&lt;br&gt;cd /root/.jenkins/updates/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OSX&lt;br&gt;cd /Users/Shared/Jenkins/Home/updates&lt;br&gt;cd ~/.jenkins/updates&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux下查看ssh的用户登录日志</title>
    <link href="https://zhaolilong.com/2020/05/29/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8Bssh%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%97%A5%E5%BF%97/"/>
    <id>https://zhaolilong.com/2020/05/29/Linux下查看ssh的用户登录日志/</id>
    <published>2020-05-29T03:12:33.000Z</published>
    <updated>2020-05-29T03:13:12.830Z</updated>
    
    <content type="html"><![CDATA[<p>linux查看日志： </p><h1 id="cd-var-log"><a href="#cd-var-log" class="headerlink" title="cd /var/log"></a>cd /var/log</h1><h1 id="less-secure"><a href="#less-secure" class="headerlink" title="less secure"></a>less secure</h1><p>或者 </p><h1 id="less-messages"><a href="#less-messages" class="headerlink" title="less messages"></a>less messages</h1><p>最近登录的日志： </p><h1 id="last"><a href="#last" class="headerlink" title="last"></a>last</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;linux查看日志： &lt;/p&gt;
&lt;h1 id=&quot;cd-var-log&quot;&gt;&lt;a href=&quot;#cd-var-log&quot; class=&quot;headerlink&quot; title=&quot;cd /var/log&quot;&gt;&lt;/a&gt;cd /var/log&lt;/h1&gt;&lt;h1 id=&quot;less-secure&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>是谁没事儿尝试来我家开锁？</title>
    <link href="https://zhaolilong.com/2020/05/28/%E6%98%AF%E8%B0%81%E6%B2%A1%E4%BA%8B%E5%84%BF%E5%B0%9D%E8%AF%95%E6%9D%A5%E6%88%91%E5%AE%B6%E5%BC%80%E9%94%81%EF%BC%9F/"/>
    <id>https://zhaolilong.com/2020/05/28/是谁没事儿尝试来我家开锁？/</id>
    <published>2020-05-28T02:23:41.000Z</published>
    <updated>2020-05-29T03:13:46.789Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Failed password for invalid user&quot; /var/log/secure | awk &apos;&#123;print $13&#125;&apos; | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>U8G2详解</title>
    <link href="https://zhaolilong.com/2020/05/09/U8G2%E8%AF%A6%E8%A7%A3/"/>
    <id>https://zhaolilong.com/2020/05/09/U8G2详解/</id>
    <published>2020-05-09T02:09:48.000Z</published>
    <updated>2020-05-09T07:21:47.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="U8g2简介"><a href="#U8g2简介" class="headerlink" title="U8g2简介"></a>U8g2简介</h2><p>U8g2是嵌入式设备的单色图形库，一句话简单明了。主要应用于嵌入式设备，包括我们常见的单片机。    </p><a id="more"></a><h2 id="U8g2支持的显示控制器"><a href="#U8g2支持的显示控制器" class="headerlink" title="U8g2支持的显示控制器"></a>U8g2支持的显示控制器</h2><p>    U8g2支持单色OLED和LCD，包括以下控制器：SSD1305，SSD1306，SSD1309，SSD1322，SSD1325，SSD1327，SSD1329，SSD1606，SSD1607，SH1106，SH1107，SH1108，SH1122，T6963，RA8835，LC7981，PCD8544，PCF8812，HX1230 ，UC1601，UC1604，UC1608，UC1610，UC1611，UC1701，ST7565，ST7567，ST7588，ST75256，NT7534，IST3020，ST7920，LD7032，KS0108，SED1520，SBN1661，IL3820，MAX7219（有关完整列表，请参见 此处）。<br>    可以说，基本上主流的显示控制器都支持，比如我们常见的SSD1306 12864，读者在使用该库之前请查阅自己的OLED显示控制器是否处于支持列表中。    </p><h2 id="U8g2支持的Arduino主板"><a href="#U8g2支持的Arduino主板" class="headerlink" title="U8g2支持的Arduino主板"></a>U8g2支持的Arduino主板</h2><p>    可以说基本上所有Arduino API的主板都得到U8g2的支持。包括：</p><p>Aruino Zero，Uno，Mega，Due，101，MKR Zero以及所有其他Arduino官方主板<br>基于Arduino平台的STM32<br>基于Arduino平台的ESP8266和ESP32<br>甚至其他不知名的基于Arduino平台的开发板</p><h2 id="U8g2如何在Arduino平台上安装"><a href="#U8g2如何在Arduino平台上安装" class="headerlink" title="U8g2如何在Arduino平台上安装"></a>U8g2如何在Arduino平台上安装</h2><p> Arduino库U8g2可以从Arduino IDE的库管理器安装，读者在库管理器搜索“U8g2”关键字就可以下载安装：<br> <br> <img src="/2020/05/09/U8G2详解/1588990435.png" alt=""><br> <br> 下载完毕，测试一下库是否安装成功： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// put your setup code here, to run once:</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// put your main code here, to run repeatedly:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成功，证明你本地已经加载了U8G2库。<br><img src="/2020/05/09/U8G2详解/1588990704.png" alt=""></p><blockquote><p><font color="red">重要知识点</font></p></blockquote><ul><li>像素点点阵<br>OLED其实就是一个M x n 的像素点阵，想显示什么就得把具体位置的像素点亮起来。对于每一个像素点，有可能是1点亮，也有可能是0点亮；</li><li>坐标系<br><img src="/2020/05/09/U8G2详解/1588990808.png" alt=""><br>在坐标系中，左上角是原点，向右是X轴，向下是Y轴。</li></ul><h2 id="U8g2优势"><a href="#U8g2优势" class="headerlink" title="U8g2优势"></a>U8g2优势</h2><ul><li>U8g2库平台支持性好，基本上支持绝大部分Arduino开发板，特别也博主比较喜欢的ESP8266；</li><li>U8g2库显示控制器支持性好，基本上市面上的OLED都完美支持；</li><li>U8g2库 API众多，特别支持了中文，支持了不同字体，这是一个对于开发者俩说不小的福利。</li></ul><h2 id="U8g2库函数详解"><a href="#U8g2库函数详解" class="headerlink" title="U8g2库函数详解"></a>U8g2库函数详解</h2><h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><h4 id="u8g2-begin-——-构造U8G2"><a href="#u8g2-begin-——-构造U8G2" class="headerlink" title="u8g2.begin() —— 构造U8G2"></a>u8g2.begin() —— 构造U8G2</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化U8g2库</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 initDisplay clearDisplay setPowerSave</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span> U8G2::begin(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>源码说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">begin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* note: call to u8x8_utf8_init is not required here, this is done in the setup procedures before */</span></span><br><span class="line">   initDisplay(); <span class="comment">//初始化显示器</span></span><br><span class="line">   clearDisplay();  <span class="comment">// 重置清屏</span></span><br><span class="line">   setPowerSave(<span class="number">0</span>); <span class="comment">//唤醒屏幕</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="u8g2-beginSimple-——-构造U8G2"><a href="#u8g2-beginSimple-——-构造U8G2" class="headerlink" title="u8g2.beginSimple() —— 构造U8G2"></a>u8g2.beginSimple() —— 构造U8G2</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单初始化U8g2库</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 beginSimple</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::beginSimple(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>源码说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beginSimple</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* does not clear the display and does not wake up the display */</span></span><br><span class="line"><span class="comment">/* user is responsible for calling clearDisplay() and setPowerSave(0) */</span></span><br><span class="line">   initDisplay();<span class="comment">//初始化显示器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong><br>可以看到和begin()函数的区别，需要用户自行控制初始化过程，给了一定的自由度，建议直接用begin函数。</p></blockquote><h4 id="u8g2-initDisplay-——-初始化显示控制器"><a href="#u8g2-initDisplay-——-初始化显示控制器" class="headerlink" title="u8g2.initDisplay() —— 初始化显示控制器"></a>u8g2.initDisplay() —— 初始化显示控制器</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化显示控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::initDisplay(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong><br>这个方法不需要单独调用，会在begin函数主动调用一次，在里面针对具体的OLED进行配置；</p></blockquote><h4 id="u8g2-clearDisplay-——-清除屏幕内容"><a href="#u8g2-clearDisplay-——-清除屏幕内容" class="headerlink" title="u8g2.clearDisplay() —— 清除屏幕内容"></a>u8g2.clearDisplay() —— 清除屏幕内容</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除屏幕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::clearDisplay(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong><br>这个方法无需单独调用，会在begin函数主动调用一次；<br>不要在 firstPage 和 nextPage 函数之间调用该方法；</p></blockquote><h4 id="u8g2-setPowerSave-——-是否开启省电模式"><a href="#u8g2-setPowerSave-——-是否开启省电模式" class="headerlink" title="u8g2.setPowerSave() —— 是否开启省电模式"></a>u8g2.setPowerSave() —— 是否开启省电模式</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除显示缓冲区</span></span><br><span class="line"><span class="comment"> * @param is_enable</span></span><br><span class="line"><span class="comment"> *        1 表示启用显示器的省电模式，屏幕上看不到任何东西</span></span><br><span class="line"><span class="comment"> *        0 表示禁用省电模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setPowerSave(<span class="keyword">uint8_t</span> is_enable)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>不管是启用还是禁用，显示器需要的内存消耗是不会变的，说到底就是为了关闭屏幕，做到省电；</li><li>所以这里就可以理解为什么初始化需要 setPowerSave(0);</li></ul><h4 id="u8g2-clear-——-清除操作"><a href="#u8g2-clear-——-清除操作" class="headerlink" title="u8g2.clear() —— 清除操作"></a>u8g2.clear() —— 清除操作</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除屏幕显示，清除缓冲区，光标回到左上角原点位置（0，0）</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 home clearDisplay clearBuffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::clear(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>源码说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; </span><br><span class="line">   home(); <span class="comment">//回到原点</span></span><br><span class="line">   clearDisplay(); <span class="comment">//清除屏幕上的显示</span></span><br><span class="line">   clearBuffer();  <span class="comment">//清除缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="u8g2-clearBuffer-——-清除缓冲区"><a href="#u8g2-clearBuffer-——-清除缓冲区" class="headerlink" title="u8g2.clearBuffer() —— 清除缓冲区"></a>u8g2.clearBuffer() —— 清除缓冲区</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除内存中数据缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::clearBuffer(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong><br>一般这个函数是与sendBuffer函数配对使用，通常用法如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.clearBuffer();</span><br><span class="line">  <span class="comment">// ... write something to the buffer </span></span><br><span class="line">  u8g2.sendBuffer();</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="u8g2-disableUTF8Print-——-禁用-UTF8打印"><a href="#u8g2-disableUTF8Print-——-禁用-UTF8打印" class="headerlink" title="u8g2.disableUTF8Print() —— 禁用 UTF8打印"></a>u8g2.disableUTF8Print() —— 禁用 UTF8打印</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 禁用Arduino平台下支持输出UTF8字符集，默认是开启</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::disableUTF8Print(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><h4 id="u8g2-enableUTF8Print-——-启用-UTF8打印"><a href="#u8g2-enableUTF8Print-——-启用-UTF8打印" class="headerlink" title="u8g2.enableUTF8Print() —— 启用 UTF8打印"></a>u8g2.enableUTF8Print() —— 启用 UTF8打印</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启Arduino平台下支持输出UTF8字符集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::enableUTF8Print(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>我们的中文字符就是UTF8；</p></li><li><p>常见例子</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.begin();</span><br><span class="line">  u8g2.enableUTF8Print();       <span class="comment">// enable UTF8 support for the Arduino print() function</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.setFont(u8g2_font_unifont_t_chinese2);  <span class="comment">// use chinese2 for all the glyphs of "你好世界"</span></span><br><span class="line">  u8g2.firstPage();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    u8g2.setCursor(<span class="number">0</span>, <span class="number">40</span>);</span><br><span class="line">    u8g2.print(<span class="string">"你好世界"</span>);     <span class="comment">// Chinese "Hello World" </span></span><br><span class="line">  &#125; <span class="keyword">while</span> ( u8g2.nextPage() );</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="u8g2-home-——-重置显示光标的位置"><a href="#u8g2-home-——-重置显示光标的位置" class="headerlink" title="u8g2.home() —— 重置显示光标的位置"></a>u8g2.home() —— 重置显示光标的位置</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重置显示光标的位置，回到原点（0，0）</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 print clear</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::home(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><h3 id="绘制相关函数"><a href="#绘制相关函数" class="headerlink" title="绘制相关函数"></a>绘制相关函数</h3><h4 id="u8g2-drawBox-——-画实心方形"><a href="#u8g2-drawBox-——-画实心方形" class="headerlink" title="u8g2.drawBox() —— 画实心方形"></a>u8g2.drawBox() —— 画实心方形</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画实心方形，左上角坐标为(x,y),宽度为w，高度为h</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param w 方形的宽度</span></span><br><span class="line"><span class="comment"> * @param h 方形的高度</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 drawFrame setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawBox(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w, <span class="keyword">u8g2_uint_t</span> h)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</p></li><li><p><strong>示例</strong>:</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawBox(<span class="number">3</span>,<span class="number">7</span>,<span class="number">25</span>,<span class="number">15</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawCircle-——-画空心圆"><a href="#u8g2-drawCircle-——-画空心圆" class="headerlink" title="u8g2.drawCircle() —— 画空心圆"></a>u8g2.drawCircle() —— 画空心圆</h4><ul><li><strong>函数说明</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画空心圆，圆心坐标为(x0,y0),半径为rad</span></span><br><span class="line"><span class="comment"> * @param x0 圆点的x坐标</span></span><br><span class="line"><span class="comment"> * @param y0 圆点的y坐标</span></span><br><span class="line"><span class="comment"> * @param rad 圆形的半径</span></span><br><span class="line"><span class="comment"> * @param opt 圆形选项</span></span><br><span class="line"><span class="comment"> *        U8G_DRAW_ALL 整个圆</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        选项可以通过 | 操作符来组合</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 drawDisc setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawCircle(<span class="keyword">u8g2_uint_t</span> x0, <span class="keyword">u8g2_uint_t</span> y0, <span class="keyword">u8g2_uint_t</span> rad, <span class="keyword">uint8_t</span> opt = U8G2_DRAW_ALL)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong><font color="red">注意点:</font></strong><br>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；<br>直径等于2rad + 1；</p></blockquote><ul><li><strong>示例</strong>:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawCircle(<span class="number">20</span>, <span class="number">25</span>, <span class="number">10</span>, U8G2_DRAW_ALL);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawDisc-——-画实心圆"><a href="#u8g2-drawDisc-——-画实心圆" class="headerlink" title="u8g2.drawDisc() —— 画实心圆"></a>u8g2.drawDisc() —— 画实心圆</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画实心圆，圆心坐标为(x0,y0),半径为rad</span></span><br><span class="line"><span class="comment"> * @param x0 圆点的x坐标</span></span><br><span class="line"><span class="comment"> * @param y0 圆点的y坐标</span></span><br><span class="line"><span class="comment"> * @param rad 圆形的半径</span></span><br><span class="line"><span class="comment"> * @param opt 圆形选项</span></span><br><span class="line"><span class="comment"> *        U8G_DRAW_ALL 整个圆</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧</span></span><br><span class="line"><span class="comment"> *       选项可以通过 | 操作符来组合</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 drawCircle setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawDisc(<span class="keyword">u8g2_uint_t</span> x0, <span class="keyword">u8g2_uint_t</span> y0, <span class="keyword">u8g2_uint_t</span> rad, <span class="keyword">uint8_t</span> opt = U8G_DRAW_ALL)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li><li>直径等于2rad + 1；</li></ul><h4 id="u8g2-drawEllipse-——-画空心椭圆"><a href="#u8g2-drawEllipse-——-画空心椭圆" class="headerlink" title="u8g2.drawEllipse() —— 画空心椭圆"></a>u8g2.drawEllipse() —— 画空心椭圆</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画空心椭圆，圆心坐标为(x0,y0),半径为rad</span></span><br><span class="line"><span class="comment"> * @param x0 圆点的x坐标</span></span><br><span class="line"><span class="comment"> * @param y0 圆点的y坐标</span></span><br><span class="line"><span class="comment"> * @param rx 椭圆形水平x方向的半径</span></span><br><span class="line"><span class="comment"> * @param ry 椭圆形竖直y方向的半径</span></span><br><span class="line"><span class="comment"> * @param opt 圆形选项</span></span><br><span class="line"><span class="comment"> *        U8G_DRAW_ALL 整个椭圆</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        选项可以通过 | 操作符来组合</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 drawCircle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawEllipse(<span class="keyword">u8g2_uint_t</span> x0, <span class="keyword">u8g2_uint_t</span> y0, <span class="keyword">u8g2_uint_t</span> rx, <span class="keyword">u8g2_uint_t</span> ry, <span class="keyword">uint8_t</span> opt)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>rx*ry 在8位模式的u8g2必须小于512</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawEllipse(<span class="number">20</span>, <span class="number">25</span>, <span class="number">15</span>, <span class="number">10</span>, U8G2_DRAW_ALL);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawFilledEllipse-——-画实心椭圆"><a href="#u8g2-drawFilledEllipse-——-画实心椭圆" class="headerlink" title="u8g2.drawFilledEllipse() —— 画实心椭圆"></a>u8g2.drawFilledEllipse() —— 画实心椭圆</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画实心椭圆，圆心坐标为(x0,y0),半径为rad</span></span><br><span class="line"><span class="comment"> * @param x0 圆点的x坐标</span></span><br><span class="line"><span class="comment"> * @param y0 圆点的y坐标</span></span><br><span class="line"><span class="comment"> * @param rx 椭圆形水平x方向的半径</span></span><br><span class="line"><span class="comment"> * @param ry 椭圆形竖直y方向的半径</span></span><br><span class="line"><span class="comment"> * @param opt 圆形选项</span></span><br><span class="line"><span class="comment"> *        U8G_DRAW_ALL 整个椭圆</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧</span></span><br><span class="line"><span class="comment"> *        选项可以通过 | 操作符来组合</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 drawCircle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawFilledEllipse(<span class="keyword">u8g2_uint_t</span> x0, <span class="keyword">u8g2_uint_t</span> y0, <span class="keyword">u8g2_uint_t</span> rx, <span class="keyword">u8g2_uint_t</span> ry, <span class="keyword">uint8_t</span> opt)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>rx*ry 在8位模式的u8g2必须小于512</li></ul><h4 id="u8g2-drawFrame-——-画空心方形"><a href="#u8g2-drawFrame-——-画空心方形" class="headerlink" title="u8g2.drawFrame() —— 画空心方形"></a>u8g2.drawFrame() —— 画空心方形</h4><ul><li><strong>函数说明</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画空心方形，左上角坐标为(x,y),宽度为w，高度为h</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param w 方形的宽度</span></span><br><span class="line"><span class="comment"> * @param h 方形的高度</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawFrame(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w, <span class="keyword">u8g2_uint_t</span> h)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawFrame(<span class="number">3</span>,<span class="number">7</span>,<span class="number">25</span>,<span class="number">15</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawGlyph-——-绘制字体字集的符号"><a href="#u8g2-drawGlyph-——-绘制字体字集的符号" class="headerlink" title="u8g2.drawGlyph() —— 绘制字体字集的符号"></a>u8g2.drawGlyph() —— 绘制字体字集的符号</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制字体字集里面定义的符号</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param encoding 字符的unicode值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setFont</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawGlyph(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">uint16_t</span> encoding)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>U8g2支持16位以内的unicode字符集，也就是说encoding的范围为0-65535，drawGlyph方法只能绘制存在于所使用的字体字集中的unicode值；</li><li>这个绘制方法依赖于当前的字体模式和绘制颜色；</li></ul><h4 id="u8g2-drawHLine-——-绘制水平线"><a href="#u8g2-drawHLine-——-绘制水平线" class="headerlink" title="u8g2.drawHLine() —— 绘制水平线"></a>u8g2.drawHLine() —— 绘制水平线</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制水平线</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param w 水平线的长度</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">void</span> U8G2::drawHLine(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li></ul><h4 id="u8g2-drawLine-——-两点之间绘制线"><a href="#u8g2-drawLine-——-两点之间绘制线" class="headerlink" title="u8g2.drawLine() —— 两点之间绘制线"></a>u8g2.drawLine() —— 两点之间绘制线</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制线，从坐标(x0,y0) 到(x1,y1)</span></span><br><span class="line"><span class="comment"> * @param x0 端点0的x坐标</span></span><br><span class="line"><span class="comment"> * @param y0 端点0的y坐标</span></span><br><span class="line"><span class="comment"> * @param x1 端点1的x坐标</span></span><br><span class="line"><span class="comment"> * @param y1 端点1的y坐标</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">void</span> U8G2::drawLine(<span class="keyword">u8g2_uint_t</span> x0, <span class="keyword">u8g2_uint_t</span> y0, <span class="keyword">u8g2_uint_t</span> x1, <span class="keyword">u8g2_uint_t</span> y1)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawLine(<span class="number">20</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">32</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawPixel-——-绘制像素点"><a href="#u8g2-drawPixel-——-绘制像素点" class="headerlink" title="u8g2.drawPixel() —— 绘制像素点"></a>u8g2.drawPixel() —— 绘制像素点</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制像素点，坐标(x,y)</span></span><br><span class="line"><span class="comment"> * @param x 像素点的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 像素点的y坐标</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setDrawColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawPixel(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li><li>你会发现很多绘制方法的底层都是调用drawPixel，毕竟像素属于最小颗粒度；</li><li>我们可以利用这个绘制方法自定义自己的图形显示；</li></ul><h4 id="u8g2-drawRBox-——-绘制圆角实心方形"><a href="#u8g2-drawRBox-——-绘制圆角实心方形" class="headerlink" title="u8g2.drawRBox() —— 绘制圆角实心方形"></a>u8g2.drawRBox() —— 绘制圆角实心方形</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制圆角实心方形，左上角坐标为(x,y),宽度为w，高度为h，圆角半径为r</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param w 方形的宽度</span></span><br><span class="line"><span class="comment"> * @param h 方形的高度</span></span><br><span class="line"><span class="comment"> * @param r 圆角半径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawRBox(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w, <span class="keyword">u8g2_uint_t</span> h, <span class="keyword">u8g2_uint_t</span> r)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li><li>要求，w &gt;= 2(r+1) 并且 h &gt;= 2(r+1)，这是显而易见的限制；</li></ul><h4 id="u8g2-drawRFrame-——-绘制圆角空心方形"><a href="#u8g2-drawRFrame-——-绘制圆角空心方形" class="headerlink" title="u8g2.drawRFrame() —— 绘制圆角空心方形"></a>u8g2.drawRFrame() —— 绘制圆角空心方形</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制圆角空心方形，左上角坐标为(x,y),宽度为w，高度为h，圆角半径为r</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param w 方形的宽度</span></span><br><span class="line"><span class="comment"> * @param h 方形的高度</span></span><br><span class="line"><span class="comment"> * @param r 圆角半径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawRFrame(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w, <span class="keyword">u8g2_uint_t</span> h, <span class="keyword">u8g2_uint_t</span> r)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong><br>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；<br>要求，w &gt;= 2(r+1) 并且 h &gt;= 2(r+1)，这是显而易见的限制</p></blockquote><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawRFrame(<span class="number">20</span>,<span class="number">15</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">7</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawStr-——-绘制字符串"><a href="#u8g2-drawStr-——-绘制字符串" class="headerlink" title="u8g2.drawStr() —— 绘制字符串"></a>u8g2.drawStr() —— 绘制字符串</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制字符串</span></span><br><span class="line"><span class="comment"> * @param x 左上角的x坐标</span></span><br><span class="line"><span class="comment"> * @param y 左上角的y坐标</span></span><br><span class="line"><span class="comment"> * @param s 绘制字符串内容</span></span><br><span class="line"><span class="comment"> * @return 字符串的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> U8g2::drawStr(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>需要先设置字体，调用setFont方法；</p></li><li><p>这个方法不能绘制encoding超过256的，超过256需要用drawUTF8或者drawGlyph；说白了就是一般用来显示英文字符；</p></li><li><p>x，y属于字符串左下角的坐标；</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">u8g2.drawStr(<span class="number">0</span>,<span class="number">15</span>,<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawTriangle-——-绘制实心三角形"><a href="#u8g2-drawTriangle-——-绘制实心三角形" class="headerlink" title="u8g2.drawTriangle() —— 绘制实心三角形"></a>u8g2.drawTriangle() —— 绘制实心三角形</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制实心三角形，定点坐标分别为(x0,y0),(x1,y1),(x2,y2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawTriangle(<span class="keyword">int16_t</span> x0, <span class="keyword">int16_t</span> y0, <span class="keyword">int16_t</span> x1, <span class="keyword">int16_t</span> y1, <span class="keyword">int16_t</span> x2, <span class="keyword">int16_t</span> y2)</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8g2.drawTriangle(<span class="number">20</span>,<span class="number">5</span>, <span class="number">27</span>,<span class="number">50</span>, <span class="number">5</span>,<span class="number">32</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawUTF8-——-绘制UTF8编码的字符"><a href="#u8g2-drawUTF8-——-绘制UTF8编码的字符" class="headerlink" title="u8g2.drawUTF8() —— 绘制UTF8编码的字符"></a>u8g2.drawUTF8() —— 绘制UTF8编码的字符</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制UTF8编码的字符串</span></span><br><span class="line"><span class="comment"> * @param x 字符串在屏幕上的左下角x坐标</span></span><br><span class="line"><span class="comment"> * @param y 字符串在屏幕上的左下角y坐标</span></span><br><span class="line"><span class="comment"> * @param s 需要绘制的UTF-8编码字符串</span></span><br><span class="line"><span class="comment"> * @return 返回字符串的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> U8g2::drawUTF8(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>使用该方法，有两个前提。首先是你的编译器需要支持UTF-8编码，对于绝大部分Arduino板子已经支持；其次，显示的字符串需要存为“UTF-8”编码，Arduino IDE上默认支持；</p></li><li><p>该方法需要依赖于fontMode（setFont）以及drawing Color，也就是说如果你传进来的字符串编码必须在font定义里面；</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setFont(u8g2_font_unifont_t_symbols);</span><br><span class="line">u8g2.drawUTF8(<span class="number">5</span>, <span class="number">20</span>, <span class="string">"Snowman: ☃"</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawVLine-——-绘制竖直线"><a href="#u8g2-drawVLine-——-绘制竖直线" class="headerlink" title="u8g2.drawVLine() —— 绘制竖直线"></a>u8g2.drawVLine() —— 绘制竖直线</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制竖直线</span></span><br><span class="line"><span class="comment"> * @param x 左上角坐标x</span></span><br><span class="line"><span class="comment"> * @param y 左上角坐标y</span></span><br><span class="line"><span class="comment"> * @param h 高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawVLine(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> h)</span><br></pre></td></tr></table></figure><h4 id="u8g2-drawXBM-drawXBMP-——-绘制图像"><a href="#u8g2-drawXBM-drawXBMP-——-绘制图像" class="headerlink" title="u8g2.drawXBM()/drawXBMP() —— 绘制图像"></a>u8g2.drawXBM()/drawXBMP() —— 绘制图像</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制图像</span></span><br><span class="line"><span class="comment"> * @param x 左上角坐标x</span></span><br><span class="line"><span class="comment"> * @param y 左上角坐标y</span></span><br><span class="line"><span class="comment"> * @param w 图形宽度</span></span><br><span class="line"><span class="comment"> * @param h 图形高度</span></span><br><span class="line"><span class="comment"> * @param bitmap 图形内容</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setBitmapMode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::drawXBM(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w, <span class="keyword">u8g2_uint_t</span> h, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *bitmap)</span><br><span class="line"><span class="keyword">void</span> U8G2::drawXBMP(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y, <span class="keyword">u8g2_uint_t</span> w, <span class="keyword">u8g2_uint_t</span> h, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *bitmap)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>drawXBM和drawXBMP区别在于 XBMP支持PROGMEM；</li></ul><h4 id="u8g2-firstPage-nextPage-——-绘制命令"><a href="#u8g2-firstPage-nextPage-——-绘制命令" class="headerlink" title="u8g2.firstPage()/nextPage() —— 绘制命令"></a>u8g2.firstPage()/nextPage() —— 绘制命令</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制图像</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::firstPage(<span class="keyword">void</span>)</span><br><span class="line"><span class="keyword">uint8_t</span> U8G2::nextPage(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>firstPage方法会把当前页码位置变成0；</p></li><li><p>修改内容处于firstPage和nextPage之间，每次都是重新渲染所有内容；</p></li><li><p><strong>优势点：</strong><br>该方法消耗的ram空间，比sendBuffer消耗的ram空间要少；</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u8g2.firstPage();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* all graphics commands have to appear within the loop body. */</span>    </span><br><span class="line">    u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">    u8g2.drawStr(<span class="number">0</span>,<span class="number">20</span>,<span class="string">"Hello World!"</span>);</span><br><span class="line">  &#125; <span class="keyword">while</span> ( u8g2.nextPage() );</span><br></pre></td></tr></table></figure><ul><li><strong>源码解析</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u8g2_FirstPage</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( u8g2-&gt;is_auto_page_clear )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//清除缓冲区</span></span><br><span class="line">    u8g2_ClearBuffer(u8g2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置当前缓冲区的Tile Row 一个Tile等于8个像素点的高度</span></span><br><span class="line">  u8g2_SetBufferCurrTileRow(u8g2, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">uint8_t</span> u8g2_NextPage(<span class="keyword">u8g2_t</span> *u8g2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> row;</span><br><span class="line">  u8g2_send_buffer(u8g2);</span><br><span class="line">  row = u8g2-&gt;tile_curr_row;</span><br><span class="line">  row += u8g2-&gt;tile_buf_height;</span><br><span class="line">  <span class="keyword">if</span> ( row &gt;= u8g2_GetU8x8(u8g2)-&gt;display_info-&gt;tile_height )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//如果row已经到达最后一行，触发refreshDisplay调用，表示整个页面已经刷完了</span></span><br><span class="line">    u8x8_RefreshDisplay( u8g2_GetU8x8(u8g2) );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( u8g2-&gt;is_auto_page_clear )</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//清除缓冲区</span></span><br><span class="line">    u8g2_ClearBuffer(u8g2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不断更新TileRow 这是非常关键的一步</span></span><br><span class="line">  u8g2_SetBufferCurrTileRow(u8g2, row);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="u8g2-print-——-绘制内容"><a href="#u8g2-print-——-绘制内容" class="headerlink" title="u8g2.print() —— 绘制内容"></a>u8g2.print() —— 绘制内容</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制内容</span></span><br><span class="line"><span class="comment"> * @Note 关联方法  setFont setCursor enableUTF8Print</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::print(...)</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">u8g2.setCursor(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">u8g2.print(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-sendBuffer-——-绘制缓冲区的内容"><a href="#u8g2-sendBuffer-——-绘制缓冲区的内容" class="headerlink" title="u8g2.sendBuffer() —— 绘制缓冲区的内容"></a>u8g2.sendBuffer() —— 绘制缓冲区的内容</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制缓冲区的内容</span></span><br><span class="line"><span class="comment"> * @Note 关联方法  clearBuffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::sendBuffer(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>sendBuffer的RAM占用空间大，需要结合构造器的buffer选项（请继续往下看，先有个概念）使用；</p></li><li><p>不管是fistPage、nextPage还是sendBuffer，都涉及到一个叫做 current page position的概念；</p></li><li><p><strong>源码解析</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u8g2_SendBuffer</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u8g2_send_buffer(u8g2);</span><br><span class="line">  u8x8_RefreshDisplay( u8g2_GetU8x8(u8g2) );  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u8g2_send_tile_row</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2, <span class="keyword">uint8_t</span> src_tile_row, <span class="keyword">uint8_t</span> dest_tile_row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> *ptr;</span><br><span class="line">  <span class="keyword">uint16_t</span> offset;</span><br><span class="line">  <span class="keyword">uint8_t</span> w;</span><br><span class="line">  </span><br><span class="line">  w = u8g2_GetU8x8(u8g2)-&gt;display_info-&gt;tile_width;</span><br><span class="line">  offset = src_tile_row;</span><br><span class="line">  ptr = u8g2-&gt;tile_buf_ptr;</span><br><span class="line">  offset *= w;</span><br><span class="line">  offset *= <span class="number">8</span>;</span><br><span class="line">  ptr += offset;</span><br><span class="line">  u8x8_DrawTile(u8g2_GetU8x8(u8g2), <span class="number">0</span>, dest_tile_row, w, ptr);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  write the buffer to the display RAM. </span></span><br><span class="line"><span class="comment">  For most displays, this will make the content visible to the user.</span></span><br><span class="line"><span class="comment">  Some displays (like the SSD1606) require a u8x8_RefreshDisplay()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u8g2_send_buffer</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2)</span> U8X8_NOINLINE</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u8g2_send_buffer</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> src_row;</span><br><span class="line">  <span class="keyword">uint8_t</span> src_max;</span><br><span class="line">  <span class="keyword">uint8_t</span> dest_row;</span><br><span class="line">  <span class="keyword">uint8_t</span> dest_max;</span><br><span class="line"> </span><br><span class="line">  src_row = <span class="number">0</span>;</span><br><span class="line">  src_max = u8g2-&gt;tile_buf_height;</span><br><span class="line">  dest_row = u8g2-&gt;tile_curr_row;</span><br><span class="line">  dest_max = u8g2_GetU8x8(u8g2)-&gt;display_info-&gt;tile_height;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    u8g2_send_tile_row(u8g2, src_row, dest_row);</span><br><span class="line">    src_row++;</span><br><span class="line">    dest_row++;</span><br><span class="line">  &#125; <span class="keyword">while</span>( src_row &lt; src_max &amp;&amp; dest_row &lt; dest_max );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.clearBuffer();</span><br><span class="line">  <span class="comment">// ... write something to the buffer </span></span><br><span class="line">  u8g2.sendBuffer();</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="显示配置相关函数"><a href="#显示配置相关函数" class="headerlink" title="显示配置相关函数"></a>显示配置相关函数</h3><h4 id="u8g2-getAscent-——-获取基准线以上的高度"><a href="#u8g2-getAscent-——-获取基准线以上的高度" class="headerlink" title="u8g2.getAscent() —— 获取基准线以上的高度"></a>u8g2.getAscent() —— 获取基准线以上的高度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取基准线以上的高度</span></span><br><span class="line"><span class="comment"> * @return 返回高度值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法  setFont getDescent setFontRefHeightAll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int8_t</span> U8G2::getAscent(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>跟字体有关（setFont）；</li></ul><h4 id="u8g2-getDescent-——-获取基准线以下的高度"><a href="#u8g2-getDescent-——-获取基准线以下的高度" class="headerlink" title="u8g2.getDescent() —— 获取基准线以下的高度"></a>u8g2.getDescent() —— 获取基准线以下的高度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取基准线以下的高度</span></span><br><span class="line"><span class="comment"> * @return 返回高度值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法  setFont setFontRefHeightAll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int8_t</span> U8G2::getDescent(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>跟字体有关（setFont）；</li></ul><h4 id="u8g2-getDisplayHeight-——-获取显示器的高度"><a href="#u8g2-getDisplayHeight-——-获取显示器的高度" class="headerlink" title="u8g2.getDisplayHeight() —— 获取显示器的高度"></a>u8g2.getDisplayHeight() —— 获取显示器的高度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取显示器的高度</span></span><br><span class="line"><span class="comment"> * @return 返回高度值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> getDisplayHeight(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><h4 id="u8g2-getDisplayWidth-——-获取显示器的宽度"><a href="#u8g2-getDisplayWidth-——-获取显示器的宽度" class="headerlink" title="u8g2.getDisplayWidth() —— 获取显示器的宽度"></a>u8g2.getDisplayWidth() —— 获取显示器的宽度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取显示器的宽度</span></span><br><span class="line"><span class="comment"> * @return 返回宽度值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> getDisplayWidth(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><h4 id="u8g2-getMaxCharHeight-——-获取当前字体里的最大字符的高度"><a href="#u8g2-getMaxCharHeight-——-获取当前字体里的最大字符的高度" class="headerlink" title="u8g2.getMaxCharHeight() —— 获取当前字体里的最大字符的高度"></a>u8g2.getMaxCharHeight() —— 获取当前字体里的最大字符的高度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前字体里的最大字符的高度</span></span><br><span class="line"><span class="comment"> * @return 返回高度值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setFont</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> getMaxCharHeight(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>每一个字符在font字集中都是一个位图，位图有高度和宽度；</li></ul><h4 id="u8g2-getMaxCharWidth-——-获取当前字体里的最大字符的宽度"><a href="#u8g2-getMaxCharWidth-——-获取当前字体里的最大字符的宽度" class="headerlink" title="u8g2.getMaxCharWidth() —— 获取当前字体里的最大字符的宽度"></a>u8g2.getMaxCharWidth() —— 获取当前字体里的最大字符的宽度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前字体里的最大字符的宽度</span></span><br><span class="line"><span class="comment"> * @return 返回宽度值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setFont</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> getMaxCharWidth(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>每一个字符在font字集中都是一个位图，位图有高度和宽度；</li></ul><h4 id="u8g2-getStrWidth-——-获取字符串的像素宽度"><a href="#u8g2-getStrWidth-——-获取字符串的像素宽度" class="headerlink" title="u8g2.getStrWidth() —— 获取字符串的像素宽度"></a>u8g2.getStrWidth() —— 获取字符串的像素宽度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取字符串的像素宽度</span></span><br><span class="line"><span class="comment"> * @param s 绘制字符串</span></span><br><span class="line"><span class="comment"> * @return 返回字符串的像素宽度值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setFont drawStr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> U8G2::getStrWidth(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>像素宽度和当前font字体有关；</li></ul><h4 id="u8g2-getUTF8Width-——-获取UTF-8字符串的像素宽度"><a href="#u8g2-getUTF8Width-——-获取UTF-8字符串的像素宽度" class="headerlink" title="u8g2.getUTF8Width() —— 获取UTF-8字符串的像素宽度"></a>u8g2.getUTF8Width() —— 获取UTF-8字符串的像素宽度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取UTF-8字符串的像素宽度</span></span><br><span class="line"><span class="comment"> * @param s 绘制字符串</span></span><br><span class="line"><span class="comment"> * @return 返回字符串的像素宽度值</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 setFont drawStr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">u8g2_uint_t</span> U8G2::getUTF8Width(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>像素宽度和当前font字体有关；</li></ul><h4 id="u8g2-setAutoPageClear-——-设置自动清除缓冲区"><a href="#u8g2-setAutoPageClear-——-设置自动清除缓冲区" class="headerlink" title="u8g2.setAutoPageClear() —— 设置自动清除缓冲区"></a>u8g2.setAutoPageClear() —— 设置自动清除缓冲区</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否自动清除缓冲区</span></span><br><span class="line"><span class="comment"> * @param mode 0 表示关闭</span></span><br><span class="line"><span class="comment"> *             1 表示开启，默认是开启</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setAutoPageClear(<span class="keyword">uint8_t</span> mode)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>该方法用于 firstPage 和 nextPage（看上面的源码解析）；</li><li>建议该方法保持默认就好，如果用户禁止了，那么需要自己维护缓冲区的状态或者手动调用clearBuffer；</li></ul><h4 id="u8g2-setBitmapMode-——-设置位图模式"><a href="#u8g2-setBitmapMode-——-设置位图模式" class="headerlink" title="u8g2.setBitmapMode() —— 设置位图模式"></a>u8g2.setBitmapMode() —— 设置位图模式</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置位图模式（定义drawXBM方法是否绘制背景颜色）</span></span><br><span class="line"><span class="comment"> * @param is_transparent</span></span><br><span class="line"><span class="comment"> *         0 绘制背景颜色，不透明，默认是该值</span></span><br><span class="line"><span class="comment"> *         1 不绘制背景颜色，透明</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 drawXBM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setBitmapMode(<span class="keyword">uint8_t</span> is_transparent)</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setDrawColor(<span class="number">1</span>);</span><br><span class="line">u8g2.setBitmapMode(<span class="number">0</span>);</span><br><span class="line">u8g2.drawXBM(<span class="number">4</span>,<span class="number">3</span>, u8g2_logo_97x51_width, u8g2_logo_97x51_height,  u8g2_logo_97x51_bits);</span><br><span class="line">u8g2.drawXBM(<span class="number">12</span>,<span class="number">11</span>, u8g2_logo_97x51_width, u8g2_logo_97x51_height,  u8g2_logo_97x51_bits);</span><br></pre></td></tr></table></figure><h4 id="u8g2-setBusClock-——-设置总线时钟"><a href="#u8g2-setBusClock-——-设置总线时钟" class="headerlink" title="u8g2.setBusClock() —— 设置总线时钟"></a>u8g2.setBusClock() —— 设置总线时钟</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置总线时钟(I2C SPI)</span></span><br><span class="line"><span class="comment"> * @param mode clock_speed 总线时钟频率(Hz)</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setBusClock(<span class="keyword">uint32_t</span> clock_speed);</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>仅仅Arduino平台支持；</li><li>必须在u8g2.begin() 或者 u8g2.initDisplay()之前调用；</li></ul><h4 id="u8g2-setClipWindow-——-设置采集窗口大小"><a href="#u8g2-setClipWindow-——-设置采集窗口大小" class="headerlink" title="u8g2.setClipWindow() —— 设置采集窗口大小"></a>u8g2.setClipWindow() —— 设置采集窗口大小</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置采集窗口，窗口范围从左上角(x0,y0)到右下角(x1,y1)</span></span><br><span class="line"><span class="comment"> * 也就是我们绘制的内容只能在规范范围内显示</span></span><br><span class="line"><span class="comment"> * @param x0 左上角x坐标</span></span><br><span class="line"><span class="comment"> * @param y0 左上角y坐标</span></span><br><span class="line"><span class="comment"> * @param x1 右上角x坐标</span></span><br><span class="line"><span class="comment"> * @param y1 右上角y坐标</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setClipWindow(<span class="keyword">u8g2_uint_t</span> x0, <span class="keyword">u8g2_uint_t</span> y0, <span class="keyword">u8g2_uint_t</span> x1, <span class="keyword">u8g2_uint_t</span> y1 );</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong><br>可以通过 setMaxClipWindow 去掉该限制</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> U8G2::setMaxClipWindow(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setClipWindow(<span class="number">10</span>, <span class="number">10</span>, <span class="number">85</span>, <span class="number">30</span>);</span><br><span class="line">u8g2.setDrawColor(<span class="number">1</span>);</span><br><span class="line">u8g2.drawStr(<span class="number">3</span>, <span class="number">32</span>, <span class="string">"U8g2"</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-setCursor-——-设置绘制光标位置"><a href="#u8g2-setCursor-——-设置绘制光标位置" class="headerlink" title="u8g2.setCursor() —— 设置绘制光标位置"></a>u8g2.setCursor() —— 设置绘制光标位置</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置绘制光标位置(x,y)</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 print</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setCursor(<span class="keyword">u8g2_uint_t</span> x, <span class="keyword">u8g2_uint_t</span> y)</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">u8g2.setCursor(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">u8g2.print(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure><h4 id="u8g2-setDisplayRotation-——-设置显示器的旋转角度"><a href="#u8g2-setDisplayRotation-——-设置显示器的旋转角度" class="headerlink" title="u8g2.setDisplayRotation() —— 设置显示器的旋转角度"></a>u8g2.setDisplayRotation() —— 设置显示器的旋转角度</h4><ul><li><strong>函数说明</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置显示器的旋转角度</span></span><br><span class="line"><span class="comment"> * @param u8g2_cb 旋转选项</span></span><br><span class="line"><span class="comment"> *        U8G2_R0 不做旋转 水平</span></span><br><span class="line"><span class="comment"> *        U8G2_R1 旋转90度</span></span><br><span class="line"><span class="comment"> *        U8G2_R2 旋转180度</span></span><br><span class="line"><span class="comment"> *        U8G2_R3 旋转270度</span></span><br><span class="line"><span class="comment"> *        U8G2_MIRROR 不做旋转 水平，显示内容是镜像的，暂时不理解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDisplayRotation</span><span class="params">(<span class="keyword">const</span> <span class="keyword">u8g2_cb_t</span> *u8g2_cb)</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="u8g2-setDrawColor-——-设置绘制颜色"><a href="#u8g2-setDrawColor-——-设置绘制颜色" class="headerlink" title="u8g2.setDrawColor() —— 设置绘制颜色"></a>u8g2.setDrawColor() —— 设置绘制颜色</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置绘制颜色（暂时还没有具体去了解用法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setDrawColor(<span class="keyword">uint8_t</span> color)</span><br></pre></td></tr></table></figure><h4 id="u8g2-setFont-——-设置字体集"><a href="#u8g2-setFont-——-设置字体集" class="headerlink" title="u8g2.setFont() —— 设置字体集"></a><font color="red">u8g2.setFont() —— 设置字体集</font></h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置字体集（字体集用于字符串绘制方法或者glyph绘制方法）</span></span><br><span class="line"><span class="comment"> * @param font 具体的字体集</span></span><br><span class="line"><span class="comment"> * @Note 关联方法  drawUTF8 drawStr drawGlyph print</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setFont(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *font)</span><br></pre></td></tr></table></figure><p>Font会根据像素点高度做了很多区分，具体font请参考 wiki。<br>如果我们需要用到中文字符，可以在wiki里面搜索一下chinese，你就会发现很多中文font，比如：</p><p>//支持UTF-8或者GB2312编码<br>u8g2_font_wqy15_t_chinese1<br>u8g2_font_wqy15_t_chinese2<br>u8g2_font_wqy15_t_chinese3<br>u8g2_font_wqy12_t_gb2312<br>u8g2_font_wqy12_t_gb2312a<br>……</p><blockquote><p><strong><font color="red">注意点:</font></strong><br>中文字符集消耗内存大，请谨慎使用，可以用在Arduino 101等ram空间比较大的板子上；</p></blockquote><p>Font的命名规则：</p><p><prefix> ‘<em>‘ <name> ‘</name></em>‘ <purpose> <char set=""><br>其中：</char></purpose></prefix></p><ul><li>prefix基本上都是 u8g2；</li><li>name 一般会挂钩上字符像素使用量，比如5X7</li><li>purpose</li></ul><table><thead><tr><th></th><th>描述</th></tr></thead><tbody><tr><td>t</td><td>Transparent font, Do not use a background color.</td></tr><tr><td>h</td><td>All glyphs have common height(所有的图形有通用的高度).</td></tr><tr><td>m</td><td>All glyphs have common height and width (monospace).</td></tr><tr><td>8</td><td>All glyphs fit into a 8x8 pixel box.</td></tr></tbody></table><ul><li>char set</li></ul><table><thead><tr><th></th><th>描述</th></tr></thead><tbody><tr><td>f</td><td>The font includes up to 256 glyphs.</td></tr><tr><td>r</td><td>Only glyphs on the range of the ASCII codes 32 to 127 are included in the font.</td></tr><tr><td>u</td><td>Only glyphs on the range of the ASCII codes 32 to 95 (uppercase chars) are included in the font.</td></tr><tr><td>n</td><td>Only numbers and extra glyphs for writing date and time strings are included in the font.</td></tr><tr><td>…</td><td>Other custom character list.</td></tr></tbody></table><blockquote><p><strong><font color="red">注意点:</font></strong><br>U8G2库提供的font非常多，博主也暂时消化不了太多。如果我们使用中文的话，就去看看中文font就好；</p></blockquote><blockquote><p><strong>示例字体</strong></p></blockquote><ul><li>u8g2_font_5x7_tr</li><li>u8g2_font_pressstart2p_8u</li></ul><h4 id="u8g2-setFontDirection-——-设置字体方向"><a href="#u8g2-setFontDirection-——-设置字体方向" class="headerlink" title="u8g2.setFontDirection() —— 设置字体方向"></a>u8g2.setFontDirection() —— 设置字体方向</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义字符串绘制或者图形绘制的方向</span></span><br><span class="line"><span class="comment"> * @param dir 方向</span></span><br><span class="line"><span class="comment"> * @param 关联方法 drawStr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setFontDirection(<span class="keyword">uint8_t</span> dir)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>dir参数</li></ul><table><thead><tr><th>Argument</th><th>String Rotation</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>0 degree</td><td>Left to right</td></tr><tr><td>1</td><td>90 degree</td><td>Top to down</td></tr><tr><td>2</td><td>180 degree</td><td>Right to left</td></tr><tr><td>3</td><td>270 degree</td><td>Down to top</td></tr></tbody></table><ul><li><strong>示例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setFont(u8g2_font_ncenB14_tf);</span><br><span class="line">u8g2.setFontDirection(<span class="number">0</span>);</span><br><span class="line">u8g2.drawStr(<span class="number">15</span>, <span class="number">20</span>, <span class="string">"Abc"</span>);</span><br><span class="line">u8g2.setFontDirection(<span class="number">1</span>);</span><br><span class="line">u8g2.drawStr(<span class="number">15</span>, <span class="number">20</span>, <span class="string">"Abc"</span>);</span><br></pre></td></tr></table></figure><h3 id="缓存相关函数"><a href="#缓存相关函数" class="headerlink" title="缓存相关函数"></a>缓存相关函数</h3><p>缓存相关函数，一般不会去操作，了解即可；</p><h4 id="u8g2-getBufferPtr-——-获取缓存空间的地址"><a href="#u8g2-getBufferPtr-——-获取缓存空间的地址" class="headerlink" title="u8g2.getBufferPtr() —— 获取缓存空间的地址"></a>u8g2.getBufferPtr() —— 获取缓存空间的地址</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓存空间的地址</span></span><br><span class="line"><span class="comment"> * @return 返回缓存空间起始地址</span></span><br><span class="line"><span class="comment"> * @Note 关联方法 getBufferTileHeight, getBufferTileWidth, clearBuffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> *U8G2::getBufferPtr(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>缓存大小等于 8 * u8g2.getBufferTileHeight() * u8g2.getBufferTileWidth().</li></ul><h4 id="u8g2-getBufferTileHeight-——-获取缓冲区的Tile高度"><a href="#u8g2-getBufferTileHeight-——-获取缓冲区的Tile高度" class="headerlink" title="u8g2.getBufferTileHeight() —— 获取缓冲区的Tile高度"></a>u8g2.getBufferTileHeight() —— 获取缓冲区的Tile高度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区的Tile高度</span></span><br><span class="line"><span class="comment"> * @return 返回高度值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> U8G2::getBufferTileHeight(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>一个tile等于8个像素点.</li></ul><h4 id="u8g2-getBufferTileWidth-——-获取缓冲区的Tile宽度"><a href="#u8g2-getBufferTileWidth-——-获取缓冲区的Tile宽度" class="headerlink" title="u8g2.getBufferTileWidth() —— 获取缓冲区的Tile宽度"></a>u8g2.getBufferTileWidth() —— 获取缓冲区的Tile宽度</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区的Tile宽度</span></span><br><span class="line"><span class="comment"> * @return 返回宽度值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> U8G2::getBufferTileWidth(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>一个tile等于8个像素点.</li></ul><h4 id="u8g2-getBufferCurrTileRow-——-获取缓冲区的当前Tile-row"><a href="#u8g2-getBufferCurrTileRow-——-获取缓冲区的当前Tile-row" class="headerlink" title="u8g2.getBufferCurrTileRow() —— 获取缓冲区的当前Tile row"></a>u8g2.getBufferCurrTileRow() —— 获取缓冲区的当前Tile row</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区的当前Tile row行数</span></span><br><span class="line"><span class="comment"> * @return 返回当前的tilerow</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> U8G2::getBufferCurrTileRow(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>这个方法跟我们上面说到的page position相关.</li></ul><h4 id="u8g2-setBufferCurrTileRow-——-设置缓冲区的当前Tile-row"><a href="#u8g2-setBufferCurrTileRow-——-设置缓冲区的当前Tile-row" class="headerlink" title="u8g2.setBufferCurrTileRow() —— 设置缓冲区的当前Tile row"></a>u8g2.setBufferCurrTileRow() —— 设置缓冲区的当前Tile row</h4><ul><li><strong>函数说明</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置缓冲区的当前Tile row</span></span><br><span class="line"><span class="comment"> * @param 当前的tilerow</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> U8G2::setBufferCurrTileRow(<span class="keyword">uint8_t</span>  row)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li><p>在 firstPage/nextPage 循环时，由于底层调用了setBufferCurrTileRow，所以尽量不要自己手动调用该方法；</p></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u8g2.setBufferCurrTileRow(<span class="number">0</span>);       <span class="comment">// let y=0 be the topmost row of the buffer</span></span><br><span class="line">u8g2.clearBuffer();</span><br><span class="line">u8g2.setFont(u8g2_font_helvB08_tr);</span><br><span class="line">u8g2.drawStr(<span class="number">2</span>, <span class="number">8</span>, <span class="string">"abcdefg"</span>);</span><br><span class="line"> </span><br><span class="line">u8g2.setBufferCurrTileRow(<span class="number">2</span>);   <span class="comment">// write the buffer to tile row 2 (y=16) on the display</span></span><br><span class="line">u8g2.sendBuffer();</span><br><span class="line">u8g2.setBufferCurrTileRow(<span class="number">4</span>);   <span class="comment">// write the same buffer to tile row 4 (y=32) on the display</span></span><br><span class="line">u8g2.sendBuffer();</span><br></pre></td></tr></table></figure><h2 id="如何运用U8G2库"><a href="#如何运用U8G2库" class="headerlink" title="如何运用U8G2库"></a>如何运用U8G2库</h2><p>构建具体的OLED驱动可分为以下几个顺序步骤：</p><ol><li>区分显示器</li><li>选择物理总线方式</li><li>区分数字连线</li><li>U8g2初始化</li><li>U8g2绘制模式</li></ol><h3 id="区分显示器"><a href="#区分显示器" class="headerlink" title="区分显示器"></a>区分显示器</h3><p>首先，你需要知道OLED显示器的控制器型号以及屏幕大小。举个例子，博主手上有一块SSD1306 128X64的OLED，那么它的控制器就是SSD1306，屏幕大小是128X64。<br>其次，你所选择的OLED必须在U8g2库所支持的OLED列表中，具体可参考<a href="https://github.com/olikraus/u8g2/wiki/u8g2setupcpp" target="_blank" rel="noopener">链接地址</a>。</p><h3 id="选择物理总线方式"><a href="#选择物理总线方式" class="headerlink" title="选择物理总线方式"></a>选择物理总线方式</h3><p> 图像信息是通过物理总线方式发给OLED显示器。通常，我们的总线包括：</p><ul><li>3SPI，3-wire SPI：串行外围接口，依靠三个控制信号，Clock、Data、CS；</li><li>4SPI, 4-Wire SPI，跟3SPI一样，只是额外多了一条数据命令线，经常叫做D/C;</li><li>I2C, IIC or TWI: SCL SDA;</li><li>8080:A 8-Bit bus which requires 8 data lines, chip select and a write strobe signa</li><li>6800: Another 8-Bit bus, but with a different protocol.<br>具体的OLED使用什么物理总线，需要查阅各自的数据手册。比如，SSD1306就是IIC。</li></ul><h3 id="区分数字连线"><a href="#区分数字连线" class="headerlink" title="区分数字连线"></a>区分数字连线</h3><p>知道了物理连线模式之后，我们一般都是把OLED连接到Arduino Board的输出引脚，也就是软件模拟具体总线协议。当然，如果有现成的物理总线端口那就更好了。</p><h3 id="U8g2初始化"><a href="#U8g2初始化" class="headerlink" title="U8g2初始化"></a>U8g2初始化</h3><p>经历以上三步之后，我们就可以开始初始化出具体的OLED驱动了。比如，博主的IIC SSD1306 128X64 的OLED，就可以用以下初始化构造器（Builder设计模式，有空可以去了解一下）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_1_SW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* clock=*/</span> SCL, <span class="comment">/* data=*/</span> SDA, <span class="comment">/* reset=*/</span> U8X8_PIN_NONE)</span></span>;   <span class="comment">// All Boards without Reset of the Display</span></span><br></pre></td></tr></table></figure><p>当然SSD1306还有其他构造器（具体可以参考<a href="https://github.com/olikraus/u8g2/wiki/u8g2setupcpp" target="_blank" rel="noopener">wiki</a>）：</p><table><thead><tr><th>Controller “ssd1306”</th><th>Display “128x64_noname”    Descirption</th></tr></thead><tbody><tr><td>U8G2_SSD1306_128X64_NONAME_1_4W_SW_SPI(rotation, clock, data, cs, dc [, reset])</td><td>page buffer, size = 128 bytes</td></tr><tr><td>U8G2_SSD1306_128X64_NONAME_2_4W_SW_SPI(rotation, clock, data, cs, dc [, reset])</td><td>page buffer, size = 256 bytes</td></tr><tr><td>U8G2_SSD1306_128X64_NONAME_F_4W_SW_SPI(rotation, clock, data, cs, dc [, reset])</td><td>full framebuffer, size = 1024 bytes</td></tr><tr><td>U8G2_SSD1306_128X64_NONAME_1_4W_HW_SPI(rotation, cs, dc [, reset])</td><td>page buffer, size = 128 bytes</td></tr></tbody></table><p> 那么，我们这里就需要重点讲述一下构造器的规则。<br> 构造器的名字包括以下几方面：</p><table><thead><tr><th>No</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>1</td><td>Prefix</td><td>U8G2</td></tr><tr><td>2</td><td>Display Controller</td><td>SSD1306</td></tr><tr><td>3</td><td>Display Name</td><td>128X64_NONAME</td></tr><tr><td>4</td><td>Buffer Size</td><td>1, 2 or F (full frame buffer)</td></tr><tr><td>5</td><td>Communication</td><td>4W_SW_SPI</td></tr></tbody></table><p>它们之间使用”_”连接起来。其中：</p><ul><li>BufferSize，缓存大小</li></ul><table><thead><tr><th>BufferSize</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>保持一页的缓冲区，用于firstPage/nextPage的PageMode.</td></tr><tr><td>2</td><td>保持两页的缓冲区，用于firstPage/nextPage的PageMode.</td></tr><tr><td>F</td><td>获取整个屏幕的缓冲区，ram消耗大，一般用在ram空间比较大的arduino板子.</td></tr></tbody></table><ul><li>Communication，通信协议</li></ul><p>| Communication     | Description |<br>| 4W_SW_SPI |    4-wire (clock, data, cs and dc) software emulated SPI |<br>| 4W_HW_SPI |    4-wire (clock, data, cs and dc) hardware SPI (based on Arduino SPI library) |<br>| 2ND_4W_HW_SPI |    If supported, second 4-wire hardware SPI (based on Arduino SPI library) |<br>| 3W_SW_SPI    | 3-wire (clock, data and cs) software emulated SPI |<br>| SW_I2C    | Software emulated I2C/TWI |<br>| HW_I2C    | Hardware I2C based on the Arduino Wire library |<br>| 2ND_HW_I2C    | If supported, use second hardware I2C (Arduino Wire lib) |<br>| 6800 |    8-bit parallel interface, 6800 protocol |<br>| 8080 |    8-bit parallel interface, 8080 protocol |</p><ul><li>Rotation （软件模拟总线前提下的构造器的第一个参数）</li></ul><p>| Rotation/Mirror |    Description |<br>| U8G2_R0    | No rotation, landscape |<br>| U8G2_R1    | 90 degree clockwise rotation |<br>| U8G2_R2    | 180 degree clockwise rotation |<br>| U8G2_R3    | 270 degree clockwise rotation |<br>| U8G2_MIRROR    | No rotation, landscape, display content is mirrored (v2.6.x) |</p><p>一个完整的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SPI.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Wire.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">U8G2_ST7920_128X64_1_SW_SPI <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="number">13</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.begin();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.firstPage();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">    u8g2.drawStr(<span class="number">0</span>,<span class="number">24</span>,<span class="string">"Hello World!"</span>);</span><br><span class="line">  &#125; <span class="keyword">while</span> ( u8g2.nextPage() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们来看看到底构造器里面做了什么操作？还是以博主使用的SSD1306 128X64为例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SSD1306 4线软件模拟SPI</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">U8G2_SSD1306_128X64_NONAME_1_4W_SW_SPI(.....)</span><br></pre></td></tr></table></figure><ul><li><strong>类定义：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SSD1306构造器，继承U8G2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">U8G2_SSD1306_128X64_NONAME_1_4W_SW_SPI</span> :</span> <span class="keyword">public</span> U8G2 &#123;</span><br><span class="line">  <span class="keyword">public</span>: U8G2_SSD1306_128X64_NONAME_1_4W_SW_SPI(<span class="keyword">const</span> <span class="keyword">u8g2_cb_t</span> *rotation, <span class="keyword">uint8_t</span> clock, <span class="keyword">uint8_t</span> data, <span class="keyword">uint8_t</span> cs, <span class="keyword">uint8_t</span> dc, <span class="keyword">uint8_t</span> reset = U8X8_PIN_NONE) : U8G2() &#123;</span><br><span class="line">    <span class="comment">//配置SSD1306</span></span><br><span class="line">    u8g2_Setup_ssd1306_128x64_noname_1(&amp;u8g2, rotation, u8x8_byte_arduino_4wire_sw_spi, u8x8_gpio_and_delay_arduino);</span><br><span class="line">    <span class="comment">//设置通信协议</span></span><br><span class="line">    u8x8_SetPin_4Wire_SW_SPI(getU8x8(), clock, data, cs, dc, reset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面代码看出，默认调用了父类U8G2的构造函数，我们看看它里面做了什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">U8G2</span> :</span> <span class="keyword">public</span> Print</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">u8g2_t</span> u8g2;</span><br><span class="line">    u8x8_char_cb cpp_next_cb; <span class="comment">/*  the cpp interface has its own decoding function for the Arduino print command */</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">u8g2_uint_t</span> tx, ty;</span><br><span class="line">  </span><br><span class="line">    U8G2(<span class="keyword">void</span>) &#123; </span><br><span class="line">          <span class="comment">//设置Arduino print函数的解码方法，这里是ASCII，当然也有UTF-8</span></span><br><span class="line">          cpp_next_cb = u8x8_ascii_next; </span><br><span class="line">          <span class="comment">//屏幕初始化</span></span><br><span class="line">          home(); </span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br></pre></td></tr></table></figure><ul><li>U8G2类构造函数主要是定义好解码方法以及初始化屏幕（包括重置原点）；</li></ul><p>    然后我们看看，u8g2_Setup_ssd1306_128x64_noname_1做了什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u8g2_Setup_ssd1306_128x64_noname_1</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2, <span class="keyword">const</span> <span class="keyword">u8g2_cb_t</span> *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> tile_buf_height;</span><br><span class="line">  <span class="comment">//定义好缓存空间 记住 这里是 1 page mode</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *buf;</span><br><span class="line">  <span class="comment">//配置屏幕</span></span><br><span class="line">  u8g2_SetupDisplay(u8g2, u8x8_d_ssd1306_128x64_noname, u8x8_cad_001, byte_cb, gpio_and_delay_cb);</span><br><span class="line">  <span class="comment">//生成buf 这里是128 bytes</span></span><br><span class="line">  buf = u8g2_m_16_8_1(&amp;tile_buf_height);</span><br><span class="line">  <span class="comment">//初始化buf</span></span><br><span class="line">  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*============================================*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This procedure is called after setting up the display (u8x8 structure).</span></span><br><span class="line"><span class="comment">  --&gt; This is the central init procedure for u8g2 object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u8g2_SetupBuffer</span><span class="params">(<span class="keyword">u8g2_t</span> *u8g2, <span class="keyword">uint8_t</span> *buf, <span class="keyword">uint8_t</span> tile_buf_height, u8g2_draw_ll_hvline_cb ll_hvline_cb, <span class="keyword">const</span> <span class="keyword">u8g2_cb_t</span> *u8g2_cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u8g2-&gt;font = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//u8g2-&gt;kerning = NULL;</span></span><br><span class="line">  <span class="comment">//u8g2-&gt;get_kerning_cb = u8g2_GetNullKerning;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//u8g2-&gt;ll_hvline = u8g2_ll_hvline_vertical_top_lsb;</span></span><br><span class="line">  u8g2-&gt;ll_hvline = ll_hvline_cb;</span><br><span class="line">  </span><br><span class="line">  u8g2-&gt;tile_buf_ptr = buf;</span><br><span class="line">  u8g2-&gt;tile_buf_height = tile_buf_height;</span><br><span class="line">  </span><br><span class="line">  u8g2-&gt;tile_curr_row = <span class="number">0</span>;<span class="comment">//页码 这是一个很重要的参数</span></span><br><span class="line">  </span><br><span class="line">  u8g2-&gt;font_decode.is_transparent = <span class="number">0</span>; <span class="comment">/* issue 443 */</span></span><br><span class="line">  u8g2-&gt;bitmap_transparency = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  u8g2-&gt;draw_color = <span class="number">1</span>;</span><br><span class="line">  u8g2-&gt;is_auto_page_clear = <span class="number">1</span>;<span class="comment">//自动清除</span></span><br><span class="line">  </span><br><span class="line">  u8g2-&gt;cb = u8g2_cb;</span><br><span class="line">  u8g2-&gt;cb-&gt;update_dimension(u8g2);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> U8G2_WITH_CLIP_WINDOW_SUPPORT</span></span><br><span class="line">  u8g2_SetMaxClipWindow(u8g2);      <span class="comment">/* assign a clip window and call the update() procedure */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  u8g2-&gt;cb-&gt;update_page_win(u8g2);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  u8g2_SetFontPosBaseline(u8g2);  <span class="comment">/* issue 195 */</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> U8G2_WITH_FONT_ROTATION  </span></span><br><span class="line">  u8g2-&gt;font_decode.dir = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以总结几点：</p><ul><li>配置初始化屏幕</li><li>配置初始化缓冲区</li></ul><blockquote><p><strong><font color="red">注意点:</font></strong></p></blockquote><ul><li>上面讲解涉及到了绘制模式，请参考下一节；</li></ul><h3 id="U8g2绘制模式"><a href="#U8g2绘制模式" class="headerlink" title="U8g2绘制模式"></a>U8g2绘制模式</h3><h3 id="U8g2支持三种绘制模式："><a href="#U8g2支持三种绘制模式：" class="headerlink" title="U8g2支持三种绘制模式："></a>U8g2支持三种绘制模式：</h3><ul><li>Full screen buffer mode，全屏缓存模式</li><li>Page mode (This is the U8glib picture loop) 分页模式</li><li>U8x8, character only mode 仅仅支持普通字符</li></ul><h3 id="Full-screen-buffer-mode"><a href="#Full-screen-buffer-mode" class="headerlink" title="Full screen buffer mode"></a>Full screen buffer mode</h3><ul><li><strong>特点：</strong></li></ul><p>绘制速度快<br>所有的绘制方法都可以使用<br>需要大量的ram空间</p><ul><li><strong>构造器：</strong></li></ul><p>构造器必须带有F，比如：<br>U8G2_ST7920_128X64_F_SW_SPI(rotation, clock, data, cs [, reset])</p><ul><li><strong>用法：</strong></li></ul><ol><li>清除缓冲区 u8g2.clearBuffer()</li><li>操作一些绘制方法</li><li>发送缓冲区的内容到显示器 u8g2.sendBuffer().</li></ol><ul><li><strong>示例代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.begin();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.clearBuffer();</span><br><span class="line">  u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">  u8g2.drawStr(<span class="number">0</span>,<span class="number">20</span>,<span class="string">"Hello World!"</span>);</span><br><span class="line">  u8g2.sendBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Page-mode"><a href="#Page-mode" class="headerlink" title="Page mode"></a>Page mode</h3><ul><li><strong>特点：</strong></li></ul><p>绘制速度慢<br>所有的绘制方法都可以使用<br>需要少量的ram空间</p><ul><li><p><strong>构造器：</strong></p></li><li><p>构造器必须带有“1”或者2，比如：<br>U8G2_ST7920_128X64_ 1 _SW_SPI(rotation, clock, data, cs [, reset])</p></li><li><p><strong>用法：</strong></p></li></ul><ol><li>调用 u8g2.firstPage()</li><li>开始一个 do while 循环</li><li>在循环内部 操作一些绘制方法</li><li>不断判断 u8g2.nextPage()</li></ol><ul><li><strong>示例代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.begin();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.firstPage();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    u8g2.setFont(u8g2_font_ncenB14_tr);</span><br><span class="line">    u8g2.drawStr(<span class="number">0</span>,<span class="number">24</span>,<span class="string">"Hello World!"</span>);</span><br><span class="line">  &#125; <span class="keyword">while</span> ( u8g2.nextPage() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="U8x8-character-mode"><a href="#U8x8-character-mode" class="headerlink" title="U8x8 character mode"></a>U8x8 character mode</h3><ul><li><p><strong>特点：</strong></p></li><li><p>绘制速度快</p></li><li><p>并不是对所有的显示器都有效</p></li><li><p>图形绘制不可用</p></li><li><p>不需要ram空间</p></li><li><p><strong>构造器：</strong></p></li><li><p>使用U8X8构造器，比如：<br>U8X8_ST7565_EA_DOGM128_4W_SW_SPI(clock, data, cs, dc [, reset])</p></li><li><p><strong>用法：</strong></p></li><li><p>所有绘制命令是直接把数据写到显示器</p></li><li><p><strong>示例代码</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8x8.begin();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8x8.setFont(u8x8_font_chroma48medium8_r);</span><br><span class="line">  u8x8.drawString(<span class="number">0</span>,<span class="number">1</span>,<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;U8g2简介&quot;&gt;&lt;a href=&quot;#U8g2简介&quot; class=&quot;headerlink&quot; title=&quot;U8g2简介&quot;&gt;&lt;/a&gt;U8g2简介&lt;/h2&gt;&lt;p&gt;U8g2是嵌入式设备的单色图形库，一句话简单明了。主要应用于嵌入式设备，包括我们常见的单片机。
    &lt;/p&gt;
    
    </summary>
    
    
      <category term="OLED" scheme="https://zhaolilong.com/tags/OLED/"/>
    
      <category term="API参考" scheme="https://zhaolilong.com/tags/API%E5%8F%82%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>NodeMCU使用OLED</title>
    <link href="https://zhaolilong.com/2020/05/09/NodeMCU%E4%BD%BF%E7%94%A8OLED/"/>
    <id>https://zhaolilong.com/2020/05/09/NodeMCU使用OLED/</id>
    <published>2020-05-09T01:08:58.000Z</published>
    <updated>2020-05-09T07:28:43.547Z</updated>
    
    <content type="html"><![CDATA[<p>硬件准备：</p><ol><li><p>NodeMCU</p></li><li><p>I2c-12864-oled液晶屏模块 0.96寸 （12864就是128*64点阵的屏幕，所以叫12864！）<br><img src="/2020/05/09/NodeMCU使用OLED/1588986804.jpg" alt=""></p></li><li><p>母对母杜邦线4根</p></li><li><p>microUSB口-用来连接ESP8266</p></li></ol><p>软件准备：<br>Win：<a href="https://github.com/nodemcu/nodemcu-flasher/tree/master/Win64/Release" target="_blank" rel="noopener">https://github.com/nodemcu/nodemcu-flasher/tree/master/Win64/Release</a><br>Mac：<a href="https://github.com/marcelstoer/nodemcu-pyflasher/releases" target="_blank" rel="noopener">https://github.com/marcelstoer/nodemcu-pyflasher/releases</a></p><a id="more"></a><h2 id="给NodeMCU刷入固件"><a href="#给NodeMCU刷入固件" class="headerlink" title="给NodeMCU刷入固件"></a>给NodeMCU刷入固件</h2><ol><li>在nodemcu官网<a href="https://nodemcu-build.com/中下载固件" target="_blank" rel="noopener">https://nodemcu-build.com/中下载固件</a></li></ol><table><thead><tr><th>基本信息</th><th>参数</th></tr></thead><tbody><tr><td>驱动电压</td><td>3.3~5V</td></tr><tr><td>分辨率</td><td>128x64</td></tr><tr><td>驱动接口</td><td>I2C</td></tr><tr><td>I2C地址</td><td>0x3c(默认)\0x3d可选</td></tr></tbody></table><p><img src="/2020/05/09/NodeMCU使用OLED/1588987148.png" alt=""><br>构建模块中勾选I2C和U8G2。<br>字体需要勾选中文，默认不支持中文字体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u8g2_font_wqy15_t_chinese1</span><br><span class="line">u8g2_font_wqy15_t_chinese2</span><br><span class="line">u8g2_font_wqy15_t_chinese3</span><br></pre></td></tr></table></figure><p><img src="/2020/05/09/NodeMCU使用OLED/1588987612.png" alt=""><br><img src="/2020/05/09/NodeMCU使用OLED/1588988007.png" alt=""></p><p>在邮箱中查看<br><img src="/2020/05/09/NodeMCU使用OLED/1588988246.png" alt=""></p><p>一般下载integer的固件</p><h2 id="用ESPFlashDownloadTool写入固件"><a href="#用ESPFlashDownloadTool写入固件" class="headerlink" title="用ESPFlashDownloadTool写入固件"></a>用ESPFlashDownloadTool写入固件</h2><h2 id="按照接线图进行接线"><a href="#按照接线图进行接线" class="headerlink" title="按照接线图进行接线"></a>按照接线图进行接线</h2><p><img src="/2020/05/09/NodeMCU使用OLED/1588988622.png" alt=""></p><table><thead><tr><th>NodeMCU</th><th>OLED</th></tr></thead><tbody><tr><td>D5</td><td>SDA</td></tr><tr><td>D6</td><td>SCL</td></tr><tr><td>GND</td><td>GND</td></tr><tr><td>3V</td><td>VCC</td></tr></tbody></table><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//"hello world" test</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.begin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g2.clearBuffer();                   <span class="comment">// clear the internal memory</span></span><br><span class="line">  u8g2.setFont(u8g2_font_ncenB14_tr);   <span class="comment">// choose a suitable font</span></span><br><span class="line">  u8g2.drawStr(<span class="number">0</span>,<span class="number">20</span>,<span class="string">"Hello World!"</span>);    <span class="comment">// write something to the internal memory</span></span><br><span class="line">  u8g2.sendBuffer();                    <span class="comment">// transfer internal memory to the display</span></span><br><span class="line">  delay(<span class="number">1000</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;硬件准备：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;NodeMCU&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I2c-12864-oled液晶屏模块 0.96寸 （12864就是128*64点阵的屏幕，所以叫12864！）&lt;br&gt;&lt;img src=&quot;/2020/05/09/NodeMCU使用OLED/1588986804.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;母对母杜邦线4根&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;microUSB口-用来连接ESP8266&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;软件准备：&lt;br&gt;Win：&lt;a href=&quot;https://github.com/nodemcu/nodemcu-flasher/tree/master/Win64/Release&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/nodemcu/nodemcu-flasher/tree/master/Win64/Release&lt;/a&gt;&lt;br&gt;Mac：&lt;a href=&quot;https://github.com/marcelstoer/nodemcu-pyflasher/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/marcelstoer/nodemcu-pyflasher/releases&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeMCU" scheme="https://zhaolilong.com/tags/NodeMCU/"/>
    
      <category term="OLED" scheme="https://zhaolilong.com/tags/OLED/"/>
    
  </entry>
  
  <entry>
    <title>Linux查找并终止指定进程</title>
    <link href="https://zhaolilong.com/2020/04/29/Linux%E6%9F%A5%E6%89%BE%E5%B9%B6%E7%BB%88%E6%AD%A2%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>https://zhaolilong.com/2020/04/29/Linux查找并终止指定进程/</id>
    <published>2020-04-29T02:28:23.000Z</published>
    <updated>2020-04-29T02:29:05.546Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps -ef | grep  php | grep -v ‘grep’ | awk ‘{print $2}’| xargs kill -9</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps -ef | grep  php | grep -v ‘grep’ | awk ‘{print $2}’| xargs kill -9&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阿里云ECS中的CentOS7变为只读的解决方法</title>
    <link href="https://zhaolilong.com/2020/04/29/%E9%98%BF%E9%87%8C%E4%BA%91ECS%E4%B8%AD%E7%9A%84CentOS7%E5%8F%98%E4%B8%BA%E5%8F%AA%E8%AF%BB%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://zhaolilong.com/2020/04/29/阿里云ECS中的CentOS7变为只读的解决方法/</id>
    <published>2020-04-29T01:34:24.000Z</published>
    <updated>2020-04-29T03:05:31.274Z</updated>
    
    <content type="html"><![CDATA[<p>升级阿里云ECS配置及带宽后，CentOS 7系统变为只读状态，导致nginx、MySQL等服务无法启动。</p><a id="more"></a><p>解决方案如下：</p><ul><li>在终端中输入mount，查看ro挂载的分区,如果发现有ro，就重新mount</li></ul><ol><li><p>mount方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/sda1</span><br><span class="line">mount /dev/sda1 /boot</span><br><span class="line">如果发现有提示“device is busy”，找到是什么进程使得他busy</span><br><span class="line">fuser -m /boot 将会显示使用这个模块的pid</span><br><span class="line">fuser -mk /boot 将会直接kill那个pid</span><br><span class="line">然后重新mount即可。</span><br></pre></td></tr></table></figure></li><li><p>remount方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -o rw,remount /boot</span><br><span class="line">或者mount -o remount,rw /boot</span><br></pre></td></tr></table></figure></li><li><p>重启</p></li><li><p>使用用 fsck – y /dev/hdc6 (/dev/hdc6指你需要修复的分区) 来修复文件系统</p></li><li><p>查看文件系统状态/etc/fstab发现里面是空的，于是找到了两种解决方案：</p></li><li><p>重新挂载系统<br>#mount -o remount,rw /                            //这样每次重新开启虚拟机都要运行一次该命令！</p></li><li><p>将fstab写入正确内容<br><code>cat /etc/fstab</code></p><p>#</p><h1 id="etc-fstab"><a href="#etc-fstab" class="headerlink" title="/etc/fstab"></a>/etc/fstab</h1><h1 id="Created-by-anaconda-on-Sun-Oct-15-15-19-00-2017"><a href="#Created-by-anaconda-on-Sun-Oct-15-15-19-00-2017" class="headerlink" title="Created by anaconda on Sun Oct 15 15:19:00 2017"></a>Created by anaconda on Sun Oct 15 15:19:00 2017</h1><p>#</p><h1 id="Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’"><a href="#Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’" class="headerlink" title="Accessible filesystems, by reference, are maintained under ‘/dev/disk’"></a>Accessible filesystems, by reference, are maintained under ‘/dev/disk’</h1><h1 id="See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info"><a href="#See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info" class="headerlink" title="See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info"></a>See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</h1><p>#<br>UUID=00e25cc9-6880-442b-b430-62bb8061394d /                       ext4    defaults        1 1<br>/www/swap    swap    swap    defaults    0 0</p></li></ol><p><code>lsblk -f</code></p><p>NAME   FSTYPE LABEL UUID                                 MOUNTPOINT<br>vda<br>└─vda1 ext4         eb448abb-3012-4d8d-bcde-94434d586a31 /</p><p>fstab实际挂载点与打印的挂载点不一致，则修改/etc/fstabw文件中的挂载点为打印挂载点.</p><p>重启即可！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级阿里云ECS配置及带宽后，CentOS 7系统变为只读状态，导致nginx、MySQL等服务无法启动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="阿里云ECS" scheme="https://zhaolilong.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91ECS/"/>
    
      <category term="Linux" scheme="https://zhaolilong.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>实例学习Metal-参考书目</title>
    <link href="https://zhaolilong.com/2020/04/12/%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0Metal-%E5%8F%82%E8%80%83%E4%B9%A6%E7%9B%AE/"/>
    <id>https://zhaolilong.com/2020/04/12/实例学习Metal-参考书目/</id>
    <published>2020-04-11T16:00:00.000Z</published>
    <updated>2020-03-13T04:56:02.207Z</updated>
    
    <content type="html"><![CDATA[<p>Barrett, Sean. 2014. “stb Single-File Public Domain Libraries for C/C++.” <a href="https://github" target="_blank" rel="noopener">https://github</a>. com/nothings/stb.<br><br><br>Blinn, James F. 1977. “Models of Light Reflection for Computer Synthesized Pictures.” In Proceedings of the 4th Annual Conference on Computer Graphics and Interactive Techniques, 192–98. SIGGRAPH ’77. New York, NY, USA: ACM. doi:10.1145/563858.563893.<br><br></p><a id="more"></a><p>Barrett, Sean. 2014. “stb Single-File Public Domain Libraries for C/C++.” <a href="https://github" target="_blank" rel="noopener">https://github</a>. com/nothings/stb.<br><br><br>Blinn, James F. 1977. “Models of Light Reflection for Computer Synthesized Pictures.” In Proceedings of the 4th Annual Conference on Computer Graphics and Interactive Techniques, 192–98. SIGGRAPH ’77. New York, NY, USA: ACM. doi:10.1145/563858.563893.<br><br><br>Boxley, Paul. 2011. “Terrain Generation with the Diamond Square Algorithm.” http: //<a href="http://www.paulboxley.com/blog/2011/03/terrain-generation-mark-one" target="_blank" rel="noopener">www.paulboxley.com/blog/2011/03/terrain-generation-mark-one</a>.<br><br><br>Carpenter, Loren. 1984. “The A-Buffer, an Antialiased Hidden Surface Method.” In Pro- ceedings of the 11th Annual Conference on Computer Graphics and Interactive Techniques, 103–8. SIGGRAPH ’84. New York, NY, USA: ACM. doi:10.1145/800031.808585.<br><br><br>Esfahbod, Behdad. 2014. “GLyphy.” <a href="https://github.com/behdad/glyphy" target="_blank" rel="noopener">https://github.com/behdad/glyphy</a>.<br><br><br>Giesen, Fabien. 2011. “A Trip Through the Graphics Pipeline 2011, Part 7,” July. https:// fgiesen.wordpress.com/2011/07/08/a-trip-through-the-graphics-pipeline-2011-part-7/.<br><br><br>Glassner, Andrew. 2015. “Interpreting Alpha.” Journal of Computer Graphics Techniques (JCGT) 4 (2): 30–44. <a href="http://jcgt.org/published/0004/02/03/" target="_blank" rel="noopener">http://jcgt.org/published/0004/02/03/</a>.<br><br><br>Gortler, Steven J. 2012. Foundations of 3D Computer Graphics. The MIT Press.<br><br><br>Green, Chris. 2007. “Improved Alpha-Tested Magnification for Vector Textures and Spe- cial Effects.” In ACM SIGGRAPH 2007 Courses, 9–18. SIGGRAPH ’07. New York, NY, USA: ACM. doi:10.1145/1281500.1281665.<br><br><br>Grevera, George J. 2004. “The ‘Dead Reckoning’ Signed Distance Transform.” Com- put. Vis. Image Underst. 95 (3). New York, NY, USA: Elsevier Science Inc.: 317–33. doi:10.1016/j.cviu.2004.05.002.<br><br><br>Gustavson, Stefan. 2012. “2D Shape Rendering by Distance Fields.” In OpenGL Insights, edited by Patrick Cozzi and Christophe Riccio, 173–82. CRC Press.<br><br><br>Hughes, J.F., A. Van Dam, J.D. Foley, and S.K. Feiner. 2013. Computer Graphics: Principles<br>and Practice. 3rd ed. Addison-Wesley.<br><br><br>International Telecom Union. 2011. RECOMMENDATION ITU-R BT.601-7. https://<br><a href="http://www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.601-7-201103-I!!PDF-E.pdf" target="_blank" rel="noopener">www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.601-7-201103-I!!PDF-E.pdf</a>.<br><br><br>Jargstorff, Frank. 2004. “A Framework for Image Processing.” In GPU Gems, edited by Randima Fernando. Addison-Wesley Professional. <a href="http://http.developer.nvidia.com/" target="_blank" rel="noopener">http://http.developer.nvidia.com/</a> GPUGems/gpugems_ch27.html.<br><br><br>Khronos Group. 2013. “KTX File Format Specification.” Edited by Mark Callow, Georg Kolling, and Jacob Ström. <a href="https://www.khronos.org/opengles/sdk/tools/KTX/file" target="_blank" rel="noopener">https://www.khronos.org/opengles/sdk/tools/KTX/file</a>_ format_spec/.<br><br><br>Lengyel, Eric. 2011. Mathematics for 3D Game Programming and Computer Graphics. 3rd ed. Boston, MA, United States: Course Technology Press.<br><br><br>McGuire, Morgan, and Louis Bavoil. 2013. “Weighted Blended Order-Independent Transparency.” Journal of Computer Graphics Techniques (JCGT) 2 (2): 122–41. <a href="http://jcgt" target="_blank" rel="noopener">http://jcgt</a>. org/published/0002/02/09/.<br><br><br>Miller, Gavin S P. 1986. “The Definition and Rendering of Terrain Maps.” In Proceedings of the 13th Annual Conference on Computer Graphics and Interactive Techniques, 39–48. SIG- GRAPH ’86. New York, NY, USA: ACM. doi:10.1145/15922.15890.<br><br><br>Wavefront Technologies. 1991. “Appendix B1. Object Files.” In Programmer’s Reference Manual for the Advanced Visualizer. <a href="http://www.cs.utah.edu/~boulos/cs3505/obj_spec" target="_blank" rel="noopener">http://www.cs.utah.edu/~boulos/cs3505/obj_spec</a>. pdf.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Barrett, Sean. 2014. “stb Single-File Public Domain Libraries for C/C++.” &lt;a href=&quot;https://github&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github&lt;/a&gt;. com/nothings/stb.&lt;br&gt;&lt;br&gt;&lt;br&gt;Blinn, James F. 1977. “Models of Light Reflection for Computer Synthesized Pictures.” In Proceedings of the 4th Annual Conference on Computer Graphics and Interactive Techniques, 192–98. SIGGRAPH ’77. New York, NY, USA: ACM. doi:10.1145/563858.563893.&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS/Mac" scheme="https://zhaolilong.com/tags/iOS-Mac/"/>
    
      <category term="图形学" scheme="https://zhaolilong.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Metal" scheme="https://zhaolilong.com/tags/Metal/"/>
    
  </entry>
  
  <entry>
    <title>实例学习Metal-第十四章 图像处理基础</title>
    <link href="https://zhaolilong.com/2020/04/05/%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0Metal-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/"/>
    <id>https://zhaolilong.com/2020/04/05/实例学习Metal-第十四章/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2020-03-13T04:42:40.214Z</updated>
    
    <content type="html"><![CDATA[<p>在本章中，我们将开始使用Metal着色语言探索图像处理世界。我们将创建一个能够表示图像滤镜链的框架，然后编写一对图像滤镜，以便我们调整图像的饱和度和模糊度。最终结果将是一个交互式应用程序，允许您实时控制图像过滤器参数。</p><p>图像处理是数据并行编程的主要应用之一。在许多情况下，图像滤波器仅需要查询源图像中的一个像素或小邻域像素以计算每个输出像素的值。在这种情况下，图像滤波器的工作可以以并行方式完成。这非常适合现代GPU架构，它使用许多小内核同时处理多个数据。</p><a id="more"></a><h1 id="Chapter-14-第十四章"><a href="#Chapter-14-第十四章" class="headerlink" title="Chapter 14(第十四章)"></a>Chapter 14(第十四章)</h1><h2 id="Fundamentals-of-Image-Processing-图像处理基础"><a href="#Fundamentals-of-Image-Processing-图像处理基础" class="headerlink" title="Fundamentals of Image Processing(图像处理基础)"></a>Fundamentals of Image Processing(图像处理基础)</h2><p>在本章中，我们将开始使用Metal着色语言探索图像处理世界。我们将创建一个能够表示图像滤镜链的框架，然后编写一对图像滤镜，以便我们调整图像的饱和度和模糊度。最终结果将是一个交互式应用程序，允许您实时控制图像过滤器参数。</p><p>图像处理是数据并行编程的主要应用之一。在许多情况下，图像滤波器仅需要查询源图像中的一个像素或小邻域像素以计算每个输出像素的值。在这种情况下，图像滤波器的工作可以以并行方式完成。这非常适合现代GPU架构，它使用许多小内核同时处理多个数据。</p><h3 id="A-Look-Ahead-展望未来"><a href="#A-Look-Ahead-展望未来" class="headerlink" title="A Look Ahead(展望未来)"></a>A Look Ahead(展望未来)</h3><p>为了进一步激励本章，这里是示例项目的一个片段。它说明了如何简洁地创建并将由可动态调整的用户界面控制的去饱和度和模糊过滤器链接在一起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context = [MBEContext newContext]; </span><br><span class="line">imageProvider = [MBEMainBundleTextureProvider textureProviderWithImageNamed:@&quot;mandrill&quot; context:context];</span><br><span class="line">desaturateFilter = [MBESaturationAdjustmentFilter filterWithSaturationFactor:0.75</span><br><span class="line">context:context];</span><br><span class="line">desaturateFilter.provider = self.imageProvider; </span><br><span class="line">blurFilter = [MBEGaussianBlur2DFilter filterWithRadius:0.0 context:context];</span><br><span class="line">blurFilter.provider = desaturateFilter;</span><br><span class="line">imageView.image = [UIImage imageWithMTLTexture:blurFilter.texture];</span><br></pre></td></tr></table></figure><p><img src="/2020/04/05/实例学习Metal-第十四章/1584068924.png" alt=""></p><center>图14.1：示例应用程序UI，允许实时过滤器调整。</center><h3 id="A-Framework-for-Image-Processing-图像处理框架"><a href="#A-Framework-for-Image-Processing-图像处理框架" class="headerlink" title="A Framework for Image Processing(图像处理框架)"></a>A Framework for Image Processing(图像处理框架)</h3><p>现在我们已经了解了我们希望图像处理框架的界面看起来像什么，我们可以讨论构建这样一个框架的实用性。该框架的大部分架构都受到（Jargstorff 2004）的启发。</p><h4 id="Texture-Providers-and-Consumers-纹理提供者和消费者"><a href="#Texture-Providers-and-Consumers-纹理提供者和消费者" class="headerlink" title="Texture Providers and Consumers(纹理提供者和消费者)"></a>Texture Providers and Consumers(纹理提供者和消费者)</h4><p>每个过滤器都能够使用其输入和输出纹理配置其计算管道并执行其内核功能。</p><p>由于我们将以纹理的形式对图像进行操作，因此我们需要一种抽象的方式来引用生成和使用纹理的对象。例如，过滤器使用和生成纹理，我们还需要一个用于从中生成纹理的类应用程序包。</p><p>我们使用名为<code>MBETextureProvider</code>的协议来抽象纹理生成的概念：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MBETextureProvider</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;<span class="built_in">MTLTexture</span>&gt; texture; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这个简单的界面为我们提供了一种(同步)从纹理提供者请求纹理的方法。它可能导致图像过滤器执行其过滤过程，或从磁盘加载图像。重要的是，我们知道我们可以从任何符合<code>MBETextureProvider</code>的对象中检索纹理。</p><p>另一方面，<code>MBETextureConsumer</code>协议允许我们告诉对象它应该从哪个纹理提供者使用纹理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MBETextureConsumer</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;MBETextureProvider&gt; provider; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这个简单的接口为我们提供了一种（同步）从纹理提供者请求纹理的方式。它可能导致图像过滤器执行其过滤过程，或从磁盘加载图像。重要的是，我们知道我们可以从任何符合<code>MBETextureProvider</code>的对象中检索纹理。</p><p>另一方面，<code>MBETextureConsumer</code>协议允许我们告诉对象它应该从哪个纹理提供者使用纹理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@protocol MBETextureConsumer &lt;NSObject&gt;</span><br><span class="line">@property (nonatomic, strong) id&lt;MBETextureProvider&gt; provider; </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>当纹理使用者想要对纹理进行操作时，它会从其提供者请求纹理并对其进行操作。</p><h4 id="An-Image-Filter-Base-Class-图像过滤器基类"><a href="#An-Image-Filter-Base-Class-图像过滤器基类" class="headerlink" title="An Image Filter Base Class(图像过滤器基类)"></a>An Image Filter Base Class(图像过滤器基类)</h4><p>抽象地，图像滤波器通过对其进行任意操作将一个纹理转换为另一个纹理。我们的MBEImageFilter类完成了调用计算着色器以从另一个生成一个纹理所需的大量工作。</p><p>图像过滤器基类符合刚才讨论的纹理提供者和纹理消费者协议。让过滤器表现为纹理提供者和纹理消费者都允许我们将过滤器链接在一起以按顺序执行多个操作。由于图像上下文管理的命令队列的串行特性，因此可以保证每个过滤器在允许其后继执行之前完成其工作。</p><p>这是MBEImageFilter类接口的相关部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface MBEImageFilter : NSObject &lt;MBETextureProvider, MBETextureConsumer&gt; @property (nonatomic, strong) MBEContext *context;</span><br><span class="line">@property (nonatomic, strong) id&lt;MTLComputePipelineState&gt; pipeline; @property (nonatomic, strong) id&lt;MTLTexture&gt; internalTexture;</span><br><span class="line">@property (nonatomic, assign, getter=isDirty) BOOL dirty;</span><br><span class="line">- (instancetype)initWithFunctionName:(NSString *)functionName</span><br><span class="line">context:(MBEContext *)context;</span><br><span class="line">- (void)configureArgumentTableWithCommandEncoder: (id&lt;MTLComputeCommandEncoder&gt;)commandEncoder;</span><br></pre></td></tr></table></figure><p>必须使用函数名称和上下文来实例化过滤器。这些用于创建计算管道状态，然后将其存储在<code>pipeline</code>属性中。</p><p>图像过滤器保持内部纹理，用作其内核函数的输出纹理。这样它可以存储其计算结果并将其提供给其他过滤器。它也可以绘制到屏幕或转换为图像。</p><p>图像过滤器可能具有任何数量的参数，这些参数会影响它们执行计算的方式。当其中一个更改时，内部纹理无效，并且必须重新执行内核函数。脏标志允许过滤器子类指示何时需要。仅当<code>dirty</code>标识设置为YES时才会执行过滤器，这在自定义属性设置器中完成。</p><p>图像过滤器基类包含<code>-applyFilter</code>方法，该方法在被要求提供其输出纹理时被调用，并且当前是脏的。此方法创建一个命令缓冲区和命令编码器，并调度其内核函数，如前一章所述。</p><p>既然我们已经拥有了必要的机器，让我们来谈谈将要使用的几个示例过滤器。</p><h3 id="Building-a-Saturation-Adjustment-Filter-构建饱和度调整过滤器"><a href="#Building-a-Saturation-Adjustment-Filter-构建饱和度调整过滤器" class="headerlink" title="Building a Saturation Adjustment Filter(构建饱和度调整过滤器)"></a>Building a Saturation Adjustment Filter(构建饱和度调整过滤器)</h3><p>我们将构建的第一个滤镜是饱和度调整滤镜。滤波器将具有可配置的饱和因子，用于确定滤波器应对输入图像进行去饱和的程度。此因子的范围为0到1.当饱和因子为0时，输出图像将是输入的灰度版本。对于介于0和1之间的值，滤镜将通过在灰度图像和输入图像之间进行插值来生成颜色或多或少静音的图像。</p><p><img src="/2020/04/05/实例学习Metal-第十四章/1584068954.png" alt=""></p><center>图14.2：一系列图像显示了如何将滤波器的饱和因子从0增加到1会增加图像饱和度</center><h4 id="Calculating-Brightness-from-RGB-从RGB计算亮度"><a href="#Calculating-Brightness-from-RGB-从RGB计算亮度" class="headerlink" title="Calculating Brightness from RGB(从RGB计算亮度)"></a>Calculating Brightness from RGB(从RGB计算亮度)</h4><p>每个RGB颜色值都有一个相应的亮度值，我们将用符号Y’表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y′ = 0.299R + 0.587G + 0.114B</span><br></pre></td></tr></table></figure><p>请注意，公式中的因子总和为1.它们的值基于人类对不同原色光强度的感知：人眼对绿光最敏感，其次是红光，最后是蓝光。 （这些值作为ITU-R BT.601-7建议书（国际电信联盟2011）第2.5.1节）的一部分公布。</p><p>用相应亮度的灰色像素替换图像中的每种颜色会产生完全去饱和的图像，该图像与原始图像具有相同的感知亮度。这将是我们的去饱和核函数的任务，如下所示。</p><h4 id="The-Desaturation-Kernel-去饱和核"><a href="#The-Desaturation-Kernel-去饱和核" class="headerlink" title="The Desaturation Kernel(去饱和核)"></a>The Desaturation Kernel(去饱和核)</h4><p>为了支持将饱和因子传递给我们的内核函数，我们创建了一个名为AdjustSaturationUniforms的单元结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct AdjustSaturationUniforms </span><br><span class="line">&#123;</span><br><span class="line">    float saturationFactor; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内核函数本身采用输入纹理，输出纹理，对统一结构的引用，以及具有我们在前一章中没有详细描述的属性的整数的2D向量：<code>thread_position_in_grid</code>。</p><p>回想一下前一章，我们发送了一组二维线程组，其大小是根据源纹理的维度计算的。 <code>thread_position_in_grid</code>属性告诉Metal生成一个坐标向量，告诉我们我们在2D网格中的位置，该网格跨越整个调度的工作项集，即源纹理中的当前坐标。</p><p>我们为每个纹理参数指定预期的访问模式：<code>access::read</code>用于输入纹理，<code>access::write</code>用于输出纹理。这限制了我们可以调用这些参数的函数集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kernel void adjust_saturation(texture2d&lt;float, access::read&gt; inTexture [[texture(0)]],</span><br><span class="line">texture2d&lt;float, access::write&gt; outTexture [[texture(1)]], constant AdjustSaturationUniforms &amp;uniforms [[buffer(0)]], uint2 gid [[thread_position_in_grid]])</span><br><span class="line">&#123;</span><br><span class="line">    float4 inColor = inTexture.read(gid);</span><br><span class="line">    float value = dot(inColor.rgb, float3(0.299, 0.587, 0.114));</span><br><span class="line">    float4 grayColor(value, value, value, 1.0);</span><br><span class="line">    float4 outColor = mix(grayColor, inColor, uniforms.saturationFactor); outTexture.write(outColor, gid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们读取源纹素的颜色，并根据前面给出的公式计算其亮度值。点函数允许我们比分别进行三次乘法和两次加法更简洁地完成此操作。然后，我们通过将亮度复制到RGB组件中来生成新颜色，这会产生灰色阴影。</p><p>要计算部分去饱和的输出颜色，我们使用Metal标准库中的函数：mix，它采用两种颜色，系数介于0和1之间。如果系数为0，则返回第一种颜色，如果为1，则返回1 ，返回第二种颜色。在它们之间，它使用线性插值将它们混合在一起。</p><p>最后，我们将得到的去饱和颜色写入输出纹理。请注意，我们之前假设输入和输出纹理具有相同的大小，并且两者的维度都是我们的线程组大小的倍数。如果不是这种情况，我们需要防止在输出纹理边界之外的输入写入范围之外进行读取。</p><h4 id="The-Saturation-Adjustment-Class-饱和度调整类"><a href="#The-Saturation-Adjustment-Class-饱和度调整类" class="headerlink" title="The Saturation Adjustment Class(饱和度调整类)"></a>The Saturation Adjustment Class(饱和度调整类)</h4><p>为了驱动饱和度调整内核，我们需要扩展图像过滤器基类。该子类名为<code>MBESaturationAdjustmentFilter</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MBESaturationAdjustmentFilter</span> : <span class="title">MBEImageFilter</span> </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">float</span> saturationFactor;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)filterWithSaturationFactor:(<span class="keyword">float</span>)saturation</span><br><span class="line">context:(MBEContext *)context; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>该子类使用去饱和内核函数的名称调用初始化程序，并通过对它应该操作的上下文的引用。</p><p>设置<code>saturationFactor</code>属性会导致过滤器设置其<code>dirty</code>属性，这会导致在其纹理属性被请求时延迟重新计算去饱和图像。</p><p>子类的<code>-configureArgumentTableWithCommandEncoder:</code>的实现：包含样板，用于将饱和因子复制到Metal缓冲区中。这里没有显示。</p><p>我们现在有一个完整的过滤器类和内核函数来执行图像去饱和。</p><h4 id="模糊"><a href="#模糊" class="headerlink" title="模糊"></a>模糊</h4><p>我们将看到的下一类图像滤镜是模糊滤镜。</p><p>模糊图像涉及将每个纹素的颜色与相邻文本的颜色混合。在数学上，模糊滤波器是纹素的邻域的加权平均值（这种操作称为<code>卷积</code>）。邻域的大小称为过滤器的半径。小半径将平均较少的纹理像素并产生较少模糊的图像。</p><h4 id="盒子模糊"><a href="#盒子模糊" class="headerlink" title="盒子模糊"></a>盒子模糊</h4><p>最简单的模糊是盒子模糊。框模糊给予所有附近纹素的相同权重，计算它们的平均值。盒子模糊很容易计算，但会产生难看的伪影，因为它们会给噪音带来不适当的重量。</p><p>假设我们选择半径为1的盒子模糊。然后输出图像中的每个纹素将是输入纹理元素及其最近邻居的平均值。 9种颜色中的每一种都具有相同的1/9重量。</p><p><img src="/2020/04/05/实例学习Metal-第十四章/1584068998.png" alt=""></p><center>图14.3：框模糊过滤器平均每个纹素周围的邻域。</center><p>盒子模糊很容易，但它们不会产生非常令人满意的结果。相反，我们将使用更复杂的模糊滤镜，即高斯模糊。</p><h4 id="Gussian-Blur-高斯模糊"><a href="#Gussian-Blur-高斯模糊" class="headerlink" title="Gussian Blur(高斯模糊)"></a>Gussian Blur(高斯模糊)</h4><p>与盒子模糊相反，高斯模糊给相邻纹素提供了不相等的权重，为更接近的纹素赋予了更多的权重，而对于那些更远的纹理则更轻。实际上，权重是根据关于当前纹素的2D正态分布计算的：</p><p>$$<br>G_\sigma(x, y) = {1 \over \sqrt {2\pi\sigma^2}}e^{-{x^2 + y^2\over 2 \sigma^2}}<br>$$</p><p>其中x和y分别是正在处理的纹理元素与其邻居之间沿x和y轴的距离。 σ是分布的标准偏差，默认等于半径的一半。</p><p><img src="/2020/04/05/实例学习Metal-第十四章/1584069023.png" alt=""></p><center>图14.4：高斯模糊滤波器。增加滤镜半径可以创建更平滑的图像。此处显示的最大半径为7。</center><h4 id="The-Blur-Shaders-模糊着色器"><a href="#The-Blur-Shaders-模糊着色器" class="headerlink" title="The Blur Shaders(模糊着色器)"></a>The Blur Shaders(模糊着色器)</h4><p>计算高斯滤波器的模糊权重在核函数中是很昂贵的，特别是对于具有大半径的滤波器。因此，我们将预先计算表格权重并将其作为纹理提供给高斯模糊核函数。此纹理的像素格式为<code>MTLPixelFormatR32Float</code>，它是单通道32位浮点格式。每个纹素都包含0到1之间的权重，所有权重总和为1。</p><p>在内核函数内部，我们迭代当前纹理元素的邻域，从查找表中读取每个纹素及其相应的权重。然后我们将加权颜色添加到累积值。一旦我们完成了所有加权颜色值的加总，我们就会将最终颜色写入输出纹理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kernel void gaussian_blur_2d(texture2d&lt;float, access::read&gt; inTexture [[texture(0)]],</span><br><span class="line">texture2d&lt;float, access::write&gt; outTexture [[texture(1)]], texture2d&lt;float, access::read&gt; weights [[texture(2)]], uint2 gid [[thread_position_in_grid]])</span><br><span class="line">&#123;</span><br><span class="line">    int size = blurKernel.get_width(); int radius = size / 2;</span><br><span class="line">    float4 accumColor(0, 0, 0, 0); for(intj=0;j&lt;size;++j) </span><br><span class="line">    &#123;</span><br><span class="line">        for(inti=0;i&lt;size;++i) </span><br><span class="line">        &#123;</span><br><span class="line">            uint2 kernelIndex(i, j);</span><br><span class="line">            uint2 textureIndex(gid.x + (i - radius), gid.y + (j - radius)); float4 color = inTexture.read(textureIndex).rgba;</span><br><span class="line">            float4 weight = weights.read(kernelIndex).rrrr;</span><br><span class="line">            accumColor += weight * color;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    outTexture.write(float4(accumColor.rgb, 1), gid); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="The-Filter-Class-过滤类"><a href="#The-Filter-Class-过滤类" class="headerlink" title="The Filter Class(过滤类)"></a>The Filter Class(过滤类)</h4><p>模糊过滤器类<code>MBEGaussianBlur2DFilter</code>派生自图像过滤器基类。它的<code>-configureArgumentTableWithCommandEncoder:</code>的实现：懒惰地生成模糊权重并将命令编码器上的查找表纹理设置为第三个参数（参数表索引2）。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)configureArgumentTableWithCommandEncoder: (<span class="keyword">id</span>&lt;<span class="built_in">MTLComputeCommandEncoder</span>&gt;)commandEncoder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.blurWeightTexture) </span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span> generateBlurWeightTexture]; </span><br><span class="line">    &#125;</span><br><span class="line">    [commandEncoder setTexture:<span class="keyword">self</span>.blurWeightTexture atIndex:<span class="number">2</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-generateBlurWeightTexture</code>方法使用上面的2D标准分布公式计算适当大小的权重矩阵，并将值复制到Metal纹理中。</p><p>这完成了我们对高斯模糊滤镜类和着色器的实现。现在我们需要讨论如何将滤镜链接在一起并将最终图像输出到屏幕上。</p><h3 id="Chaining-Image-Filters-链接图像过滤器"><a href="#Chaining-Image-Filters-链接图像过滤器" class="headerlink" title="Chaining Image Filters(链接图像过滤器)"></a>Chaining Image Filters(链接图像过滤器)</h3><p>再次考虑本章开头的代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context = [MBEContext newContext]; imageProvider = [MBEMainBundleTextureProvider</span><br><span class="line">textureProviderWithImageNamed:<span class="string">@"mandrill"</span> context:context];</span><br><span class="line">desaturateFilter = [MBESaturationAdjustmentFilter filterWithSaturationFactor:<span class="number">0.75</span></span><br><span class="line">context:context];</span><br><span class="line">desaturateFilter.provider = <span class="keyword">self</span>.imageProvider; </span><br><span class="line">blurFilter = [MBEGaussianBlur2DFilter filterWithRadius:<span class="number">0.0</span> context:context];</span><br><span class="line">blurFilter.provider = desaturateFilter;</span><br><span class="line">imageView.image = [<span class="built_in">UIImage</span> imageWithMTLTexture:blurFilter.texture];</span><br></pre></td></tr></table></figure><p>主捆绑图像提供程序是一个实用程序，用于将图像加载到Metal纹理中，并充当链的开头。它被设置为去饱和度过滤器的纹理提供者，后者又被设置为模糊过滤器的纹理提供者。</p><p>请求模糊滤镜的纹理实际上是将图像滤镜处理设置为运动的原因。这会导致模糊滤镜请求去饱和过滤器的纹理，这反过来会导致去饱和内核同步调度。一旦完成，模糊滤镜将去饱和纹理作为输入并调度其自己的内核函数。</p><p>现在我们已经过滤了图像，我们可以使用它来渲染带有Metal的纹理四边形（或其他表面）。假设我们想用UIKit显示它？我们如何从UIImage创建Metal纹理，而不是从Metal纹理创建UIImage？</p><h3 id="Creating-a-UIImage-from-a-Texture-从纹理创建UIImage"><a href="#Creating-a-UIImage-from-a-Texture-从纹理创建UIImage" class="headerlink" title="Creating a UIImage from a Texture(从纹理创建UIImage)"></a>Creating a UIImage from a Texture(从纹理创建UIImage)</h3><p>最有效的方法是使用Core Graphics中的图像实用程序。首先，创建一个临时缓冲区，其中读取Metal纹理的像素数据。可以使用CGDataProviderRef包装此缓冲区，然后使用CGDataProviderRef创建CGImageRef。然后我们可以创建一个包装此CGImageRef的UIImage实例。</p><p>示例代码在UIImage上实现了一个类别，该类别在名为<code>+imageWithMTLTexture:</code>的方法中执行所有这些操作。为简洁起见，此处不包含此内容，但它有助于阅读。</p><p>值得一提的是，这不是在屏幕上获取过滤图像的最有效方法。从纹理创建图像使用额外的内存，占用CPU时间，并要求Core Animation合成器将图像数据复制回纹理以供显示。所有这些都是昂贵的，并且在许多情况下可以避免。幸运的是，在本书的整个过程中，我们已经看到很多方法可以使用不涉及UIKit的纹理。</p><h4 id="Driving-Image-Processing-Asynchronously-异步驱动图像处理"><a href="#Driving-Image-Processing-Asynchronously-异步驱动图像处理" class="headerlink" title="Driving Image Processing Asynchronously(异步驱动图像处理)"></a>Driving Image Processing Asynchronously(异步驱动图像处理)</h4><p>上面，我们提到过滤器同步调度它们的内核函数。由于图像处理是计算密集型的，我们需要一种在背景线程上进行工作的方法，以保持用户界面的响应。</p><p>将命令缓冲区提交到命令队列本质上是线程安全的，但是控制并发的其他方面是程序员的责任。</p><p>幸运的是，Grand Central Dispatch使我们的工作变得轻松。由于我们只会在主线程上响应用户操作而使用图像过滤器，因此我们可以使用一对<code>dispatch_async</code>调用将我们的图像处理工作重定位到后台线程上，异步更新主线程上的图像视图过滤器的处理完成。</p><p>我们将在视图控制器上以原子64位整数属性的形式使用粗互斥，每次请求更新时都会递增。该计数器的值由入队的块捕获。如果块在后台队列上执行时尚未发生另一个用户事件，则允许执行图像过滤器，并刷新UI。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateImage &#123;</span><br><span class="line">    ++<span class="keyword">self</span>.jobIndex;</span><br><span class="line">    uint64_t currentJobIndex = <span class="keyword">self</span>.jobIndex;</span><br><span class="line">    <span class="keyword">float</span> blurRadius = <span class="keyword">self</span>.blurRadiusSlider.value; </span><br><span class="line">    <span class="keyword">float</span> saturation = <span class="keyword">self</span>.saturationSlider.value;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.renderingQueue, ^&#123; </span><br><span class="line">        <span class="keyword">if</span> (currentJobIndex != <span class="keyword">self</span>.jobIndex)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">self</span>.blurFilter.radius = blurRadius; <span class="keyword">self</span>.desaturateFilter.saturationFactor = saturation;</span><br><span class="line">        <span class="keyword">id</span>&lt;<span class="built_in">MTLTexture</span>&gt; texture = <span class="keyword">self</span>.blurFilter.texture; <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithMTLTexture:texture];</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; <span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="The-Sample-Project-示例项目"><a href="#The-Sample-Project-示例项目" class="headerlink" title="The Sample Project(示例项目)"></a>The Sample Project(示例项目)</h3><p>本章的示例代码位于14-ImageProcessing目录中。</p><p>在本章中，我们采用了与Metal并行计算的后续步骤，并看到了几个可以在GPU上高效运行的图像过滤器示例。您现在可以使用此处提供的框架来创建自己的效果，并使用Metal的强大功能在GPU上高效运行它们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本章中，我们将开始使用Metal着色语言探索图像处理世界。我们将创建一个能够表示图像滤镜链的框架，然后编写一对图像滤镜，以便我们调整图像的饱和度和模糊度。最终结果将是一个交互式应用程序，允许您实时控制图像过滤器参数。&lt;/p&gt;
&lt;p&gt;图像处理是数据并行编程的主要应用之一。在许多情况下，图像滤波器仅需要查询源图像中的一个像素或小邻域像素以计算每个输出像素的值。在这种情况下，图像滤波器的工作可以以并行方式完成。这非常适合现代GPU架构，它使用许多小内核同时处理多个数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS/Mac" scheme="https://zhaolilong.com/tags/iOS-Mac/"/>
    
      <category term="图形学" scheme="https://zhaolilong.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Metal" scheme="https://zhaolilong.com/tags/Metal/"/>
    
  </entry>
  
</feed>
