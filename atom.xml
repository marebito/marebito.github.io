<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博伊卡の楼閣</title>
  
  <subtitle>逆水行舟，不进则退</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhaolilong.com/"/>
  <updated>2020-03-10T01:56:09.675Z</updated>
  <id>https://zhaolilong.com/</id>
  
  <author>
    <name>Boyka·Yuri</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第三章</title>
    <link href="https://zhaolilong.com/2019/03/02/%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>https://zhaolilong.com/2019/03/02/第三章/</id>
    <published>2019-03-02T15:08:19.000Z</published>
    <updated>2020-03-10T01:56:09.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="Unity-ARKit"><a href="#Unity-ARKit" class="headerlink" title="Unity ARKit"></a>Unity ARKit</h2><p>既然您已经安装了Unity和Unity ARKit插件，现在是时候学习更多有关此工具的知识并开始我们的第一次AR体验。请注意，我称这是一种体验，而不是游戏，尽管它可能以某种方式用作游戏;从我的观点来看，游戏需要一些关键元素，我将在第4章详细介绍。</p><p>如果您还没有打开我们在上一章创建的AR项目，那么现在是进行此操作的好时机。如果您查看Project文件夹（图3-1）并查看每个文件夹，您将看到Unity ARKit插件附带了许多我们将在本书中探索和使用的资源。</p><h3 id="创建一个场景"><a href="#创建一个场景" class="headerlink" title="创建一个场景"></a>创建一个场景</h3><p>我们要做的第一项任务是创建GameObject并将其放入我们的场景中并在AR中查看它。从“菜单”中，选择“GameObject”➤“三维对象”➤“多维数据集”（图3-1）。我们可以选择任何3D对象，但我希望您在AR中看到Cube并在3D空间中移动它。虽然我更喜欢Spheres，但3DCube 有六个顶点（多边形的角点），这些顶点会更容易看到。但是，我们很快就会添加不同形状的GameObject。</p><p><img src="/2019/03/02/第三章/1551539521.jpg" alt=""></p><center>图 3-1. 创建一个3D GameObject</center><p>完成此任务后，您将在“场景”面板中看到我们令人惊奇的Cube （图3-2）。</p><p><img src="/2019/03/02/第三章/1551539615.jpg" alt=""></p><center>图 3-2. 场景中的Cube GameObject</center><p>现在让我们看看Inspector（图3-3）。如果您的变换位置与我的不同，请暂时不要担心（无论如何我们将移动GameObject）。注意比例是1,1,1。 Unity使用度量标准进行测量，因此Unity空间中的1个单位相当于1米的实际值。现在对于大多数传统游戏（不是AR），这并不是初学者需要担心的（很多）。但是，因为我们将游戏资产投射到现实世界中，所以正确地进行测量和缩放变得非常重要。因此，如果我们将Cube 的比例保持在1米宽，1米高，1米深，这将是一个非常大的Cube 。用于描述3D图形中的坐标的惯例是X，Y，Z。我会在本书中使用这个标准。我将扩大我们惊人的Cube ，所以它将适合我的小公寓。一些读者可能会感到惊讶的是，大多数教学书籍的作者并不住在价值数百万美元的豪宅中（至少这位作者没有）。</p><p><img src="/2019/03/02/第三章/1551539781.jpg" alt=""></p><center>图 3-3. Inspector中的Cube GameObject</center><p>在Inspector中，设置scale为0.25, 0.25, 0.25（图 3-4）。</p><p><img src="/2019/03/02/第三章/1551539890.jpg" alt=""></p><center>图 3-4. 减小Cube 的Scale</center><p>现在，如果您在场景中查看多维数据集，它将（或应该）看起来更小（图3-5）。如果您想要仔细查看GameObject，可以将场景视图中的摄像机移动到更靠近多维数据集的位置。移动场景视图相机有两种主要方式。最简单的方法是在Hierarchy面板中选择GameObject并按f键（我记得这是f作为焦点）。另一种方法是使用鼠标中键（如果你有一个3键鼠标）来移动或移出相机或双击鼠标（如果你有一个魔术鼠标）。我（非常）老了，喜欢用我的5键鼠标。</p><p><img src="/2019/03/02/第三章/1551540009.jpg" alt=""></p><center>图 3-5. 缩小比例的Cube GameObject的场景视图</center><h3 id="摄像机"><a href="#摄像机" class="headerlink" title="摄像机"></a>摄像机</h3><p>现在是讨论相机的好时机。我们刚刚在Scene视图中移动了相机。使用此相机，开发人员可以查看场景中的内容。但是，如果查看“层次”面板，您将看到一个GameObjectMain Camera。这是玩家将要浏览的相机。您将在图3-5中注意到，我的场景视图中有一个摄像头图标。这是玩家的相机在场景中的位置。</p><p>我希望您在“层次”面板中选择“Main Camera”。您将在Scene视图右下方的小窗口中看到一个小窗口（图3-6）。此窗口显示播放器相机的视图（相机预览）。</p><p><img src="/2019/03/02/第三章/1551540191.jpg" alt=""></p><center>图 3-6. 摄像机预览</center><p>虽然Camera Preview窗口为我们提供了一个好主意 场景对玩家来说是什么样的，为了获得更好的视野，我们可以选择 游戏视图选项卡（图3-7）。</p><p><img src="/2019/03/02/第三章/1551540259.jpg" alt=""></p><center>图 3-7. 游戏视图</center><p>正如我们在前一章中看到的，我们可以使用许多设置（宽高比，比例等）。我们可以在这里看到我们惊人的Cube有点远。我们将首先移动GameObject，然后我们将移动Main Camera。</p><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p>有几种方法可以在Unity中移动（转换）GameObject。我们将使用的第一种方法（也是我使用的主要方法）是在Inspector中设置变换设置。首先，选择我们想要转换的GameObject。然后，在检查器中将变换位置设置为0,0,0（图3-8）。</p><p><img src="/2019/03/02/第三章/1551540355.jpg" alt=""></p><center>图 3-8. 具有更新的转换位置的GameObject</center><p>现在让我们看一下Main Camera，看一下播放器的外观（图3-9）。</p><p><img src="/2019/03/02/第三章/1551540437.jpg" alt=""></p><center>图 3-9. 重置变换位置的GameObject的相机预览</center><p>你会注意到GameObject距离Main Camera仍然有点太远了。在屏幕的左上角（在Hierarchy面板的正上方），有六个图标（图3-10）。</p><p><img src="/2019/03/02/第三章/1551540587.jpg" alt=""></p><center>图 3-10. 六个变换图标</center><p>第一个图标是手形工具（Q快捷方式），用于在场景视图中转换（或平移）相机。选择此工具后，在“层次结构（Hierarchy）”移动鼠标中选择任何GameObject，并注意GameObject的变换设置不会更改，但GameObject的视图会发生变化。在按住alt（选项）键的同时，使用“手形”工具可以围绕其枢轴点绕相机进行环绕。通过按住控制按钮，您可以将摄像机移动（或移动）距离GameObject更近或更远。</p><p>下一个图标是移动工具（W快捷方式）。您可以猜测，移动工具用于移动GameObject在场景中的位置。选择Main Camera后，选择移动工具（通过选择移动图标或按W键），您将注意到在场景视图中，Main Camera图标现在具有移动Gizmo（带箭头的红色，绿色蓝色线条）要点 - 图3-11）。首先，选择绿线（Y轴）并向下移动主摄像机。请注意，选择此行时，其他箭头线将显示为灰色，并且您选择的行将更改为黄色。现在尝试将相机移动到Y轴上的0。您会注意到这可能需要一些时间。如果无法正确显示位置，则可能需要在检查器的Y中输入零（这就是我更喜欢在检查器中键入值的原因）。</p><p><img src="/2019/03/02/第三章/1551540769.jpg" alt=""></p><center>图 3-11. 移动Gizmo</center><p>下一个工具是旋转工具（E快捷方式）。正如您可能猜到的，此工具用于旋转GameObject。尝试选择多维数据集，然后按R键。您将看到旋转Gizmo（图3-12）。使用旋转Gizmo，您可以通过单击并拖动围绕它出现的线框旋转Gizmo的轴来更改GameObject的旋转。使用“旋转Gizmo”时，红色，绿色和蓝色圆圈围绕红色，绿色和蓝色轴执行旋转（红色是x轴，绿色是y轴，蓝色是z轴）。外圆用于围绕场景视图z轴旋转GameObject。</p><p><img src="/2019/03/02/第三章/1551540850.jpg" alt=""></p><center>图 3-12. 旋转Gizmo</center><p>下一个工具是Scale toll（R快捷方式）。通过选择Scale Gizmo的中心然后拖动鼠标，缩放工具用于在所有轴上缩放或重新缩放GameObjects（图3-13）。您也可以使用此工具通过选择任意一个轴来在单个轴上进行缩放。</p><p><img src="/2019/03/02/第三章/1551540923.jpg" alt=""></p><center>图 3-13. 缩放Gizmo</center><p>使用多维数据集缩放多维数据集选择的Cube GameObject设置位置，或者在我们使用转换工具时它已被移动; 现在是将位置设置或重置为0,0,0的好时机（图3-14）。</p><p><img src="/2019/03/02/第三章/1551541076.jpg" alt=""></p><center>图 3-14. Cube GameObject位置设置</center><p>现在我们需要将Main Camera定位在原点（0,0,0）。如果你看看我的立方体的位置，这意味着我们的相机将在我们的立方体中间。所以，让我们先把立方体移开。将立方体变换位置设置为0,0,1，然后将主摄像机移动到0,0,0（图3-15）。现在，立方体看起来就像距离我们的相机1米远。</p><p><img src="/2019/03/02/第三章/1551541180.jpg" alt=""></p><center>图 3-15. 新的主摄像机设置</center><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>现在是时候看看我们这个惊人的立方体将如何在现实世界中展现出来。在为iOS开发时，我们需要在测试或部署游戏之前使用Xcode。要在iTunes上发布AR游戏，我们需要将游戏提交给Apple进行审批，然后当它获得批准后，我们​​可以从iTunes商店下载它，看看它在我们的设备上的样子。使用Xcode，我们可以在我们的设备上预览我们的游戏将会是什么样子，但这仍然需要我们构建和运行游戏并使用Xcode来预览游戏。正如您可能想象的那样，这是一次非常耗时（并且有点令人沮丧）的体验。 Unity拯救了我们，为我们提供了Unity Remote。 Unity Remote是一个应用程序（或应用程序），可用于iTunes应用商店中的iOS设备。此工具可帮助我们在iOS设备上测试游戏，而无需将游戏提交到iTunes商店。但是，在撰写本文时，Unity Remote（版本5）不支持AR。 Unity的优秀人员已经考虑过这一挑战，并在Unity ARKit中加入了一个名为UnityARKitRemote的小程序。 Unity ARKitRemote为我们提供了在iOS设备上测试AR项目所需的工具。</p><h3 id="ARKit-Remote"><a href="#ARKit-Remote" class="headerlink" title="ARKit Remote"></a>ARKit Remote</h3><p>在项目文件夹中，输入搜索文本查找ARKit Remote预制件（图 3-16）。现在拖拽文件到Hierarchy选项卡（图 3-17）.</p><p><img src="/2019/03/02/第三章/1551595928.jpg" alt=""></p><center>图 3-16. 搜索ARKit Remote<p><img src="/2019/03/02/第三章/1551595975.jpg" alt=""></p><center>图 3-17. 在Hierarchy中的ARKitRemote预制件<h3 id="设置主摄像机"><a href="#设置主摄像机" class="headerlink" title="设置主摄像机"></a>设置主摄像机</h3><p>现在在主摄像机设定中，设置clear flag为Depth only（图 3-18）。</p><p><img src="/2019/03/02/第三章/1551596138.jpg" alt=""></p><center>图 3-18. 设置相机的Clear Flags为Depth only<h3 id="添加一个组件"><a href="#添加一个组件" class="headerlink" title="添加一个组件"></a>添加一个组件</h3><p>现在我们打算添加一个组件到我们的相机。在这个例子中，我们打算添加一个Unity AR Video脚本。添加这个脚本，选中主摄像机（Main Camera），在Inspector中选择添加组件（Add Component）。</p><p>在Inspector中，您将看到一列你能够添加的组件（图 3-18）。这可能花费一会功夫去找，所以我建议使用在添加组件菜单中的搜索栏来添加我们寻找的脚本。在图3-19中，在搜索栏中，我搜索video。</p><p><img src="/2019/03/02/第三章/1551596538.jpg" alt=""></p><center>图 3-19. 搜索Unity AR Video脚本组件</center><p>一旦您发现了到Unity AR Video脚本，选中它（单击鼠标），现在您应当看到这个组件被添加到Main Camera上了。</p><p><img src="/2019/03/02/第三章/1551596695.jpg" alt=""></p><center>图 3-20. Unity AR Video脚本组件添加到主摄像机上</center><p>在Unity AR Video脚本中，有一个属性叫做Clear Material。我们打算添加一个材质。在Unity AR Video脚本的Clear Materials属性，在属性框的右侧，有一个小齿轮（图 3-19）；如果您选中这个齿轮，您将会看到一个在这个项目文件夹下所有可用材质的列表（图 3-21）。另外，你可以手动搜索，或者使用搜索栏。搜索YUV材质。我将详细介绍这种材料的作用以及我们在后面的章节中使用它的原因。</p><p><img src="/2019/03/02/第三章/1551596988.jpg" alt=""></p><center>图 3-21. 为Clear Material选择YUV材质</center><h3 id="跟踪手机运动"><a href="#跟踪手机运动" class="headerlink" title="跟踪手机运动"></a>跟踪手机运动</h3><p>为了使AR项目看起来真实，我们需要跟踪手机在现实世界中的移动，并在手机屏幕上投影虚拟对象的准确表示。 Unity的优秀人才（再次）让我们的生活更轻松，在Unity中，ARKit有一个名为Unity AR Camera Manager的脚本。按照我们添加Unity AR Video脚本的步骤，我们将添加Unity AR Camera Manager。首先选择Main Camera，然后在Inspector中选择Add Component（图 3-22）;现在搜索AR Camera Manager（图3-23），并将其添加到Main Camera。</p><p><img src="/2019/03/02/第三章/1551654194.jpg" alt=""></p><center>图 3-22. 添加组件</center><p><img src="/2019/03/02/第三章/1551654227.jpg" alt=""></p><center>搜索Unity AR Camera Manager</center><p>最好将Main Camera添加到Unity AR Camera Manager的跟踪Tracked Camera属性中;这将确保AR Camera Manager使用正确的相机。但是，如果您不选择此选项，Unity AR Camera Manager将为您选择。要将Main Camera添加到Unity AR Camera Manager的Camera属性，请从Hierarchy中选择Main Camera，然后将其拖动到Unity AR Camera Manager的Camera属性（图 3-24）。</p><p><img src="/2019/03/02/第三章/1551654485.jpg" alt=""></p><center>图 3-24. 设置Main Camera作为Tracked Camera<h3 id="构建并运行"><a href="#构建并运行" class="headerlink" title="构建并运行"></a>构建并运行</h3><p>现在我们已准备好构建和运行我们的应用程序。确保已将iOS设备连接到Mac，然后从Unity File菜单中选择Build＆Run（图3-25）。如果您尚未下载最新版本的Xcode，则需要立即执行此操作（这需要一段时间）。</p><p><img src="/2019/03/02/第三章/1551654576.jpg" alt=""></p><center>图 3-25. 选择Build & Run</center><p><img src="/2019/03/02/第三章/1551654731.jpg" alt=""></p><center>图 3-26. 构建设置<p>在Build设置菜单中，首先选择要在其上构建的平台，在我们的示例中将是iOS。此外，选中“开发构建”复选框。最后，仅选择要构建的场景非常重要。如果未列出当前场景，请单击“添加打开场景”按钮（图3-26）并取消选中任何其他场景。在Build Setting屏幕中，选择Player Settings图标。这将打开玩家设置的Inspector，我们将在其中输入公司名称和产品名称（图3-27）。</p><p><img src="/2019/03/02/第三章/1551654943.jpg" alt=""></p><center>图 3-27. Player Settings的检视器视图</center><p>向下滚动菜单以找到Bundle Identifier（图3-26）。请务必注意，一旦您在Xcode中向个人团队注册了捆绑包标识符，将来就无法将相同的捆绑包标识符注册到其他Apple Developer Program团队。这意味着当您使用免费的Apple ID和个人团队测试游戏时，您应该选择仅用于测试的包标识符 - 您将无法使用相同的包标识符来释放游戏。执行此操作的最佳解决方案是在测试包标识符的末尾添加“Test” - 例如，com.yourCompanyName.yourAppNameTest。另请注意，捆绑标识符以所谓的反向DNS样式编写。接受的字符是字母数字字符，句点和连字符。在我的例子中（图3-28），我使用过com。 RottenEggProductions.HelloWorldARTest作为包标识符（您将需要自己的名字）。如果您有签名团队ID，您可能也想要包含该ID。但出于测试目的，这不是必需的。</p><p><img src="/2019/03/02/第三章/1551655117.jpg" alt=""></p><center>图 3-28. 在PlayerSetting中设置Bundle Identifier</center><p>现在选择Build and Run图标。 Unity将提示您保存项目。学习入门编程课程的传统是命名我们的第一个应用程序Hello World（不要问我原因）。所以，在这个传统中，我将命名我的第一个AR App，Hello WorldAR。请注意，在图3-29中，我将其保存在与Unity Project相同的文件夹中。有些人会说这不是好习惯，但现在已经足够好了</p><p><img src="/2019/03/02/第三章/1551655198.jpg" alt=""></p><center>图 3-29. 保存Hello WorldAR Menu</center><p>保存文件后，Unity将开始编译应用程序（图3-28）并最终打开Xcode（图3-29）。当Xcode打开时（图3-31），确保选择了正确的设备（iPhone或iPad），选择播放按钮以在设备上启动游戏（图3-30）。如果Unity报告任何错误，请务必检查错误是什么并在重试之前解决这些问题。</p><p><img src="/2019/03/02/第三章/1551655287.jpg" alt=""></p><center>图 3-30. Unity编译我们的应用程序</center><p><img src="/2019/03/02/第三章/1551655344.jpg" alt=""></p><center>图 3-31. Xcode</center><p>系统将提示您允许Unity ARKit访问您的相机，如果一切正常，您应该在现实世界中看到您的惊人立方体。在我的例子中，你可以在我的Mount Aoraki照片前看到我惊人的立方体（图3-32）。</p><p><img src="/2019/03/02/第三章/1551655438.jpg" alt=""></p><center>图 3-32. 我的Hello WorldAR应用程序</center><h3 id="保存场景"><a href="#保存场景" class="headerlink" title="保存场景"></a>保存场景</h3><p>现在是拯救我们现场的好时机。从文件菜单中，选择“文件”➤“将场景另存为”并命名此场景（图3-33）。我已选择Hello WorldAR作为此场景的名称（图3-34）。</p><p><img src="/2019/03/02/第三章/1551655680.jpg" alt=""></p><center>图 3-33. 场景另存为（Save Scene as）菜单<p><img src="/2019/03/02/第三章/1551655775.jpg" alt=""></p><center>图 3-34. 保存场景并选择它的位置</center><h3 id="了解场景"><a href="#了解场景" class="headerlink" title="了解场景"></a>了解场景</h3><p>现在可能是讨论Unity场景和项目之间差异的好时机。 Unity项目包含可能用于游戏或应用程序的所有场景和必要代码。场景是项目的元素（或组件）。将该项目视为整部电影，将场景视为该电影的一部分。在游戏中，这些场景可以是菜单，关卡，积分等。</p><h3 id="引入视觉惯性测距法（Visual-Inertial-Odometry）"><a href="#引入视觉惯性测距法（Visual-Inertial-Odometry）" class="headerlink" title="引入视觉惯性测距法（Visual Inertial Odometry）"></a>引入视觉惯性测距法（Visual Inertial Odometry）</h3><p>现在我们将看一些用于创建AR游戏的重要工具。在我们的Hello WorldAR项目中，我们创建了一个位于iPhone相机前面的立方体，并在我们移动相机位置时停留在那里。相机如何知道它的位置？您可能已经知道，iPhone有一些非常酷的方式来了解它的位置。我最常用的是加速度计。加速度计允许iPhone知道它在3轴（X，Y，Z）中的位置。这对于在纵向和横向模式之间切换非常有用。我使用的另一个工具是指南针（或磁力计），正如您可能已经知道的那样，这对于导航非常有用。最后一个工具是陀螺仪。陀螺仪跟踪iPhone的旋转或扭曲。虽然这些是很好的导航工具，但它们没有跟踪AR中手机移动所需的精确度。为了跟踪AR所需的iPhone的移动，Apple最近在手机的相机中加入了一些技术。通过组合视觉信息（来自摄像机）和惯性信息（来自加速度计和陀螺仪），可以精确测量iPhone的位置。</p><h3 id="特征点（Feature-Points）"><a href="#特征点（Feature-Points）" class="headerlink" title="特征点（Feature Points）"></a>特征点（Feature Points）</h3><p>那么相机如何跟踪手机的位置？好问题！ iPhone中的相机（目前是iPhone 8或更高版本）非常智能，可以识别现实世界中的关键点（或特征点），并且当移动相机时，跟踪这些点的位置。这个过程需要一些非常令人印象深刻的数学，但最近的iPhone有足够的处理能力来做到这一点。</p><h3 id="点云（Point-Clouds）"><a href="#点云（Point-Clouds）" class="headerlink" title="点云（Point Clouds）"></a>点云（Point Clouds）</h3><p>Unity ARKit包括一个预制件，用于帮助手机识别物理世界中的特征点。我们将要使用的第一个是PointCloud Prefab。在Unity中打开Hello WorldAR应用程序后，我们将创建一个空的GameObject。从文件菜单中，选择GameObject➤CreateEmpty（图3-35）。</p><p><img src="/2019/03/02/第三章/1551656212.jpg" alt=""></p><center>图 3-35. 创建一个Empty GameObject</center><p>在Inspector中选中Empty GameObject后，将其重命名为Point Cloud。现在添加一个组件。在搜索栏中，搜索Unity Point Cloud示例并将其添加到Point Cloud GameObject（图3-36）。</p><p><img src="/2019/03/02/第三章/1551656302.jpg" alt=""></p><center>图 3-36. 搜索Point Cloud Example</center><p>添加Unity Point Cloud示例脚本后，现在将最大点数设置为120（图3-37）。您可以根据需要设置多个点云。</p><p><img src="/2019/03/02/第三章/1551656378.jpg" alt=""></p><center>图 3-37. 设置要显示的最大点数</center><p>现在我们需要添加一个Point Cloud Particle预制件到Point Cloud。选择Point Cloud Prefab选项框右侧的小齿轮，然后搜索预制件（图 3-38）。选择并拖拽PointCloudPrefab到Point Cloud Particle Example脚本里的Point Cloud Particle预制件选项框（图 3-39）。</p><p><img src="/2019/03/02/第三章/1551656959.jpg" alt=""></p><center>图 3-38. 搜索PointCloud预制件</center><p><img src="/2019/03/02/第三章/1551657029.jpg" alt=""></p><center>图 3-39. PointCloudPrefab设置为Point Cloud Prefab</center><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>现在我们将测试我们的Point Cloud。当我们测试我们的Hello WorldAR应用程序时，我们经历了构建应用程序的长期（可能是乏味的）任务，在Xcode中启动它。然后最终能够在我们的iOS设备上看到我们的应用程序。 Unity的优秀人才对此进行了思考，并为我们创造了一种减少测试开发时间的方法。在Unity ARKit中，有一个Scene可以让我们在Unity的Game选项卡中预览构建。如果你想在每次想要预览开发时都经历使用Xcode的过程，那很好。但是，我会向您展示一种您可能更有价值的方式。</p><h3 id="Unity-ARKitRemote"><a href="#Unity-ARKitRemote" class="headerlink" title="Unity ARKitRemote"></a>Unity ARKitRemote</h3><p>由于Unity Remote Connection目前不支持AR，因此我们需要在iOS设备上构建和部署App。 Unity的优秀人才包括在Unity ARKit中，这是一个名为ARKit Remote的场景。您可以使用搜索栏在Project文件夹中找到它。在图3-40中，我使用了搜索字符串remote。</p><p><img src="/2019/03/02/第三章/1551738319.jpg" alt=""></p><center>图 3-40. 搜索UnityARKitRemote场景</center><p>双击场景打开它。如果您没有保存当前场景，Unity打开另一场景前系统会提示您先保存它。您将会看到这是一个非常简单的场景，它包含了一个主摄像机（Main Camera）和一个直射光（Directional Light）（图 3-41）。</p><p><img src="/2019/03/02/第三章/1551739189.jpg" alt=""></p><center>图 3-41. UnityARKitRemote</center><p>如果在层次结构(Hierarchy)中选择主摄像机(Main Camera)，您将看到主摄像机(Main Camera)添加了多个脚本（图 3-42）。这些脚本将使手机摄像头能够跟踪其位置，并使我们能够在Unity编辑器中查看摄像机视图。</p></center></center></center></center></center></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三章&quot;&gt;&lt;a href=&quot;#第三章&quot; class=&quot;headerlink&quot; title=&quot;第三章&quot;&gt;&lt;/a&gt;第三章&lt;/h1&gt;&lt;h2 id=&quot;Unity-ARKit&quot;&gt;&lt;a href=&quot;#Unity-ARKit&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第二章</title>
    <link href="https://zhaolilong.com/2019/02/27/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>https://zhaolilong.com/2019/02/27/第二章/</id>
    <published>2019-02-27T00:05:07.000Z</published>
    <updated>2020-03-10T01:56:09.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>如果顺利的话，您可能已经对增强现实（或AR）有了一个很好的了解。由于对术语虚拟现实（或VR），增强现实和混合现实之间的差异存在一些混淆，我认为可能值得在本书中澄清AR的含义。</p><p>虚拟现实（VR）是一个计算机生成的环境，通过感官和感知模拟体验。不同于传统的计算机系统，VR系统将用户置于体验之中。代替在他们屏幕前观看，用户沉浸其中并且能够与3D世界互动。</p><p>现在，让我们看看增强现实（AR）。普遍的共识是AR被定义为真实世界环境的一个直接实时视图，它的元素被计算机生成的信息“增强”。VR和AR之间根本的区别在于AR包括真实环境的<strong>实时视图</strong>。VR系统通常不包括真实环境的实时视图。 VR耳机是全封闭的，显示完全计算机产生。</p><p>混合现实（MR，虽然这个缩写词很少使用），是一个术语这主要是微软用来区分他们的HoloLens。我觉得混合现实是另一种形式的AR。但是，还有一些对此进行辩论。当我问微软的好朋友时，他们觉得混合现实介于AR和VR之间，完全集成了数字对象进入您的世界，使它看起来好像它们真的在那里。</p><p>您可能会惊讶于VR和AR这两个词一直存在很多年。虽然关于首次使用术语VR的问题存在相当大的争议（主要是由于对术语的商定定义），有一些普遍认为该术语最初是在20世纪50年代左右使用的，作者提到完全沉浸式系统或环境。自始至终美国军方和美国宇航局，飞机制造商使用AR系统用于培训，研究和开发。然而，直到2016年我们看到了第一个商用消费类AR系统Oculus Rift。Occulus Rift由Oculus VR制造（最终被Facebook以20亿美元的价格买断）。</p><p>多年来也提到了AR。困难同意当时对AR的首次提及也是由于对什么是AR的商定定义。 1989年，乔治道格拉斯写了一篇文章计算机驱动的天文望远镜引导和控制系统具有叠加的星场和天体坐标图形显示这似乎是第一个AR系统。</p><p>最近，有几个有趣的发展AR。虽然有一些专有系统，但第一个最值得注意的开发是为Android和iOS推出PokémonGo手机。使用地理定位功能和集成摄像头在手机上，用户能够在现实世界中看到屏幕上出现的虚拟对象。</p><p>在本书中，我将专注于开发一款iOS的AR游戏。我出于多种原因选择了iOS。首先，有很多设备使用iOS。更重要的是，Apple正在投入AR硬件和软件的开发。在iOS11中，苹果包含了ARKit。ARKit使得它变得简单对于我们创建AR游戏以及在用户的环境中放入虚拟物体的模拟。通过结合来自设备的运动传感器的信息及其相机的数据，ARKit可以提供帮助iPhone或iPad分析周围环境。苹果也加强了iPhone 8和iPhone X中相机的功能。在iPhone 8和iPhone X相机已经被设计用于低光拍摄和60-fps的视频。iPhone X上的双光学防抖功能和改进的iPhone 8上的光学防抖功能也提供了提高视觉清晰度。这些硬件和软件功能有助于实现游戏在用户环境中更自然地出现。苹果也大力投入改善未来iPhone和iPad的AR功能。</p><p>Unity最近在Unity商店中推出了Unity ARKit。 这使我们更容易为iOS制作AR游戏。因此，在本书中，我将使用Unity ARKit。所以现在是一个安装最新版Unity ARKit的好时机。Unity ARKit的最低要求如下：</p><ul><li><p>支持ARKit且具有最新功能的iOS设备 iOS 11.3或更高版本。</p></li><li><p>安装macOS 10.13（High Sierra）或更高版本的Mac。</p></li><li><p>Unity版2017.1或更高版本。</p></li><li><p>来自于Apple Developer网站的最新版本的XCode 9.3（或更高版本）（需要macOS 10.13）。</p></li></ul><p>现在您已经安装了Unity，现在是时候熟悉Unity ARKit的各种元素了，我们将用它来制作和测试我们的游戏。在我们探索Unity ARKit的不同组件时， 我将讨论开发AR游戏的一些技术原理。由于这是一本介绍性的书，我不会深入研究技术细节，并试图保持这个相对较高的水平。我的编辑让我推荐有关额外AR的书籍，所以我可能会保留关于AR的第二本书的更高级或技术内容。</p><p>现在让我们启动Unity并创建一个新项目。</p><p>当您启动Unity时，您将看到Projects屏幕（图 2-1）。</p><p><img src="/2019/02/27/第二章/1551277997.jpg" alt=""></p><center>图 2-1. Unity Projects屏幕</center><p>选择屏幕右上角的“新建”图标。这将打开 Unity New Project屏幕（图2-2）。在对话框中，键入 在项目名称中，设置Unity文件的位置，输入您组织的名称，并将模板设置为3D。</p><p><img src="/2019/02/27/第二章/1551278189.jpg" alt=""></p><center>图 2-2. Unity New Project屏幕</center><p>在Unity New Project屏幕的对话框中，输入项目名称，选择要保存此文件的位置，然后选择“创建” 项目图标（图2-2）。我选择了AR projects作为文件名并选择了硬盘驱动器上的Users文件夹。</p><p>现在Unity将打开一个空的Unity项目（图 2-3）。</p><p><img src="/2019/02/27/第二章/1551278449.jpg" alt=""></p><center>图 2-3 一个空的Unity项目屏幕</center><h3 id="安装Unity-ARKit"><a href="#安装Unity-ARKit" class="headerlink" title="安装Unity ARKit"></a>安装Unity ARKit</h3><p>现在是安装Unity ARKit的好时机。安装来自Unity Store的Unity ARKit，您将需要访问Unity资产商店。 Unity资产商店可以通过多种方式访问​​。在Unity屏幕的主窗口有一个Assets Store的选项卡，这将显示资产商店窗口。该窗口也可以通过使用Command键和数字9键（⌘+9）。从资产商店下载资产，您需要注册，用Unity去创建一个Unity ID。当您已经创建一个Unity ID，在Unity资产商店的窗口中，有一个搜索栏。在搜索栏中输入ARKit，这将显示符合该搜索条件的文件列表（图 2-4）。在Unity中默认窗口设置将显示Unity商店窗口最小化；使用全屏模式查看资产商店，屏幕的右上角有一个下啦菜单。选中这个并点击鼠标左键。这将显示屏幕选项，Reload（重新加载），Maximize（最大化），Close（关闭）选项卡以及Add（添加）选项卡。选中最大化按钮（点击鼠标左键）。在屏幕的顶部，有很多过滤选项。过滤选项的下面，有符合您搜索条件的资产。双击ARKit，这将加载这个资产的屏幕。选中import（导入）按钮。这个资产将被导入到Unity。（图 2-5）。</p><p><img src="/2019/02/27/第二章/1551309799.jpg" alt=""></p><center>图 2-4. Unity资产商店</center><p><img src="/2019/02/27/第二章/1551309853.jpg" alt=""></p><center>图 2-5. 场景文件夹中带有ARKit的Unity项目文件夹</center><h3 id="编辑器布局"><a href="#编辑器布局" class="headerlink" title="编辑器布局"></a>编辑器布局</h3><p>现在是仔细研究Unity布局的好时机。主窗口被分割成面板。默认显示视图（出厂设置）通过单击视图的选项卡选择区域。视图可以被添加，移动，移除以及缩放，编辑器支持切换布局，所以布局本质上是一种特定的视图排列。例如，主窗口的默认布局（图 2-6）有一个区域包含场景视图（图 2-7）和游戏视图（图 2-8）。</p><p><img src="/2019/02/27/第二章/1551312350.jpg" alt=""></p><center>图 2-6. Unity编辑器默认布局</center><p><img src="/2019/02/27/第二章/1551312381.jpg" alt=""></p><center>图 2-7. 多选项卡区域选中场景视图</center><p><img src="/2019/02/27/第二章/1551312467.jpg" alt=""></p><center>图 2-8. 多选项卡区域选中游戏视图</center><h3 id="预设布局"><a href="#预设布局" class="headerlink" title="预设布局"></a>预设布局</h3><p>默认布局只是几种预设布局中的一种。替代布局可以从主窗口右上角的菜单中选择（图2-9）。 Unity还使我们能够创建自己的布局。在图2-9中，你会看到我的菜单有一个手机游戏配置。这是我的自定义布局，我在创建手机游戏时创建的布局。检验菜单上的各种布局。图2-6至2-7显示了由此产生的布局。</p><p><img src="/2019/02/27/第二章/1551312763.jpg" alt=""></p><center>图 2-9. 布局菜单</center><p>我稍后会更详细地描述各种独特的类型，但是现在，请注意，2-by-3（2×3）布局（图2-10）是布局的示例，场景视图和游戏视图位于不同的区域而不是共用同一个。 4-split（4分割）布局（图2-11）有四个场景视图实例，表明布局不限于每个布局 视图类型。 Tall（高版面）布局（图2-12）提供了一个水平场景视图。 Wide（宽版面）布局（图2-13）提供了一个横向场景视图。</p><p><img src="/2019/02/27/第二章/1551313521.jpg" alt=""></p><center>图 2-10. 2×3布局</center><p><img src="/2019/02/27/第二章/1551313573.jpg" alt=""></p><center>图 2-11. 4分割布局</center><p><img src="/2019/02/27/第二章/1551313606.jpg" alt=""></p><center>图 2-12. 高版面布局</center><p><img src="/2019/02/27/第二章/1551313638.jpg" alt=""></p><center>图 2-13. 宽版面布局</center><h3 id="自定义布局"><a href="#自定义布局" class="headerlink" title="自定义布局"></a>自定义布局</h3><p>预设布局提供了各种工作空间，但幸运的是，您并不仅限于使用它们。 Unity提供了根据需要完全重新排列编辑器窗口的灵活性。</p><h3 id="缩放区域"><a href="#缩放区域" class="headerlink" title="缩放区域"></a>缩放区域</h3><p>对于初学者，您可能会在尝试各种预设布局时注意到有些区域太窄，例如，在宽版面布局（图2-13）中的左侧面板。幸运的是，您可以单击某个区域的边框并拖动它来调整区域大小。</p><h3 id="移动视图"><a href="#移动视图" class="headerlink" title="移动视图"></a>移动视图</h3><p>更酷，你可以移动视图。将视图的选项卡拖动到另一个选项卡区域将移动视图到那。并将选项卡拖动到一个 “对接”区域将创造一个新的区域。比如，以默认局部启动，拖拽Inspector（检视）选项卡到Hierarchy（层级）选项卡的右侧。现在检视器视图与Hierarchy视图共用相同的区域。结果应当看起来如图2-14。</p><p><img src="/2019/02/27/第二章/1551314467.jpg" alt=""></p><center>图 2-14. 自定义视图移动的工作区</center><h3 id="分离视图"><a href="#分离视图" class="headerlink" title="分离视图"></a>分离视图</h3><p>您甚至可以拖拽一个视图到编辑器窗口外面以便它驻留在自己的“浮动”窗口中，可以像任何其他区域一样对待。将“场景”选项卡拖到编辑器外部，使其位于浮动窗口中， 然后将“游戏”选项卡拖动到其选项卡区域。结果应当看起来像图2-15。同样地，将选项卡拖动到浮动的停靠区域，将向窗口添加到另一个区域。</p><blockquote><p>提示 喜欢将游戏视图分离成浮动窗口，因为我在编辑工作之前，我通常不需要看到它直到我单击了“运行”，这样我就可以最大化游戏视图以填充整个屏幕。我也喜欢使用多台显示器。这种方式，我可以最大化我的屏幕空间。</p></blockquote><p><img src="/2019/02/27/第二章/1551314973.jpg" alt=""></p><center>图 2-15. 新视图的列表</center><p>浮动窗口经常被其他窗口掩盖，所以菜单栏上的Windows菜单包含用于制作每个视图的菜单项可见性。请注意，每个都有一个键盘快捷键，还有一个布局子菜单与编辑器内的布局菜单相同。</p><h3 id="添加和移除视图"><a href="#添加和移除视图" class="headerlink" title="添加和移除视图"></a>添加和移除视图</h3><p>您还可以使用菜单中的菜单添加和删除每个区域中的视图 该区域的右上角（图2-15）。“关闭标签”项将删除目前显示的视图。“添加标签”项提供了新视图的列表你可以选择。</p><p>您可能希望为不同的目标平台设置不同的布局，或者开发与游戏测试的不同布局，甚至对于不同的游戏采用不同的布局。例如，我有一个专门为我的自定义布局 以合适的肖像方式预先保存游戏视图的手机游戏 比。每次手动重新配置编辑器都是一件麻烦事 你启动Unity。幸运的是，您可以通过选择来命名和保存布局 布局菜单中的“保存布局”选项，将提示您输入 新布局名称（图2-16）。</p><p><img src="/2019/02/27/第二章/1551532134.jpg" alt=""></p><center> 图 2-16. 提示新布局</center><p>保存后，新布局将列在布局菜单中 如果选择“删除布局”，如果您选择删除布局将从列表中删除布局 （图2-17）。</p><p><img src="/2019/02/27/第二章/1551532322.jpg" alt=""></p><center>图 2-17. 布局删除菜单</center><p>如果您弄乱或删除了原始布局，可以在区域菜单选择中恢复出厂设置选项（图2-18）。这也将删除自定义布局。</p><p><img src="/2019/02/27/第二章/1551532458.jpg" alt=""></p><center>图 2-18. 恢复初始布局设置</center><p>如果更改布局但尚未保存更改，则可以随时丢弃它们，只需在布局菜单中重新选择该布局即可。</p><h3 id="检视器视图"><a href="#检视器视图" class="headerlink" title="检视器视图"></a>检视器视图</h3><p>首先要详细描述的最佳视图是Inspector View，用于显示有关在其他视图中选择的对象的信息。它真的不仅仅是检查员，因为它通常可以用来修改选定的项目。</p><p>检视器视图也被用来显示和调整各种设定，可以在编辑菜单中显示。（图 2-19）。</p><p><img src="/2019/02/27/第二章/1551532784.jpg" alt=""></p><center>图 2-19. 在编辑菜单中显示</center><p>检视器视图显示了编辑器的设定。如果项目目前有metafile，那么版本控制模式被设置到Meta文件中（如果您正在使用Asset Server，这个选项被设置为Asset Server）。为了隐藏metafile，设置版本控制模式为隐藏。（图 2-20）。</p><p><img src="/2019/02/27/第二章/1551532951.jpg" alt=""></p><center>图 2-20. 检视器视图中的编辑器设定</center><p>将版本控制模式设置为已禁用，Unity将删除metafile。资产跟踪现在在项目的Library文件夹里面的二进制文件中处理。</p><blockquote><p><strong>注意</strong> 使用metafile进行版本控制的Unity用户支持还可以选择将资产序列化模式设置为强制文本。在该模式下，Unity场景文件以纯文本格式保存YAML（YAML Ain’t Markup Language）格式。</p></blockquote><p>通常，检视器视图会显示最近选择的对象的属性（当您调出编辑器设置时，您选择它）。但有时您不希望检视器视图发生变化，当你选择其他对象时。在这种情况下，您可以通过选择视图右上方菜单中的“锁定”选项来固定检视器视图到一个对象（图2-21）。</p><p><img src="/2019/02/27/第二章/1551533612.jpg" alt=""></p><center>图 2-21. 锁定检视器视图</center><h3 id="项目视图"><a href="#项目视图" class="headerlink" title="项目视图"></a>项目视图</h3><p>虽然检视器视图可以被认为编辑器中最低级别的视图，因为它显示了仅仅单一对象的属性，项目视图可以被认为是最高级别的视图（图 2-22）。项目视图显示了所有游戏可用的资产，范围从单独的模型，纹理，以及脚本到场景文件的合并资产。所有项目资产都是驻留在项目的Assets文件夹中的文件 （因此您可能希望将项目视图视为资产视图）。</p><p><img src="/2019/02/27/第二章/1551533939.jpg" alt=""></p><center>图 2-22. 项目视图的顶层</center><h3 id="在一列和两列之间切换"><a href="#在一列和两列之间切换" class="headerlink" title="在一列和两列之间切换"></a>在一列和两列之间切换</h3><p>在几个较旧版本的Unity中，项目视图只有一列显示。该选项仍可在项目视图的菜单中找到（单击视图右上角小的三条线图标），现在您可以在一列到两列之间切换。</p><h3 id="缩放图标"><a href="#缩放图标" class="headerlink" title="缩放图标"></a>缩放图标</h3><p>右侧面板中底部的滑块缩放的视图—更大的比例对于纹理来说是很好的，对于没有有趣图标的脚本来说更小的比例较好。这是按资产类型划分资产的一个很好的理由（即将所有纹理放在Textures文件夹中，脚本放在Script文件夹中，等等）。有可能，单级滑块设置不适合资产类型的混合。</p><h3 id="检查资产"><a href="#检查资产" class="headerlink" title="检查资产"></a>检查资产</h3><p>选择右侧的资产将在“检查器视图”中显示该资产的属性。例如，如果选择动画样本，则“检查器视图”将显示有关动画的信息，其中一些可以更改，例如持续时间，甚至可以让您在编辑器中运行动画（图2-23）。我们将在后面的章节中介绍如何更改资产属性，但现在可以在项目视图中选择各种类型的资源，并查看Inspector视图中显示的内容。</p><p><img src="/2019/02/27/第二章/1551534499.jpg" alt=""></p><center>图 2-23. 在项目视图中检视一个选中资产</center><h3 id="资产搜索"><a href="#资产搜索" class="headerlink" title="资产搜索"></a>资产搜索</h3><p>在一个较大复杂的项目中，很难手动搜索一个特定的资产。幸运地，就想在Finder中一样，有一个搜索框可以被用来过滤显示在项目视图右侧面板的结果。如图2-24所示，项目视图显示搜索名称中带有“add”的资产的结果。</p><p><img src="/2019/02/27/第二章/1551534810.jpg" alt=""></p><center>图 2-24. 搜索名称中带有“add”的资产</center><p>右侧面板显示资产（即我们所有资产）下的所有内容的搜索结果。通过选择左侧面板中的一个子文件夹，可以进一步缩小搜索范围。例如，如果您知道自己在寻找场景，并且已根据资产类型将资源安排到子文件夹中，则可以选择要搜索的文件夹。在图2-25中，我在examples文件夹中搜索了文件名带有“add”的任何资产。</p><p><img src="/2019/02/27/第二章/1551535022.jpg" alt=""></p><center>图 2-25. 在指定文件夹中搜索资产</center><p>请注意搜索下方;有一个选项卡，其中包含所选文件夹的名称。您仍然可以单击左侧的“资源”选项卡，查看本地和Unity资源商店中所有资产的搜索结果，我们将在本书中对其进行大量使用。</p><p>您还可以使用搜索框右侧的菜单按资产类型过滤搜索。您可以选择场景作为感兴趣的资产类型，而不仅仅是在Examples文件夹中搜索（图2-26）。请注意这是如何添加到搜索框中生效的。 t：前缀表示应按以下资产类型过滤搜索。您可以在不使用菜单的情况下输入。</p><p><img src="/2019/02/27/第二章/1551535263.jpg" alt=""></p><center>图 2-26. 通过资产类型过滤搜索</center><p>资产类型菜单右侧的按钮用于按标签过滤（您可以在检查器视图中为每个资产分配标签），这对于搜索资产商店也非常方便。最右边的按钮（星号）会将当前搜索保存在左侧面板的“收藏夹”部分中。</p><h3 id="经营资产"><a href="#经营资产" class="headerlink" title="经营资产"></a>经营资产</h3><p>项目视图中的资产可以像Finder中的相应文件一样进行操作。</p><p>双击资产将尝试打开合适的程序以查看或编辑资产。这相当于右键单击资产并选择“打开”。双击场景文件将在此Unity Editor窗口中打开场景，就像您在“文件”菜单中选择了“打开场景”一样。</p><p>您还可以重命名，复制和删除文件，并将文件拖入和拖出文件夹，就像您一样可以在Finder中。当您右键单击资产时，Unity Edit菜单和弹出菜单中的某些操作可用。在接下来的几章中，您将对此进行一些练习。</p><p>同样，在下一章中，您将处理向项目添加资产的工作。这涉及导入文件或导入Unity包，使用菜单栏上的Assets菜单或使用Finder将文件拖到项目的Assets文件夹中。</p><h3 id="Hierarchy视图"><a href="#Hierarchy视图" class="headerlink" title="Hierarchy视图"></a>Hierarchy视图</h3><p>每个游戏引擎都有一个顶级对象，称为GameObject或实体，用于表示具有位置，潜在行为和名称以识别它的任何内容。 UnityGameObject是GameObject类的实例。</p><blockquote><p><strong>注意</strong> 一般来说，当我们引用一种Unity对象时，我们将使用它的类名来精确，并明确如何在脚本中引用该对象。</p></blockquote><p>层次结构视图是当前场景的另一种表示形式。虽然场景视图是您可以像使用内容创建工具一样工作的场景的3D表示，而游戏视图显示了玩游戏时的场景，但是层次结构视图列出了场景中的所有GameObject在易于导航的树形结构中。</p><h3 id="检查GameObject"><a href="#检查GameObject" class="headerlink" title="检查GameObject"></a>检查GameObject</h3><p>单击层次结构视图中的GameObject时，它将成为当前的编辑器选择，其组件将显示在编辑器中。每个GameObject都有一个变换组件，它指定相对于层次结构中父级的位置，旋转和缩放（如果您熟悉3D图形的数学，则变换本质上是对象的变换矩阵）。一些组件为GameObject提供功能（例如，光照是附有光照组件的GameObject）。其他组件引用网格，纹理和脚本等资源。图2-27显示了主摄像机GameObject的组件（在层次结构视图中，GameObject的整个运行器树以蓝色显示，因为它链接到预制件，一种特殊类型的资产，用于克隆一个或一组GameObject）。</p><p><img src="/2019/02/27/第二章/1551535821.jpg" alt=""></p><center>Hierarchy视图和检视视图</center><h3 id="父与子GameObject"><a href="#父与子GameObject" class="headerlink" title="父与子GameObject"></a>父与子GameObject</h3><p>您会发现许多GameObject都按层次排列，因此是该视图的名称。育儿对于概念上组合在一起的GameObject有意义。例如，当您想要移动汽车时，您希望车轮随车一起自动移动。因此，车轮应指定为汽车的儿童，偏离汽车的中心。当车轮转动时，它们相对于汽车的运动转动。育儿还允许我们一次激活或停用整组GameObject。</p><h3 id="场景视图"><a href="#场景视图" class="headerlink" title="场景视图"></a>场景视图</h3><p>虽然Hierarchy视图允许我们在当前场景中创建，检查和修改GameObjects，但它并没有为我们提供一种可视化场景的方法。这就是场景视图的用武之地。场景视图类似于3D建模应用程序的界面。它允许您从任何3D有利位置检查和修改场景，并让您了解最终产品的外观。</p><h3 id="场景导航"><a href="#场景导航" class="headerlink" title="场景导航"></a>场景导航</h3><p>如果您不熟悉在3D空间中工作，那么在2D工作中这是一个简单的扩展。而不是仅仅在具有x和y轴以及（x，y）坐标的空间中工作，在3D空间中，您具有额外的z轴和（x，y，z）坐标。 x轴和z轴定义地平面，y-指向上方（您可以将y视为高度）。</p><blockquote><p><strong>注意</strong> 一些3D应用程序和游戏引擎使用z轴表示高度，使用x轴和y轴作为地平面，因此在导入资源时，您可能需要调整（旋转）它们。</p></blockquote><p>3D空间中的视点通常称为相机。单击右上角多色场景Gizmo的x，y和z箭头可以快速翻转相机，使其面向相应的轴。例如，单击y箭头可以看到场景的俯视图（图2-28），场景Gizmo下的文本显示“Top”。</p><p><img src="/2019/02/27/第二章/1551536198.jpg" alt=""></p><center>图 2-28. 场景视图的顶级视图</center><p>这里的摄像机与游戏中使用的场景中的CameraGameObject不同，因此当您在场景视图中环顾四周时，您不必担心会弄乱游戏。</p><p>为了演示如何使用导航工具，我从项目文件夹中选择了PlayerGameObject并将其拖到层次结构视图中。</p><p>单击“场景Gizmo”中心的框可在透视图之间切换摄像机投影，从而使对象在远处后退时变小;和正交，无论是近距离还是远距离，它们都以原始尺寸呈现。透视更加真实，而且你通常在游戏中使用它，但正交设计在设计时通常更方便（因此它在计算机辅助设计应用中无处不在）。场景Gizmo下文本前面的小图形表示当前投影。</p><p>您可以使用鼠标滚轮或在“编辑器”窗口的右上方工具栏中选择“手形”工具进行放大和缩小，并在按住Control键的同时单击并拖动鼠标。选择“手形”工具后，您还可以通过单击拖动视图来移动相机，并且可以在按住Option（或Alt）键的同时拖动鼠标来旋转（环绕）相机，这样您就不会受到限制只是轴摄像机的角度，如图2-29所示。</p><p><img src="/2019/02/27/第二章/1551536399.jpg" alt=""></p><center>图 2-29. 场景视图中的倾斜透视</center><p>请注意，当您从任意角度查看时，场景Gizmo下的文本会显示Persp或Iso，具体取决于您是使用透视投影还是正投影（Iso是等长投影的缩写，这是游戏中常见的倾斜正交视图喜欢星际争霸）。</p><p>工具栏上的其他按钮激活用于移动，旋转和缩放GameObject的模式。目前没有理由改变它们，因此当您开始创建新项目时，将更详细地解释这些模式。</p><blockquote><p><strong>提示</strong> 如果您不小心对场景进行了更改，可以从“编辑”菜单中选择“撤消”。如果你做了很多你不想保留的更改，当你切换到另一个场景或退出Unity时，你可以拒绝保存这个场景。在此期间，请注意您仍然可以在这些模式下使用备用键盘和鼠标组合移动相机。表2-1列出了所有可能的选项。</p></blockquote><p>表 2-1. 可用的场景视图相机控件</p><table><thead><tr><th>功能</th><th>手工工具</th><th>一键鼠标或触摸板</th><th>两键鼠标</th><th>三键鼠标</th></tr></thead><tbody><tr><td>移动</td><td>按住-拖拽</td><td>按住Alt-Command并按住-拖拽</td><td>按住Alt-Control按住-拖拽</td><td>按住Alt和中键按住-拖拽</td></tr><tr><td>旋转</td><td>按住Alt键并按住-拖拽</td><td>按住Alt键按住-拖拽</td><td>按住Alt键并按住-拖拽</td><td>按住Alt并按住-拖拽</td></tr><tr><td>缩放</td><td>按住Control键按住-拖拽</td><td>按住Control键按住-拖拽或者两指滑动</td><td>按住Alt键并右键按住-拖拽</td><td>按住Alt键并右键按住-拖拽或者滑动滚轮</td></tr></tbody></table><p>还有一些其他方便的基于键盘的场景导航功能。按箭头键将沿x-z平面（地平面）向前，向后，向左和向右移动摄像机。按住鼠标右键可以像在第一人称游戏中一样导航场景。 AWSD键分别向左，向前，向右和向后移动，并移动鼠标控制相机（视点）所在的位置。</p><p>当你想在场景视图中查看特定的GameObject时，有时最快的方法是在Hierarchy视图中选择GameObject，然后使用Edit菜单中的Frame Selected菜单项（注意方便的快捷键F） 。在图2-28中，我单击Scene Gizmo的x轴以获得水平视图，然后在Hierarchy View中选择Player GameObject，并按下F键（Edit菜单中选择Frame的快捷键）进行缩放在场景视图中的运行器中心和居中。</p><p>您也可以直接在“场景视图”中选择一个GameObject，但必须先退出“手形”工具。就像在层次结构视图中选择GameObject将导致在Scene View和Inspector View中显示该选择一样，在Scene View中选择GameObject同样会在Inspector视图中显示该选择，并在层次结构中将其显示为选定的GameObject视图。在图2-30中，在我调用运行器上的Frame Selected后，我单击了Move工具（编辑器窗口右上角的Hand工具按钮右侧的按钮），然后在Player中单击了Player附近的GameObject。场景视图。层次结构视图自动更新以显示已选择GameObject，并且游戏对象也显示在检查器视图中。</p><p><img src="/2019/02/27/第二章/1551537481.jpg" alt=""></p><center>图 2-30. 在场景视图中选中一个GameObject</center><h3 id="场景视图选项"><a href="#场景视图选项" class="headerlink" title="场景视图选项"></a>场景视图选项</h3><p>位于场景视图顶部的按钮提供显示选项，以帮助您进行游戏开发。每个按钮配置一个视图模式。</p><p>最左边的按钮设置绘图模式。通常，此模式设置为“纹理”，但如果要查看所有多边形，可以将其设置为“线框”（图2-31）。</p><p><img src="/2019/02/27/第二章/1551537584.jpg" alt=""></p><center>图 2-31. “场景”视图中的线框显示</center><p>下一个按钮设置“渲染路径”，它控制场景是正常着色还是用于诊断。 </p><p>“渲染路径”模式按钮右侧的三个按钮是简单的切换按钮。当你将鼠标悬停在它们上面时，它们会弹出一些鼠标悬停文档（也称为工具提示）。</p><p>第一个控制场景光照模式。这在使用场景视图中的默认光照方案或您放置在游戏中的实际光照之间切换。</p><p>中间按钮切换游戏覆盖模式，无论天空，镜头光晕和雾效果是否可见。</p><p>最后，还有Audition模式，可以打开和关闭声音。</p><h3 id="场景视图Gizmos"><a href="#场景视图Gizmos" class="headerlink" title="场景视图Gizmos"></a>场景视图Gizmos</h3><p>右侧的Gizmos按钮激活与组件关联的诊断图形的显示。图2-32中的场景视图显示了一些小玩意儿。通过单击Gizmos按钮并检查可用小玩意列表，您可以看到代表摄像机和灯光的那些图标。</p><p><img src="/2019/02/27/第二章/1551537792.jpg" alt=""></p><center>图 2-32. 场景视图中的Gizmos</center><p>您可以选择和取消选择Gizmos窗口中的各个复选框，以便专注于您感兴趣的对象。左上角的复选框在小玩意的3D显示或2D图标之间切换。相邻的滑块控制小玩意的比例（因此隐藏所有小玩意的快速方法是将比例滑块一直拖动到左侧）。</p><h3 id="游戏视图"><a href="#游戏视图" class="headerlink" title="游戏视图"></a>游戏视图</h3><p>现在让我们来看看游戏视图。与层次结构视图和场景视图一样，游戏视图描绘当前场景，但不用于编辑目的。相反，游戏视图用于运行和调试游戏。</p><p>单击Unity Editor窗口顶部的“运行”按钮时，将自动显示“游戏视图”。如果单击“运行”时没有现有的“游戏视图”，则会创建一个新的游戏视图。如果在编辑器未处于运行模式时游戏视图可见，则它显示游戏处于其初始状态（即，从初始摄像机位置的有利位置）。</p><p>游戏视图显示了游戏在实际部署时的外观和功能，但可能与最终构建目标的外观和行为有所不同。一个可能的区别是游戏视图的大小和宽高比。可以使用视图左上角的菜单更改此设置。图2-33显示了当您从调整视图尺寸的自由宽高比切换到5：4宽高比时会发生什么情况，从而缩小游戏显示范围，使其适合区域和保持所选的宽高比。</p><p><img src="/2019/02/27/第二章/1551537981.jpg" alt=""></p><center>图 2-33. 游戏视图</center><h3 id="运行时最大化"><a href="#运行时最大化" class="headerlink" title="运行时最大化"></a>运行时最大化</h3><p>单击“运行时最大化”按钮将导致游戏视图扩展，以便在运行模式下填充整个编辑器窗口（图2-34）。如果视图与“编辑器”窗口分离，则该按钮无效。</p><p><img src="/2019/02/27/第二章/1551538132.jpg" alt=""></p><center>图 2-34. 游戏视图运行时最大化</center><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>“统计”按钮显示有关场景的统计信息（图2-35）随着游戏的运行而更新。</p><p><img src="/2019/02/27/第二章/1551538234.jpg" alt=""></p><center>图 2-35. 带有统计的游戏视图</center><h3 id="游戏视图Gizmos"><a href="#游戏视图Gizmos" class="headerlink" title="游戏视图Gizmos"></a>游戏视图Gizmos</h3><p>Gizmos按钮可激活与组件关联的诊断图形的显示。图2-36中的游戏视图显示了两个图标，它们是音频源的小玩意。 Gizmos按钮右侧的列表允许您选择要显示的小玩意。</p><p><img src="/2019/02/27/第二章/1551538327.jpg" alt=""></p><center>图 2-36. 带有Gizmos的游戏视图</center><p>游戏视图和场景视图都是当前场景的描绘。 Unity项目由一个或多个场景组成，Unity Editor一次打开一个场景。将项目视为游戏，将场景视为关卡（实际上，在场景中运行的一些Unity脚本函数在其名称中使用“级别”）。通过附加组件使Unity GameObject变得有趣，每个组件都提供一些特定的信息或行为。这就是Inspector View的用武之地。如果在Hierarchy View或Scene View中选择一个游戏对象，Inspector View将显示其附加的组件。</p><h3 id="控制台视图"><a href="#控制台视图" class="headerlink" title="控制台视图"></a>控制台视图</h3><p>所有预设布局中的剩余视图（控制台视图）很容易被忽略，但它非常有用（图2-37）。</p><p><img src="/2019/02/27/第二章/1551538502.jpg" alt=""></p><center>图 2-37. 控制台视图</center><p>控制台视图中显示信息，警告和错误消息。错误为红色，警告为黄色，信息性消息为白色。从列表中选择一条消息会在下方区域显示更多详细信息。此外，Unity Editor底部的单行区域显示最新的Console消息，因此即使Console视图不可见，您也始终可以看到已记录消息。</p><blockquote><p><strong>提示</strong> 警告消息很容易被忽略，但您可以自行忽略它们。它们是有原因的，通常表明必须解决的问题。如果你让警告累积起来，很难注意到一个非常重要的警告何时出现。</p></blockquote><p>控制台很快就会混乱。您可以使用控制台视图顶部最左侧的三个按钮来管理这种混乱。清除切换按钮可删除所有消息。 “折叠切换”按钮组合了类似的消息。每次编辑器进入播放模式时，清除播放切换将删除所有消息。</p><p>错误暂停按钮将导致编辑器暂停错误消息，特别是当脚本调用Log.LogError时。</p><p>在编辑器中操作时，日志消息最终会出现在编辑器日志中，而从Unity构建的可执行文件生成的消息将被定向到播放器日志。从视图菜单中选择Open Player Log或Open Editor Log（单击Console视图右上角的小图标）将在文本文件或控制台应用程序中显示这些日志（图2-38）。</p><p><img src="/2019/02/27/第二章/1551538673.jpg" alt=""></p><center>图 2-38. Mac控制台应用中的Unity日志</center><h3 id="进一步探索"><a href="#进一步探索" class="headerlink" title="进一步探索"></a>进一步探索</h3><p>我们已经结束了这次Unity之旅。在第3章中，您将开始学习一些ARKit功能。这是真正开始使用Unity的第一章。您还没有开始构建自己的场景（将在第3章开始），但您已经能够熟悉Unity编辑器。有很多官方Unity资源可以扩展我将要讨论的主题。</p><h3 id="Unity手册"><a href="#Unity手册" class="headerlink" title="Unity手册"></a>Unity手册</h3><p>正如您所看到的，Unity用户界面很多，我们几乎都没有。现在是认真阅读Unity手册的好时机，可以从Unity编辑器（欢迎屏幕或帮助菜单）或Unity网站（<a href="http://unity3d.com/）下的学习选项卡下阅读“文档”部分。当您想要查看某些内容或只是阅读Unity而没有在附近运行Unity" target="_blank" rel="noopener">http://unity3d.com/）下的学习选项卡下阅读“文档”部分。当您想要查看某些内容或只是阅读Unity而没有在附近运行Unity</a> Editor时，Web版本非常方便。</p><p>本章介绍的大部分内容与Unity手册的Unity基础部分中的主题相匹配，特别是“学习界面”，“自定义工作区”，“发布构建”和“Unity热键”部分。我们确实跳过了进入Unity手册的高级部分，触及Unity对版本控制的支持。 Unity手册的“使用Unity进行外部版本控制”页面对此进行了更深入的介绍。</p><h3 id="指南"><a href="#指南" class="headerlink" title="指南"></a>指南</h3><p>除了“文档”部分，Unity网站上的“学习”选项卡还包含一个“教程”部分，其中包含大量的初级编辑器视频。顾名思义，这些视频介绍了Unity编辑器，实际上这组视频涵盖了本章讨论的大部分内容，包括最重要视图的描述（游戏视图，场景视图，层次结构视图，检查器视图，和Project View）甚至是发布构建的过程。</p><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>虽然我只是简单地讨论了版本控制，但在解释如何删除元文件的上下文中，该主题值得多讨论，因为版本控制系统（或VCS）对于软件开发非常重要（您将首先实现它）你失去你的项目的时间或不记得你做了什么改变打破了你的游戏！）。如果你已经有了一个最喜欢的VCS，你可能想在Unity中使用它，如果你还没有使用它，那么你可能想要考虑它，如果只是保留你的项目的旧版本，以防你需要滚动返回，能够检查版本之间的差异。</p><p>在版本控制系统中，Perforce是游戏工作室中常用的商业工具，而Subversion（svn）作为开源选项有着悠久的历史。目前，像Git和Mercurial这样的分布式版本控制系统正在发展趋势。我在Bitbucket上使用Mercurial（http：// bitbucket.com /）作为我的内部项目并在GitHub上发布公共项目，包括本书的项目。</p><p>说Unity VCS支持与产品无关是另一种说法，Unity没有任何特定的版本控制系统集成到Unity Editor中。 Unity Pro用户的元文件和YAML场景文件只是提供了与常用于源代码的面向文本的版本控制系统的更好兼容性。您仍然必须在Unity之外自己运行VCS操作。顺便提一下，您可以在<a href="http://yaml.org/上找到有关YAML的更多信息。我发现使用GitHub网站上提供的Mac" target="_blank" rel="noopener">http://yaml.org/上找到有关YAML的更多信息。我发现使用GitHub网站上提供的Mac</a> GitHub应用程序和类似的BitTucket SourceTree也很方便，也可以在该网站上找到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第二章&quot;&gt;&lt;a href=&quot;#第二章&quot; class=&quot;headerlink&quot; title=&quot;第二章&quot;&gt;&lt;/a&gt;第二章&lt;/h1&gt;&lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第一章</title>
    <link href="https://zhaolilong.com/2019/02/25/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://zhaolilong.com/2019/02/25/第一章/</id>
    <published>2019-02-25T00:31:18.000Z</published>
    <updated>2020-03-10T01:56:09.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本书中，我们将学习如何去创建一个增强现实（AR）游戏使用游戏开发软件Unity（Unity3D 2018或者更新版本， Unity）。本章中，我们将通过下载和安装Unity的过程，了解Unity提供的一些工具。我们也将安装一个来自Unity Asset Store存在的AR项目，探索这个游戏的一些特性。第二章，我们将安装ARKit和提供一个Unity用户界面的概览。第三章，我们将开始使用Unity ARKit并使用一些关键的功能。我还将提供视觉惯性测距的基本概述以及这对创建AR项目的意义。我们将使用基本场景并测试Unity ARKit。在第四章，我们将使用一些Unity ARKit中更高级的功能，例如AR场景的命中测试和光照。最后，第五章，我们将把所有这些结合起来，使用Unity ARKit来制作一款AR游戏。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本书是为没有使用Unity或制作游戏的经验的初学者编写的。这些章节按顺序编写，以帮助每一步的学习。但是，如果您正在阅读本书并且已经了解Unity或制作游戏，那么请随意跳过您认为已经知道的章节。</p><h3 id="Unity3D"><a href="#Unity3D" class="headerlink" title="Unity3D"></a>Unity3D</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unity游戏引擎是一个创建2D和3D游戏的跨平台游戏开发工具。跨平台不同的人有不同的理解。Unity可以被使用在macOS，Windows，或者Linux上，这可以被认为是一个跨平台开发工具。但是，Unity可以用来开发游戏机，个人计算机，网络浏览器，移动设备，VR系统的游戏等等，这也可能是Unity被认为是跨平台开发工具的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unity可用于创建3D游戏，也就是说，游戏看起来像是在3D空间中运行（它有X，Y和Z）。Unity也可用于创建2D游戏。最近，Unity已经用于创建VR和AR游戏或者模拟。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本书中，我们将使用Unity最新版本，当前是2018.1版本。然而，像大多数软件（和很多硬件）一样，Unity不断推出新特性和新功能，到本书印刷时，可能会有更新版本的Unity。当Unity对其软件进行微小更改时，通常会添加一个数字（如2018.1.1）。当更新有点重要时，版本号将会改变（如2018.2）。当Unity通常进行重大更改时，版本号将完全更改（Unity 1,2,3,4,5）。 2017年7月，Unity将版本编号系统更改为发布年份（2017年和2018年）。</p><h3 id="Unity要求"><a href="#Unity要求" class="headerlink" title="Unity要求"></a>Unity要求</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你开始学习制作游戏之前，你将需要下载Unity并安装它在你的Mac上。虽然可以在Windows个人计算机上安装带有Unity的iOS设备的游戏，但您需要使用一个名为Xcode的软件来移植Unity代码，以便它可以在Mac或iOS设备上运行。目前，Xcode仅适用于Mac。所以，如果你有一台Windows PC，那么在某个阶段你需要使用Mac来移植游戏。在本书中，我将使用Mac;如果您使用的是Windows PC，则许多说明或说明可能不适用于您。</p><h3 id="准备你的Mac"><a href="#准备你的Mac" class="headerlink" title="准备你的Mac"></a>准备你的Mac</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于使用Unity的iOS开发，您需要一台运行Mac OS X 10.9或更高版本的Lion或Mountain Lion以及Xcode 7.0或更高版本的Mac。 Unity 2018仍然可以在一些较旧的系统上运行，但是您需要最新版本的Xcode，如上所述，这是iOS开发所必需的。最新版本的Xcode通常支持更新版本的iOS。在撰写本文时，Xcode的当前版本是版本9，这是我将在本书中使用的内容。</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我强烈建议您查看Apple开发人员网站（<a href="https://developer.apple.com/" target="_blank" rel="noopener">https://developer.apple.com/</a>）并注册为iOS开发人员。虽然这不是本书的绝对要求，但如果您想在App Store上发布游戏，那么您将需要成为注册的Apple Developer。注册为Apple Developer的过程可能需要一段时间，尤其是如果您正在注册公司。第一步是注册为Apple Developer（目前是免费的），然后一旦注册，下一步就是注册为iOS开发人员（目前每年99美元）。</p><h3 id="下载Xcode"><a href="#下载Xcode" class="headerlink" title="下载Xcode"></a>下载Xcode</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本书的后面部分，你不需要Xcode，但值得下载和安装Xcode。您可以在Apple Developer网站（<a href="https://developer.apple.com/" target="_blank" rel="noopener">https://developer.apple.com/</a>）上找到最新版本的Xcode。</p><h3 id="下载Unity"><a href="#下载Unity" class="headerlink" title="下载Unity"></a>下载Unity</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在是安装Unity的好时机。访问Unity网站<a href="https://unity3d.com" target="_blank" rel="noopener">https://unity3d.com</a>，然后选择Get Unity或输入[https:// store.unity.com/](https:// store.unity.com/)。在此页面上，您将找到Unity的最新版本（在撰写本文时，2018.1）。您还可以在Unity网站上找到Unity的早期版本。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然只有一个Unity应用程序，但您可以订阅不同的许可选项，具体取决于您的需求和公司规模（如果有的话）。三种许可选项目前是Personal，Plus和Pro。要开始下载过程，请单击符合您需求的订阅选项按钮（在撰写本文时，这将是Try Personal，Get Plus或Go Pro）。该文件大约为1GB，因此下载可能需要一段时间。在你等待的时候，你在Unity网站上，花一些时间查看已发布的一些游戏和演示，社区网站和用户论坛。这些在使用Unity的游戏开发过程中非常有用。</p><h3 id="安装Unity"><a href="#安装Unity" class="headerlink" title="安装Unity"></a>安装Unity</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您从Unity下载的文件是一个下载安装程序，在撰写本文时名为UnityDownloadAssistant。</p><h3 id="运行下载助手"><a href="#运行下载助手" class="headerlink" title="运行下载助手"></a>运行下载助手</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下载UnityDownloadAssistant文件后，双击该文件以运行Unity Download Assistant。双击Unity Download Assistant图标以开始安装Unity（图1-1）。</p><p><img src="/2019/02/25/第一章/1551054573.jpg" alt=""></p><p>图 1-1. Unity下载助手</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装程序将处理整个安装周期，当这个完成的时候，一个Unity的文件夹将会被放置在Applications文件夹里（除非你选择了一个不同的安装位置）。如果您安装了以前版本的Unity，新版本的安装可能替换以前的版本。我建议在安装新版本之前重命名以前版本的文件夹（例如，Unity2017）。这样您仍然可以使用Unity的两个版本。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unity安装文件夹包含Unity应用程序和几个支持文件夹和应用程序（图 1-2）。</p><p><img src="/2019/02/25/第一章/1551188404.jpg" alt=""></p><p>图 1-2 Unity安装文件夹</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unity文件夹中最重要的文件之一是Unity应用程序，它将提供一些工具用来创建和测试您的游戏。应用程序有时有时称为Unity编辑器，不同于其他程序，Unity运行时引擎（也称为Unity播放器）。Unity运行时引擎已集成到最终版本，这将使游戏能够在目标硬件上运行。当我提到Unity时，通常指的是Unity编辑器。 我有时会将Unity技术称为Unity。但如果顺利的话，上下文是明确的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Documentation文件夹包含用户手册，组件参考，脚本参考文档。这些在Unity网站上也是可用的（选择学习链接）。所有这些文档都是HTML文档，从Unity Help菜单系统中可以用浏览器打开，或者可以双击直接打开它们。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Standard Assets文件夹包含许多以.unityPackage作为文件扩展名的文件。这些是Unity的包文件，它包含Unity资产的集合，可以被导入Unity。它也可能创建你自己的标准资产并导出这些资产为一个包文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有Unity Bug Reporter应用程序。这个应用程序是通常直接在Unity编辑器中运行Report a Bug功能。然而，这个应用程序从Unity安装文件夹直接运行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您在Unity安装时下载了样例项目，确保在Unity中打开这些。如果您在安装时不下载这些。它仍然可以在任何时候呗下载。</p><h3 id="欢迎"><a href="#欢迎" class="headerlink" title="欢迎"></a>欢迎</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Unity安装完成后（做好准备需要一段时间），Unity编辑器欢迎界面将出现Unity Hello！窗口（图 1-3）。Unity Hello！窗口是您登录Unity账户的地方（如果您有的话）。如果您没有Unity账户，选择Create One链接。如果您当前没有连接网络，您可以通过选择Work offline按钮进行离线工作。</p><p><img src="/2019/02/25/第一章/1551190638.jpg" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当您启动Unity（图 1-3）时Unity Hello！窗口将会出现。我强烈建议创建一个Unity账户，如果您还没有创建的话。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首次登录以后，您将会看到License管理界面。如果您已经付费了Unity的授权版本，在对话框中输入你的授权序列号。请输入您的许可证 对话框中的序列号。如果你想使用免费版的Unity， 选择Unity Personal单选按钮（图 1-4）。</p><p><img src="/2019/02/25/第一章/1551222294.jpg" alt=""></p><p>图 1-4 Unity授权管理界面</p><h3 id="设置Unity"><a href="#设置Unity" class="headerlink" title="设置Unity"></a>设置Unity</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们开始使用Unity制作游戏之前，现在是查看Unity的一些选项和管理功能的好时机。</p><h3 id="改变外观（Pro版）"><a href="#改变外观（Pro版）" class="headerlink" title="改变外观（Pro版）"></a>改变外观（Pro版）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你已经购买了一个Unity的Pro授权，你将能够在浅色或深色之间选择。如果你正在使用Unity的免费版本，你讲只能看到浅色外观。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为大多数游戏开发的初学者使用Unity的免费版本，我将使用浅色外观截屏。对于这本书的纸质版本浅色外观也能产生更好的截屏效果。如果你有高级版本并且想去改变外观，选择Unity菜单中的Prefrences（偏好设置）项（图 1-5）</p><p><img src="/2019/02/25/第一章/1551223091.jpg" alt=""></p><p>图 1-5 Unity偏好设置菜单</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着偏好设置菜单的打开，你可以改变皮肤用深色到浅色或浅色到深色（图 1-6）如果你正在使用Unity个人版本，您被迫接受浅色皮肤。</p><p><img src="/2019/02/25/第一章/1551223299.jpg" alt=""></p><p>图 1-6 Unity编辑器中的通用偏好设置菜单</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当您已经打开偏好设置菜单时，我建议确保启动时加载以前的项目选项是未选中的。这将确保Unity在启动时加载项目选择对话框。这将确保您避免更新错误的版本或者在准备好之前更新您正在使用的Unity版本。</p><h3 id="报告问题"><a href="#报告问题" class="headerlink" title="报告问题"></a>报告问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你继续使用Unity几年，你将遇到一些bug（真实的和想象中的）。我从1.6版本使用Unity并遇到了很多Unity的bug。软件的bug对于Unity不是唯一的。一个游戏开发引擎是软件中复杂的一片并且Unity肯定赞赏并重视错误报告。如果bug不被报告，那么Unity很难修复它们。Unity Bug Reporter应用程序提供了这个特性。正如前面提到的，报告一个Bug Report可在Unity安装文件夹中找到，也可从Unity编辑器的“帮助”菜单中选择（图1-7）。</p><p><img src="/2019/02/25/第一章/1551224060.jpg" alt=""></p><p>图 1-7 帮助菜单中的报告Bug选项</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在帮助菜单上选择Report a Bug选项或者在Unity安装文件夹中双击Report a Bug应用程序来打开Unity Report a Bug应用程序（图 1-8）。该应用程序提供菜单选项和对话框，供用户指定问题是关于什么的，问题发生的频率，bug的标题，bug的细节，以及附加任何有助于修复的相关文件的选项。Unity Bug Reporter需要用户指定一个email地址以便于Unity团队可以回复bug报告者。</p><p><img src="/2019/02/25/第一章/1551224778.jpg" alt=""></p><p>图 1-8 Unity Bug Reporter窗口</p><h3 id="iOS开发要求"><a href="#iOS开发要求" class="headerlink" title="iOS开发要求"></a>iOS开发要求</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面的章节中，我建议下载Xcode和注册苹果开发者计划是一个好的主意。如果你还没有做好。现在是停下来做这些的好时机。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于iOS开发的硬件和软件要求以及关于苹果开发者计划的细节列在苹果开发者支持页面(<a href="https://developer.apple.com" target="_blank" rel="noopener">https://developer.apple.com</a>)上。你也可以找到Xcode的要求和下载页面，网址为<a href="https://developer.apple.com/Xcode/" target="_blank" rel="noopener">https://developer.apple.com/Xcode/</a>。</p><h3 id="Unity网站"><a href="#Unity网站" class="headerlink" title="Unity网站"></a>Unity网站</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着Unity Technologies增加Unity的特性和功能，内容的广度和深度也增加了。网站上有大量的信息，但是我建议看看FAQ部分（<a href="https://unity3d.com/unity/faq" target="_blank" rel="noopener">https://unity3d.com/unity/faq</a>）。也有一些非常棒的指南，文档，以及视频，这些将帮助你使用Unity（<a href="https://unity3d.com/unity/faq" target="_blank" rel="noopener">https://unity3d.com/unity/faq</a>）来学习创建游戏。</p><h3 id="Unity社区"><a href="#Unity社区" class="headerlink" title="Unity社区"></a>Unity社区</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在帮助菜单中，有官方的Unity社区网站链接。这包含了官方Unity论坛（<a href="https://forum.unity.com" target="_blank" rel="noopener">https://forum.unity.com</a>），由Unity工作人员主持。对于任何游戏开发者而言这是非常棒的资源。这个菜单上还有Unity Answers的链接，它使用了一个Stack Exchange格式并包含一些控制（或审核） 问题和解答。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unity反馈网站（<a href="https://feedback.unity3d.com" target="_blank" rel="noopener">https://feedback.unity3d.com</a>）让开发者能够在未来可能的特性上发出请求或者投票。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>增强现实交互</title>
    <link href="https://zhaolilong.com/2018/06/20/%E5%A2%9E%E5%BC%BA%E7%8E%B0%E5%AE%9E%E4%BA%A4%E4%BA%92/"/>
    <id>https://zhaolilong.com/2018/06/20/增强现实交互/</id>
    <published>2018-06-20T08:47:03.000Z</published>
    <updated>2020-03-10T01:56:09.669Z</updated>
    
    <content type="html"><![CDATA[<p>在真实世界场景中显示虚拟物体可能是很有趣的，但是你想做得更多而不仅仅是在一个场景上覆盖静态图片。另外在场景中显示虚拟物体，ARKit也可以使得虚拟物体在屏幕上移动，给用户与虚拟物体交互的能力，通过触摸手势，例如点击或者滑动。</p><a id="more"></a><p>例如，一个用户可能想点击一个虚拟物体来使得它移动或者以某种方式响应，例如改变它的外观或者在屏幕上移动。通过制作增强现实交互，你的应用可能更感兴趣和赞同。</p><blockquote><p><strong>注意</strong> 你仅仅可以测试和运行ARKit应用在iPhone 6s或者更高，或者一个iPad Pro上。</p></blockquote><p>让我们创建一个新的增强现实应项目，命名为ARGesture。这个项目将包含一个AppDelegate.swift文件，一个ViewController.swift文件和一个Main.storyboard文件，还有art.scnassets文件夹，它包含了一个ship.scn对象和一个texture.png文件。</p><p>我们的目标是创建一个几何模型并在屏幕上显示它。然后用户可以在那个模型上滑动并使得它旋转。为了做到这点，我们将需要学习一些技能。</p><p>首先，大多数人熟悉操作几何模型使用角度，但是苹果的SceneKit框架使用弧度。我们可以编写我们自己的公式去转换角度到弧度，但是苹果提供了一个数学框架叫作GLKit，它包含了一个可以执行这个计算的函数。作为一个通用的规则，尽可能依赖苹果框架总是最好的，而不是编写你自己的函数，因为苹果框架被测试过，而你讲不得不花费时间调试和测试你自己的函数。</p><p>在ViewController.swift文件的顶部，添加以下行导入GLKit框架</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GLKit</span><br></pre></td></tr></table></figure><p>你的ViewController.swift文件应该导入GLKit，UIKit，SceneKit和ARKit框架总共四个import语句。</p><p>接下来，我们需要创建一个节点，该节点代表我们想添加到屏幕上的几何模型。这意味着创建一个SCNNode对象。因为我们将需要访问这个对象在不止一个方法中，创建这个作为一个IBOutlet属性，所以ViewController.swift文件顶部应当看起来像这样:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br><span class="line"><span class="keyword">import</span> GLKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> sceneView: <span class="type">ARSCNView</span>!</span><br><span class="line">    <span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br></pre></td></tr></table></figure><p>在viewDidLoad函数中，我们可以添加调试选项，将在屏幕上显示世界原点。你可能不想显示世界原点在最终的应用中，但是它可以当你开发应用时是有用的，显示给你虚拟物体出现在屏幕的位置。添加以下行在viewDidLoad函数中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br></pre></td></tr></table></figure><h2 id="存储和访问图形资产"><a href="#存储和访问图形资产" class="headerlink" title="存储和访问图形资产"></a>存储和访问图形资产</h2><p>现在我们需要创建一个几何模型。在这种情况下，我们想创建一个金字塔，所以我们将需要定义它的宽，高和长。另外，我们也想去应用一个纹理到我们的金字塔上。</p><p>增强现实应用项目引入了两个图像文件：ship.scn和texture.png。我们将不显示ship.scn文件，所以你可以删除代码，显示这个ship.scn在屏幕上。然而，我们想去使用texture.png文件。</p><p>在前一章节中，你看到了如何使用一个纹理图像图片通过简单地定义它的名字像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> material = <span class="type">SCNMaterial</span>()</span><br><span class="line">material.diffuse.contents = <span class="type">UIImage</span>(named: <span class="string">"stone.jpg"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在真实世界场景中显示虚拟物体可能是很有趣的，但是你想做得更多而不仅仅是在一个场景上覆盖静态图片。另外在场景中显示虚拟物体，ARKit也可以使得虚拟物体在屏幕上移动，给用户与虚拟物体交互的能力，通过触摸手势，例如点击或者滑动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AR" scheme="https://zhaolilong.com/tags/AR/"/>
    
      <category term="增强现实" scheme="https://zhaolilong.com/tags/%E5%A2%9E%E5%BC%BA%E7%8E%B0%E5%AE%9E/"/>
    
  </entry>
  
  <entry>
    <title>Metal编程指南</title>
    <link href="https://zhaolilong.com/2018/06/10/Metal%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <id>https://zhaolilong.com/2018/06/10/Metal编程指南/</id>
    <published>2018-06-10T02:03:53.000Z</published>
    <updated>2020-03-10T01:56:09.668Z</updated>
    
    <content type="html"><![CDATA[<ul><li>[Metal基础概念] 简明的描述Metal的主要特性。</li><li>[命令组成和执行模型] 解释如何创建和提交命令到GPU执行。</li><li>[资源对象:缓冲和纹理] 讨论设备内存管理，包括表现GPU内存分配的缓冲和纹理对象。</li><li>[函数和库] 描述Metal着色语言代码如何被呈现在一个Metal应用中，Metal着色语言代码在GPU上如何被加载和执行的。</li><li>[图像渲染:渲染命令编码器] 描述如何渲染3D图像，包括如何穿过多个线程来分配图形操作。</li><li>[数据并行计算处理:计算命令编码器] 阐述如何执行数据并行处理。</li><li>[缓冲和纹理操作:位命令编码器] 描述如何在纹理和缓冲之间拷贝数据。</li></ul><a id="more"></a><h2 id="Metal基本概念"><a href="#Metal基本概念" class="headerlink" title="Metal基本概念"></a>Metal基本概念</h2><p>Metal对于图像和数据并行计算工作量提供了一个单一的，统一的编程接口和语言。Metal使得你能够整合图像和计算任务更高效而不需要使用分离的API和着色语言。</p><blockquote><p>Metal框架提供了如下特性:</p></blockquote><ul><li><p><strong>低功耗接口。</strong>Metal被设计消除潜在的性能瓶颈，例如显式的状态校验。你可以控制GPU的异步行为，对于用来并行创建和提交命令缓冲有效的多线程。</p><p>关于Metal命令提交的细节，参见[命令组成和执行模型] 。</p></li><li><p><strong>内存和资源管理。</strong>Metal框架描述了表示GPU内存分配的缓冲和纹理对象。纹理对象有指定的纹理格式，可能用于纹理图像或附件。</p><p>关于Metal内存对象的细节，参见[资源对象:缓冲和纹理] 。</p></li><li><p><strong>对于图像和计算操作完整的支持。</strong>Metal对于图像和计算操作使用相同的数据结构和资源(例如缓冲，纹理，和命令队列)。另外，Metal着色语言支持图像和计算方法。Metal框架使得资源可以在运行时接口，图像着色器和计算方法中被共享。</p><p>关于使用Metal对于图形渲染或数据并行计算操作的细节，参见[图像渲染:渲染命令编码器]和[数据并行计算处理:计算命令编码器]。</p></li><li><p><strong>预编译着色器。</strong>Metal着色器可以和你应用的代码一起在构建时被编译，然后在运行时加载。这个工作流提供了更好的代码生成和着色器的代码更容易调试。(Metal也支持着色器运行时编译。)</p><p>关于来自Metal框架代码和Metal着色器一起工作的细节，参见[函数和库]。关于Metal着色语言本身的细节，参见Metal渲染语言指南。</p></li></ul><p>一个Metal应用不能在后台执行Metal命令，Metal应用会尝试终止这种行为。</p><h2 id="命令组成和执行模型"><a href="#命令组成和执行模型" class="headerlink" title="命令组成和执行模型"></a>命令组成和执行模型</h2><p>在Metal架构中，<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>协议定义了表示单GPU的接口。<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>协议提供了询问设备属性方法，创建其他设备指定对象，例如缓冲和纹理，编码和排队渲染以及被提交给GPU执行的计算命令。</p><p>命令队列由一个命令缓冲区队列组成，命令队列组织那些命令缓冲区的执行顺序。一个命令缓冲区包括打算在一个特定设备上执行的已编码的命令。命令编码器追加渲染、计算和位块传送命令到一个命令缓冲区，那些命令缓冲区最终被提交到设备上执行。</p><p><a href="https://developer.apple.com/documentation/metal/mtlcommandqueue" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandQueue</font></a>协议定义了一个命令队列的接口，创建命令缓冲对象的主要支持方法。<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>协议定义了一个命令缓冲区的接口并提供创建命令编码器，入队执行的命令缓冲区，检查状态以及其他操作的方法。<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>协议支持下列命令编码器类型，它们是编码不同种类GPU工作量进入一个命令缓冲区的接口。</p><ul><li><a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>协议编码单一渲染过程的图像(3D)渲染命令。</li><li><a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>协议编码数据并行计算工作量。</li><li><a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>协议编码在缓冲和纹理之间的简单拷贝操作，和类似mipmap产生的工具操作一样。</li></ul><p>在任何时候，只有一个命令编码器可以是活跃的，追加命令到一个命令缓冲区。每个命令编码器在创建用于使用相同命令缓冲区的另一个命令编码器之前必须结束。一个例外“每个命令缓冲区的一个活跃的命令编码器”的规则是<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>协议，在使用<a href="">使用多线程编码单一渲染通道</a>中讨论。</p><p>一旦所有的编码结束，提交<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象本身，它标记那个命令缓冲区准备由GPU执行。<a href="https://developer.apple.com/documentation/metal/mtlcommandqueue" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandQueue</font></a>协议控制提交到<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象的命令何时被执行，相对于其他<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象已经在命令队列。</p><p>图表2-1展示了命令队列，命令缓冲，命令编码器对象是如何紧密联系的。表格顶部的每列组件(缓冲，纹理，采样器，深度以及模板状态，管线状态)表示资源和状态，这些状态一个特殊命令编码器的特性。</p><p>图表 2-1 Metal对象关系</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/Cmd-Model-1_2x.png" alt="img-w600"></p><h3 id="设备对象表示一个GPU"><a href="#设备对象表示一个GPU" class="headerlink" title="设备对象表示一个GPU"></a>设备对象表示一个GPU</h3><p><a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象表示一个可以执行命令GPU。<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>协议有方法去创建一个新的命令队列，从内存分配缓冲区，创建纹理，以及设备兼容性查询。调用<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/1433401-mtlcreatesystemdefaultdevice" target="_blank" rel="noopener">MTLCreateSystemDefaultDevice</a></font>函数获取系统上首选的系统设备。</p><h3 id="Metal中的瞬态与非瞬态对象"><a href="#Metal中的瞬态与非瞬态对象" class="headerlink" title="Metal中的瞬态与非瞬态对象"></a>Metal中的瞬态与非瞬态对象</h3><p>Metal中的一些对象被设计成瞬态和极其轻量级的，而另一些可能对应用程序的生命周期则更昂贵并会持续很长时间。</p><p>命令缓冲区和命令编码器对象是瞬态的并用途单一。他们是非常便宜的分配和销毁，所以他们的创建方法返回自动释放对象。</p><p>下列对象不是瞬态的。重用这些对象在性能敏感的代码，避免重复创建它们。</p><ul><li>命令队列</li><li>数据缓冲区</li><li>纹理</li><li>采样器状态</li><li>库</li><li>计算状态</li><li>渲染管线状态</li><li>深度/模板状态</li></ul><h3 id="命令队列"><a href="#命令队列" class="headerlink" title="命令队列"></a>命令队列</h3><p>命令队列接受一个GPU将要执行的命令缓冲区的有序列表。所有命令缓冲区发送到一个队列，这保证了入队的命令缓冲区有序执行。通常，命令队列是线程安全的并且允许多个活跃的命令缓冲区被同时编码。</p><p>创建命令队列，调用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtldevice/1433388-newcommandqueue" target="_blank" rel="noopener">newCommandQueue</a></font>方法或<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtldevice/1433433-makecommandqueue" target="_blank" rel="noopener">newCommandQueueWithMaxCommandBufferCount:</a></font>方法。通常，命令队列希望长时间存活，所以他们不应当被反复创建和销毁。</p><h3 id="命令缓冲区"><a href="#命令缓冲区" class="headerlink" title="命令缓冲区"></a>命令缓冲区</h3><p>命令缓冲区存储被编码的命令直到缓冲区被提交到GPU执行。一个命令缓冲可以包含许多不同种类的被编码的命令，依赖于编码器的数量和类型，这些编码器被用来构建它。在一个典型的应用程序中，渲染的整个帧被编码进一个单独的命令缓冲区，即使渲染的帧包含多个帧渲染通道，计算处理功能，或者位块传送操作。</p><p>命令缓冲区是瞬态的一次性对象并且不支持重用。一旦一个命令缓冲区被提交执行，唯一有效的操作是去等待命令缓冲区被安排或者执行完成—通过同步调用或者在<a href="">注册命令缓冲执行处理程序</a>中讨论的处理程序—检查命令缓冲区执行状态。</p><p>命令缓冲区也表示了唯一独立地可跟踪的工作单元，并且他们定义了由Metal内存模型确定的一致性界限，详情见<a href="">资源对象:缓冲和纹理</a>。</p><h4 id="创建命令缓冲区"><a href="#创建命令缓冲区" class="headerlink" title="创建命令缓冲区"></a>创建命令缓冲区</h4><p>创建<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象，调用<a href="https://developer.apple.com/documentation/metal/mtlcommandqueue" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandQueue</font></a>的<font color="DeepSkyBlue">commandBuffer</font>方法。<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象只能被提交到创建的<a href="https://developer.apple.com/documentation/metal/mtlcommandqueue" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandQueue</font></a>对象中。</p><p>由<font color="DeepSkyBlue">commandBuffer</font>方法创建的命令缓冲区持有需要执行的数据。对于特定场景，在<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象执行期间在别处持有保留这些对象，你可以通过调用<a href="https://developer.apple.com/documentation/metal/mtlcommandqueue" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandQueue</font></a>的<font color="DeepSkyBlue">commandBufferWithUnretainedReferences</font>方法创建一个命令缓冲区。使用<font color="DeepSkyBlue">commandBufferWithUnretainedReferences</font>方法仅仅为了性能极其关键的应用程序，这可以确保关键对象在应用的别处有引用直到命令缓冲执行完成。否则，不再有其他引用的一个对象可能过早地被施放，命令缓冲执行结果是不明确的。</p><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>协议使用下列方法去确定命令缓冲在命令队列中的执行顺序。命令缓冲并未开始执行直到它被提交。一旦提交，命令缓冲会按照它们入队的顺序去执行。</p><ul><li><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443019-enqueue" target="_blank" rel="noopener">enqueue</a></font>方法在命令队列缓冲区上保留命令缓冲的一个地方,但不提交到命令缓冲区去执行。当这个命令缓冲区最后被提交，它将在任何以前入队相关队列的命令缓冲区后被执行。</li><li><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443003-commit" target="_blank" rel="noopener">commit</a></font>方法引起了命令缓冲区被尽快执行，但是在任何以前入队相同命令队列的命令缓冲区被提交之后。如果命令缓冲没有以前入队的，<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443003-commit" target="_blank" rel="noopener">commit</a></font>做一个隐含的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443019-enqueue" target="_blank" rel="noopener">enqueue</a></font>调用。</li></ul><p>多线程使用<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443019-enqueue" target="_blank" rel="noopener">enqueue</a></font>的例子，参见<a href="">多线程，命令缓冲区和命令编码器</a>。</p><h4 id="注册命令缓冲区执行的处理程序"><a href="#注册命令缓冲区执行的处理程序" class="headerlink" title="注册命令缓冲区执行的处理程序"></a>注册命令缓冲区执行的处理程序</h4><p>下面列出的<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>方法监控命令执行。计划和完成处理程序在一个不明确的线程上按执行顺序被调用。执行这些处理程序代码应很快完成；如果昂贵的或阻塞的工作需要被完成,推迟那个工作到另一个线程。</p><ul><li><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442991-addscheduledhandler" target="_blank" rel="noopener">addScheduledHandler:</a></font>方法注册一个当命令缓冲调度时被调用的代码块。在由其他的<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象递交的工作或者系统其他API的任何依赖被满足时命令缓冲被考虑调度。你可以为一个命令缓冲注册多个调度处理程序。</li><li><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443036-waituntilscheduled" target="_blank" rel="noopener">waitUntilScheduled</a></font>方法同步等待并且在命令缓冲被调度后返回，所有由<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442991-addscheduledhandler" target="_blank" rel="noopener">addScheduledHandler:</a></font>方法注册的调度程序被完成。</li><li><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442997-addcompletedhandler" target="_blank" rel="noopener">addCompletedHandler:</a></font>方法注册一个在设备完成命令缓冲执行后立刻被调用的代码块。你可以为一个命令缓冲注册多个完成处理代码块。</li><li><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443039-waituntilcompleted" target="_blank" rel="noopener">waitUntilCompleted</a></font>方法同步等待，在设备已经完成命令缓冲执行后返回，所有通过<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442997-addcompletedhandler" target="_blank" rel="noopener">addCompletedHandler:</a></font>方法注册的处理程序返回。</li></ul><p><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443029-presentdrawable" target="_blank" rel="noopener">presentDrawable:</a></font>方法是一个完成处理程序的特例。这个方便的方法当命令缓冲被调度时显示一个可显示资源(一个<font color="Fuchsia"><a href="https://developer.apple.com/documentation/quartzcore/cametaldrawable" target="_blank" rel="noopener">CAMetalDrawable</a></font>对象)的内容。关于<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443029-presentdrawable" target="_blank" rel="noopener">presentDrawable:</a></font>方法的详情，参见<a href="">集成核心动画:CAMetalLayer</a>。</p><h4 id="监控命令缓冲区执行状态"><a href="#监控命令缓冲区执行状态" class="headerlink" title="监控命令缓冲区执行状态"></a>监控命令缓冲区执行状态</h4><p>只读<font color="DarkGray"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443048-status" target="_blank" rel="noopener">status</a></font>属性包含一个列举在<font color="Fuchsia"><a href="https://developer.apple.com/documentation/metal/mtlcommandbufferstatus" target="_blank" rel="noopener">Command Buffer Status Codes</a></font>中的<font color="Fuchsia"><a href="https://developer.apple.com/documentation/metal/mtlcommandbufferstatus" target="_blank" rel="noopener">MTLCommandBufferStatus</a></font>的枚举值，这些反应了在这个命令缓冲声明周期中的当前调度阶段。</p><p>如果执行成功完成，只读<font color="DarkGray"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443040-error" target="_blank" rel="noopener">error</a></font>属性值是nil。如果执行失败，那么status被设置为<font color="DarkGray">MTLCommandBufferStatusError</font>，<font color="DarkGray">error</font>属性可能包含一个被列举在<font color="Fuchsia"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffererror.code" target="_blank" rel="noopener">Command Buffer Error Codes</a></font>中的值，它表明了失败的原因。</p><h3 id="命令编码器"><a href="#命令编码器" class="headerlink" title="命令编码器"></a>命令编码器</h3><p>命令编码器是一个瞬态对象，你用一次写命令和状态到一个以一种GPU可执行格式的命令缓冲区。许多命令编码器对象方法追加命令到命令缓冲区。当一个缓冲编码器是活跃的，它有在其命令缓冲区追加命令的专属权。一旦你完成了编码命令，调用<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>方法。继续写命令，创建一个新的命令编码器。</p><h4 id="创建一个命令编码器对象"><a href="#创建一个命令编码器对象" class="headerlink" title="创建一个命令编码器对象"></a>创建一个命令编码器对象</h4><p>由于一个命令编码器追加命令到一个指定的命令缓冲区，通过从你想使用的<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象请求创建一个命令编码器。使用下面的<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>方法来创建各类型的命令编码器:</p><ul><li><font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442999-rendercommandencoderwithdescript" target="_blank" rel="noopener">renderCommandEncoderWithDescriptor:</a></font>方法创建一个<font color="Fuchsia"><a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener">MTLRenderCommandEncoder</a></font>]对象图像渲染在<font color="Fuchsia"><a href="https://developer.apple.com/documentation/metal/mtlrenderpassdescriptor" target="_blank" rel="noopener">MTLRenderPassDescriptor</a></font>中的一个附件。</li><li>computeCommandEncoder方法创建一个<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>对象对于数据并行计算。</li><li>blitCommandEncoder方法创建一个<a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>对象对于内存操作。</li><li>parallelRenderCommandEncoderWithDescriptor:方法创建一个<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>对象，它使得一些<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>对象运行在不同的线程上，当静止渲染一个附件时，它被指定到一个共享的<font color="Fuchsia">MTLRenderPassDescriptor</font>中。</li></ul><h4 id="渲染命令编码器"><a href="#渲染命令编码器" class="headerlink" title="渲染命令编码器"></a>渲染命令编码器</h4><p>图像渲染可以被描述依据一个渲染管道。一个<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>对象表示渲染状态和关联单一渲染通道的绘制指令。<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>需要一个相关联的<font color="Fuchsia"><a href="https://developer.apple.com/documentation/metal/mtlrenderpassdescriptor" target="_blank" rel="noopener">MTLRenderPassDescriptor</a></font>(描述在创建一个渲染管道描述符)，它包含颜色，深度和模板附件，它们作为渲染命令的终点。<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>有下列方法:</p><ul><li>指定图像资源，例如缓冲区和纹理对象，包含顶点，片元，或者纹理图像数据</li><li>指定<font color="Fuchsia"><a href="https://developer.apple.com/documentation/metal/mtlrenderpipelinestate" target="_blank" rel="noopener">MTLRenderPipelineState</a></font>对象，包含已编译渲染状态，包括顶点和片元着色器</li><li>指定固定功能状态，包括视口，三角形填充模式，剪刀矩形，深度和模板测试以及其他值</li><li>绘制3D基元</li></ul><p>关于<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>协议的详细信息，请看<a href="">图像渲染：渲染命令编码器</a>。</p><h4 id="计算命令编码器"><a href="#计算命令编码器" class="headerlink" title="计算命令编码器"></a>计算命令编码器</h4><p>对于数据并行计算，<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>协议提供了在命令缓冲区编码命令的方法，可以指定计算功能和它的参数(例如，纹理，缓冲，和采样器状态)，调度执行计算功能。创建一个计算命令编码器对象，使用<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443044-makecomputecommandencoder" target="_blank" rel="noopener">computeCommandEncoder</a></font>方法。关于<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>的方法和属性的详细信息，请看<a href="">数据并行计算处理:计算命令编码器</a>。</p><h4 id="位块传送命令编码器"><a href="#位块传送命令编码器" class="headerlink" title="位块传送命令编码器"></a>位块传送命令编码器</h4><p><a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>协议有方法在缓冲(<font color="Fuchsia"><a href="https://developer.apple.com/documentation/metal/mtlbuffer" target="_blank" rel="noopener">MTLBuffer</a></font>)和纹理(<font color="Fuchsia"><a href="https://developer.apple.com/documentation/metal/mtltexture" target="_blank" rel="noopener">MTLTexture</a></font>)之间为内存拷贝操作追加命令。<font color="Fuchsia"><a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener">MTLBlitCommandEncoder</a></font>协议也提供了方法用纯色去填充纹理和产生纹理映射。创建一个位块传送命令编码器对象，使用<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443001-makeblitcommandencoder" target="_blank" rel="noopener">blitCommandEncoder</a></font>方法。关于<a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>方法和属性的详细信息，请看<a href="">缓冲区和纹理操作:位块传送命令编码器</a>。</p><h4 id="多线程，命令缓冲，和命令编码器"><a href="#多线程，命令缓冲，和命令编码器" class="headerlink" title="多线程，命令缓冲，和命令编码器"></a>多线程，命令缓冲，和命令编码器</h4><p>大多数应用使用单线程来编码在单一指令缓冲区中一帧的渲染命令。在每帧的末尾，提交编码缓冲区，计划和开始命令执行。</p><p>如果你想去并行编码命令缓冲区，那么你可以同时创建多个命令缓冲区，用一个分开的线程编码每一个。如果你知道提前以什么顺序应该执行一个命令缓冲区，那么<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443019-enqueue" target="_blank" rel="noopener">enqueue</a></font>方法可以声明在命令队列中的执行顺序，不需要等待命令被编码和提交。否则，当一个命令缓冲区被提交，在任何以前入队的命令缓冲以后它会被分配到命令队列的一个地方。</p><p>有时仅仅一个CPU线程可以访问一个命令缓冲。多线程应用每个命令缓冲可以使用一个线程来创建多个并行的命令缓冲。</p><p>图表2-2显示了一个三线程的例子。每个线程有它自己的命令缓冲区。对于每个线程，一个命令编码器在一次访问它相关的命令缓冲。图表2-2也显示了每个指令缓冲接收来自不同命令编码器的命令。当你结束编码时，调用命令编码器的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>方法，一个新的命令编码器对象可以开始编码指令到命令缓冲区。</p><p>图表2-2 多线程Metal命令缓冲区</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/Cmd-Model-threads_2x.png" alt="img-w600"></p><p><a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>对象允许将一个渲染通过拆分到多个命令编码器和分配到单独的线程。关于<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>更多信息，请看使用<a href="">多线程编码单一渲染管道</a>。</p><h2 id="资源对象-缓冲和纹理"><a href="#资源对象-缓冲和纹理" class="headerlink" title="资源对象:缓冲和纹理"></a>资源对象:缓冲和纹理</h2><p>这章描述Metal资源对象(MTLResource)存储未格式化的内存和格式化的图像数据。MTLResource对象有两个类型:</p><ul><li>MTLBuffer表示未格式化内存的分配，它可以包含任意类型数据。缓冲区通常被用在顶点，着色器，和计算状态数据。</li><li>MTLTexture表示指定纹理类型和像素格式的格式化图像数据的分配。纹理对象被用作顶点，片元的源纹理，或者计算方法，和存储图像渲染输出一样(换言之，作为一个附件)。</li></ul><p>MTLSamplerState对象也在这章中被讨论。尽管采样器不是资源本身，他们当执行用纹理对象检查计算时被使用。</p><h3 id="缓冲是无类型的内存分配"><a href="#缓冲是无类型的内存分配" class="headerlink" title="缓冲是无类型的内存分配"></a>缓冲是无类型的内存分配</h3><p>MTLBuffer对象表示一个可以包含任意类型数据的内存分配。</p><h4 id="创建一个缓冲对象"><a href="#创建一个缓冲对象" class="headerlink" title="创建一个缓冲对象"></a>创建一个缓冲对象</h4><p><a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>的下列方法创建和返回一个MTLBuffer对象:</p><ul><li>newBufferWithLength:options:方法用一个新的存储分配创建MTLBuffer对象。</li><li>newBufferWithBytes:length:options:方法通过从已存在的存储(位于CPU地址指针)拷贝进入一个新的存储分配来创建一个MTLBuffer对象。</li><li>newBufferWithBytesNoCopy:length:options:deallocator:方法用一个已存在的存储分配来创建一个MTLBuffer对象，对于这个对象不能分配任何新的存储。</li></ul><p>所有缓冲创建方法有输入值length来标明存储分配的大小，以字节来表示。对于可以修改创建缓冲区行为的options，所有方法也接受一个MTLResourceOptions对象。如果options的值时0，默认值被用作资源选项。</p><h4 id="缓冲方法"><a href="#缓冲方法" class="headerlink" title="缓冲方法"></a>缓冲方法</h4><p>MTLBuffer协议有下列方法:</p><ul><li>contents方法返回缓冲区的存储分配的CPU地址。</li><li>newTextureWithDescriptor:offset:bytesPerRow:方法创建一种特殊的纹理对象，该纹理对象引用缓冲区的数据。这个方法被详细讲解在创建一个纹理对象章节中。</li></ul><h3 id="纹理是格式化的图像数据"><a href="#纹理是格式化的图像数据" class="headerlink" title="纹理是格式化的图像数据"></a>纹理是格式化的图像数据</h3><p>一个MTLTexture对象代笔爱哦一个格式化图像数据的分配，它可以被用作一个顶点着色器的资源，片元着色器，或者计算方法，或者作为一个附件被用作一个渲染的终点。MTLTexture对象可以有下列结构中的一个:</p><ul><li>一个1D，2D，或者3D的图像</li><li>一个1D或者2D图像的数组</li><li>六个2D图像的立方体</li></ul><p>MTLPixelFormat指定在一个MTLTexture对象个体像素构成。像素格式被更进一步讨论在纹理像素格式。</p><h4 id="创建一个纹理对象"><a href="#创建一个纹理对象" class="headerlink" title="创建一个纹理对象"></a>创建一个纹理对象</h4><p>下列方法创建并返回一个MTLTexture对象:</p><ul><li><a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>的newTextureWithDescriptor:方法用一个纹理图像数据的新存储分配来创建一个MTLTexture对象，使用<font color="Fuchsia">MTLTextureDescriptor</font>对象来描述纹理的属性。</li><li>MTLTexture的newTextureViewWithPixelFormat:方法来创建一个MTLTexture对象，这个对象共享相同的存储分配来调用MTLTexture对象。因为他们共享相同的存储，新纹理对象的像素的任何改变被反映在调用纹理对象上，反之亦然。对于最新创建的纹理，newTextureViewWithPixelFormat:方法重新解释了已存在的调用MTLTexture对象的存储分配的纹理图像数据，好像数据被被存储到一个指定的像素格式。新纹理对象MTLPixelFormat必须和原始纹理对象``的MTLPixelFormat是兼容的。(请看像素格式关于普通的纹理细节,包装,和压缩像素格式。)</li><li>MTLBuffer的newTextureWithDescriptor:offset:bytesPerRow:方法创建一个MTLTexture对象，调用MTLBuffer对象作为它的纹理图像数据来共享存储分配。当它们共享相同的存储，新纹理对象像素的任何改变都会被反映在调用纹理对象上，反之亦然。在纹理和缓冲之间共享存储可以防止指定纹理优化的使用，例如像素混合或平铺。</li></ul><h4 id="使用纹理描述符创建一个纹理对象"><a href="#使用纹理描述符创建一个纹理对象" class="headerlink" title="使用纹理描述符创建一个纹理对象"></a>使用纹理描述符创建一个纹理对象</h4><p><font color="Fuchsia">MTLTextureDescriptor</font>定义属性，这些属性被用来创建一个MTLTexture对象，包括它图像大小(宽，高，和深)，像素格式，排列(数组或者立方体类型)和纹理映射数量。<font color="Fuchsia">MTLTextureDescriptor</font>属性仅仅被使用在<font color="Fuchsia">MTLTexture</font>对象创建期间。在创建MTLTexture对象后，属性改变在它的<font color="Fuchsia">MTLTextureDescriptor</font>对象中而纹理上不再有任何效果。</p><p>从描述符创建一个或者多个纹理:</p><ol><li><p>创建一个自定义<font color="Fuchsia">MTLTextureDescriptor</font>对象，它包含描述纹理数据的纹理属性:</p><ul><li>textureType属性指定纹理维度和排列(例如，数组或立方体)。</li><li>width，height和depth属性指定基准面纹理映射每个尺寸的像素大小。</li><li>pixelFormat属性指定一个像素如何在纹理中存储的。</li><li>arrayLength属性指定MTLTextureType1DArray或MTLTextureType2DArray类型纹理对象的数组元素的个数。</li><li>mipmapLevelCount属性指定了每个像素采样的个数。</li><li>resourceOptions属性指定了它内存分配的行为。</li></ul></li><li><p>从<font color="Fuchsia">MTLTextureDescriptor</font>对象通过调用一个<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象的newTextureWithDescriptor:方法来创建一个纹理。纹理创建后，调用replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:方法加载纹理图像数据，详情见复制图像数据和纹理。</p></li><li><p>创建更多MTLTexture对象，你可以重用相同的<font color="Fuchsia">MTLTextureDescriptor</font>对象，修改需要的描述符的属性值。</p></li></ol><p>清单3-1 显示了创建一个纹理描述符txDesc和设置它对于一个3D，64×64×64的纹理属性的代码</p><p>清单3-1 用一个自定义的纹理描述符创建一个纹理对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MTLTextureDescriptor* txDesc = [[MTLTextureDescriptor alloc] init];</span><br><span class="line">txDesc.textureType = MTLTextureType3D;</span><br><span class="line">txDesc.height = 64;</span><br><span class="line">txDesc.width = 64;</span><br><span class="line">txDesc.depth = 64;</span><br><span class="line">txDesc.pixelFormat = MTLPixelFormatBGRA8Unorm;</span><br><span class="line">txDesc.arrayLength = 1;</span><br><span class="line">txDesc.mipmapLevelCount = 1;</span><br><span class="line">id &lt;MTLTexture&gt; aTexture = [device newTextureWithDescriptor:txDesc];</span><br></pre></td></tr></table></figure><h4 id="使用纹理切片"><a href="#使用纹理切片" class="headerlink" title="使用纹理切片"></a>使用纹理切片</h4><p>一个切片是一个单一的1D，2D，或3D纹理图像和所有关联的纹理映射。对于每个切片:</p><ul><li>基准面纹理映射大小被指定<font color="Fuchsia">MTLTextureDescriptor</font>对象的width,height,和depth属性。</li><li>纹理映射级别缩放大小 <em>i</em> 被指定，max(1, floor(width/2<sup>i</sup>))×max(1,floor(height/2<sup>i</sup>))×max(1,floor(depth/2<sup>i</sup>))。最大纹理映射级别是第一个纹理映射获得的级别大小为1×1×1。</li><li>纹理映射级别数量在一个切片中可以被决定floor(log<sub>2</sub>(max(width, height, depth)))+1。</li></ul><p>所有纹理对象有至少一个切片；立方体和数组纹理类型可能有数个切片。在复制图像数据和纹理章节中讨论读写纹理图像数据的规范方法，切片是一个零点输入值。对于一个1D，2D，或3D纹理，只有一个切片，所以切片的值必须是0.一个立方体纹理有6个完全的2D切片，地址从0到5.对于1DArray和2DArray纹理类型，每个数组元素表示一个切片。例如，对于一个2DArray纹理类型有arrayLength = 10，有10个完整的切片，地址从0到9.选择一个单一的1D，2D，或3D图像整体的纹理结构，首选选择一个切片，然后选择一个切片内的纹理映射级别。</p><h4 id="用便利的方法创建一个纹理描述符"><a href="#用便利的方法创建一个纹理描述符" class="headerlink" title="用便利的方法创建一个纹理描述符"></a>用便利的方法创建一个纹理描述符</h4><p>对于普通2D和立方体纹理，使用下列便利的方法来创建一个<font color="Fuchsia">MTLTextureDescriptor</font>对象，几个属性值自动设置:</p><ul><li>texture2DDescriptorWithPixelFormat:width:height:mipmapped:方法创建一个<font color="Fuchsia">MTLTextureDescriptor</font>对象对于2D纹理。width和height值定义了2D纹理的尺寸。type属性被自动设置为MTLTextureType2D， depth和arrayLength被设置成1.</li><li>textureCubeDescriptorWithPixelFormat:size:mipmapped: 方法创建一个立方体纹理的<font color="Fuchsia">MTLTextureDescriptor</font>对象，type属性被设置为MTLTextureTypeCube，width和height被设置为size，depth和arrayLength被设置为1.</li></ul><p>两个<font color="Fuchsia">MTLTextureDescriptor</font>便利方法接收一个输入值，pixelFormat，它定义了纹理的像素格式。这两种方法也接受输入值产生，这决定了是否产生纹理图像。(如果mipmapped是YES，纹理被贴图细化。)</p><p>清单3-2 使用texture2DDescriptorWithPixelFormat:width:height:mipmapped:方法来创建一个64×64的2D纹理描述符对象，它不是纹理细化的。</p><p>清单3-2 用便利的纹理描述符创建一个纹理对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MTLTextureDescriptor *texDesc = [MTLTextureDescriptor </span><br><span class="line">         texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm </span><br><span class="line">         width:64 height:64 mipmapped:NO];</span><br><span class="line">id &lt;MTLTexture&gt; myTexture = [device newTextureWithDescriptor:texDesc];</span><br></pre></td></tr></table></figure><h4 id="复制图像数据和纹理"><a href="#复制图像数据和纹理" class="headerlink" title="复制图像数据和纹理"></a>复制图像数据和纹理</h4><p>同步拷贝图像数据进入或从MTLTexture对象分配存储拷贝数据，使用下列方法:</p><ul><li>replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:从调用者的指针拷贝一个区域的像素数据到一部分指定纹理切片的存储分配。replaceRegion:mipmapLevel:withBytes:bytesPerRow:是一个类似的便利方法拷贝一个区域的像素数据到默认切片，假设切片相关参数的默认值(例如，slice = 0 并且 bytesPerImage = 0)。</li><li>getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:从一个指定纹理切片获取一个区域的像素数据。getBytes:bytesPerRow:fromRegion:mipmapLevel:是一个类似的便利方法，从默认的切片获取一个区域的像素数据，假设切片相关的参数默认值(slice = 0和bytesPerImage = 0)。</li></ul><p>清单3-3 显示了如何调用replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:来指定从系统内存中的源数据的一个纹理图像，textureData，在切片0和纹理映射级别0。</p><p>清单3-3 复制图像数据和纹理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//  pixelSize is the size of one pixel, in bytes</span><br><span class="line">//  width, height - number of pixels in each dimension</span><br><span class="line">NSUInteger myRowBytes = width * pixelSize;</span><br><span class="line">NSUInteger myImageBytes = rowBytes * height;</span><br><span class="line">[tex replaceRegion:MTLRegionMake2D(0,0,width,height)</span><br><span class="line">    mipmapLevel:0 slice:0 withBytes:textureData</span><br><span class="line">    bytesPerRow:myRowBytes bytesPerImage:myImageBytes];</span><br></pre></td></tr></table></figure><h4 id="纹理像素格式"><a href="#纹理像素格式" class="headerlink" title="纹理像素格式"></a>纹理像素格式</h4><p>MTLPixelFormat指定存储在单个像素的MTLTexture对象的颜色，深度，和模板数据存储的组成。有三种像素格式:ordinary，packed和compressed。</p><ul><li>Ordinary格式只有常规8，16或32位颜色组件。每个组件都是安排在增加内存地址，第一列组件在最低的地址。例如，MTLPixelFormatRGBA8Unorm是一个每个颜色组件8位的32位的格式；最低位地址包含红色，下一个地址包含绿色，等等。与此相反，MTLPixelFormatBGRA8Unorm，最低位地址包含蓝色，下一个地址包含绿色，等等。</li><li>Packed格式结合多个组件组合为一个16位或32位值，组件存储从最小最有效位(LSB MSB)。例如，MTLPixelFormatRGB0A2Unit是一个32位packed格式，它由3个10位通道和两位Alpha组成。</li><li>Compressed格式排列的像素块,每一块的布局是特定于该像素格式。压缩像素格式仅仅可以被用于2D，2D数组，或者立方体纹理类型。压缩格式不能被用于创建1D，2D多采样或3D纹理。</li></ul><p>MTLPixelFormatGBGR422和MTLPixelFormatBGRG422是特殊像素格式，这个格式是用来存储YUV色彩空间的像素。这些格式只支持2D纹理(但是既不是2D数组，也不是立方体类型)，没有纹理映射，偶数宽度。</p><p>一些像素格式存储sRGB色彩空间的颜色组件(例如，MTLPixelFormatRGBA8Unorm_sRGB或MTLPixelFormatETC2_RGB8_sRGB)。当一个采样操作引用拥有sRGB像素格式的纹理，在采样操作发生之前，Metal实现转换sRGB色彩空间组件到一个线性颜色空间。sRGB转换，S，一个线性组件，L，如下:</p><ul><li>If S &lt;= 0.04045, L = S/12.92</li><li>If S &gt; 0.04045, L = ((S+0.055)/1.055)<sup>2.4</sup></li></ul><p>相反地，当渲染一个色彩渲染附件，它使用sRGB像素格式的纹理，实现转换成想线性颜色值到sRGB，如下:</p><ul><li>If L &lt;= 0.0031308, S = L * 12.92</li><li>If L &gt; 0.0031308, S = (1.055 * L<sup>0.41667</sup>) - 0.055</li></ul><p>关于渲染像素格式的更多信息，请看创建一个渲染通道描述符。</p><h4 id="创建一个纹理查询的采样器状态对象"><a href="#创建一个纹理查询的采样器状态对象" class="headerlink" title="创建一个纹理查询的采样器状态对象"></a>创建一个纹理查询的采样器状态对象</h4><p>MTLSamplerState对象定义了寻址，过滤和其他属性，当一个图像或者计算函数对MTLTexture对象执行纹理采样操作时这些属性被使用。采样器描述符定义了采样器状态对象的属性。创建一个采样器对象:</p><ol><li>调用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>的<font color="DeepSkyBlue">newSamplerStateWithDescriptor:</font>方法来创建一个MTLSamplerDescriptor对象。</li><li>在MTLSamplerDescriptor对象中设置期望的值，包括过滤选项，寻址方式，最大各向异性，和细节层次参数。</li><li>通过调用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象的<font color="DeepSkyBlue">newSamplerStateWithDescriptor:</font>方法创建描述符，从采样器描述符创建MTLSamplerState对象。</li></ol><p>你可以重用采样器描述符对象来创建更多MTLSamplerState对象，修改所需的描述符的属性值。描述符属性仅在对象创建期间被使用。采样器状态已经被创建后，在采样器状态上改变其描述符的属性不再有效果。</p><p>清单3-4 是一个代码例子创建一个MTLSamplerDescriptor和配置它为了创建一个MTLSamplerState。对于描述符对象的过滤和寻址方式属性设置为非默认值。然后<font color="DeepSkyBlue">newSamplerStateWithDescriptor:</font>方法。</p><p>清单3-4 创建一个采样器状态对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// create MTLSamplerDescriptor</span><br><span class="line">MTLSamplerDescriptor *desc = [[MTLSamplerDescriptor alloc] init];</span><br><span class="line">desc.minFilter = MTLSamplerMinMagFilterLinear;</span><br><span class="line">desc.magFilter = MTLSamplerMinMagFilterLinear;</span><br><span class="line">desc.sAddressMode = MTLSamplerAddressModeRepeat;</span><br><span class="line">desc.tAddressMode = MTLSamplerAddressModeRepeat;</span><br><span class="line">//  all properties below have default values</span><br><span class="line">desc.mipFilter        = MTLSamplerMipFilterNotMipmapped;</span><br><span class="line">desc.maxAnisotropy    = 1U;</span><br><span class="line">desc.normalizedCoords = YES;</span><br><span class="line">desc.lodMinClamp      = 0.0f;</span><br><span class="line">desc.lodMaxClamp      = FLT_MAX;</span><br><span class="line">// create MTLSamplerState</span><br><span class="line">id &lt;MTLSamplerState&gt; sampler = [device newSamplerStateWithDescriptor:desc];</span><br></pre></td></tr></table></figure><h4 id="保持CPU和GPU内存之间的一致性"><a href="#保持CPU和GPU内存之间的一致性" class="headerlink" title="保持CPU和GPU内存之间的一致性"></a>保持CPU和GPU内存之间的一致性</h4><p>MTLResource对象可以访问在CPU和GPU两者之间的底层存储。然而，GPU从主机CPU异步操作，所以记住以下当使用主机CPU访问这些资源的存储。</p><p>当执行一个<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象,<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象只保证观察任何更改由<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象引用的任何MTLResource对象分配到主机CPU的存储，如果(且仅当)这些变化是由主机CPU在<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象被提交之前产生。就是说，<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象可能不观察在相应的<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象被提交后主机CPU资源产生的改变(例如，<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象的status属性是MTLCommandBufferStatusCommitted)。</p><p>相似地，在<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象执行一个<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象之后，如果命令缓冲已经被执行完成，那么主机CPU只保证观察<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象产生的命令缓冲引用的任何资源存储分配的任何改变(也就是说，<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象的status属性是<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>StatusCompleted)。</p><h2 id="函数和库"><a href="#函数和库" class="headerlink" title="函数和库"></a>函数和库</h2><p>这章描述如何创建一个<font color="Fuchsia">MTLFunction</font>对象作为一个Metal着色器的参考或计算函数，如何组织和访问<font color="Fuchsia">MTLLibrary</font>对象的方法。</p><h3 id="MTLFunction表示着色器或计算函数"><a href="#MTLFunction表示着色器或计算函数" class="headerlink" title="MTLFunction表示着色器或计算函数"></a><font color="Fuchsia">MTLFunction</font>表示着色器或计算函数</h3><p><font color="Fuchsia">MTLFunction</font>对象表示单一的函数，这个函数用Metal着色语言编写，作为图形或者计算管线的一部分在GPU上执行。Metal着色语言详情，参见Metal着色语言指导。</p><p>在Metal运行时和图像或者用Metal着色语言编写的计算函数之间传递数据或状态，分配纹理，缓冲和采样器的索引参数。参数索引确定哪个纹理，缓冲或采样器正在被引用，通过Metal运行时和Metal着色代码。</p><p>渲染通道，指定一个<font color="Fuchsia">MTLFunction</font>对象作为一个<font color="Fuchsia">MTLRenderPipelineDescriptor</font>对象的顶点或者片元着色器，详见创建一个渲染管线状态。计算管道，当在目标设备上创建一个MTLComputePipelineState对象时指定一个<font color="Fuchsia">MTLFunction</font>对象，详见指定命令编码器的计算状态和资源。</p><h3 id="库是函数的一个仓库"><a href="#库是函数的一个仓库" class="headerlink" title="库是函数的一个仓库"></a>库是函数的一个仓库</h3><p><font color="Fuchsia">MTLLibrary</font>对象表示了一个或更多<font color="Fuchsia">MTLFunction</font>对象的一个仓库。一个<font color="Fuchsia">MTLFunction</font>对象表示了一个Metal函数，这个函数用着色语言编写。在Metal着色语言中源码中，任何函数使用Metal标识符(vertex，fragment或kernel)可以通过在库中的一个<font color="Fuchsia">MTLFunction</font>对象来显示。Metal函数没有这些函数标识符中的一个不能直接用一个<font color="Fuchsia">MTLFunction</font>对象来显示。</p><p>库中的<font color="Fuchsia">MTLFunction</font>对象可以从这些资源中创建:</p><ul><li>Metal着色语言代码在app编译过程中被编译成一个二进库格式。</li><li>包含在Metal着色语言源码中的一个文本字符串在app运行时被编译。</li></ul><h4 id="从编译的代码创建一个库"><a href="#从编译的代码创建一个库" class="headerlink" title="从编译的代码创建一个库"></a>从编译的代码创建一个库</h4><p>为了最佳性能，在你的应用程序在Xcode编译过程中Metal着色语言源码将被编译成为一个库文件，这避免了在应用程序运行时编译函数源码的消耗。创建一个<font color="Fuchsia">MTLLibrary</font>对象从一个二进制库，调用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>的下列方法之一:</p><ul><li><font color="DeepSkyBlue">newDefaultLibrary</font>获取为main bundle构建的一个库，它包含所有共享和计算函数在应用程序的xCode项目中。</li><li><font color="DeepSkyBlue">newLibraryWithFile:error:</font>获取库文件的路径并返回一个<font color="Fuchsia">MTLLibrary</font>对象，这个对象包含了所有存储在库文件中的所有函数。</li><li><font color="DeepSkyBlue">newLIbraryWithData:error:</font>获取二进制大对象包含在库中的函数源码并返回一个<font color="Fuchsia">MTLLibrary</font>对象。</li></ul><p>更多关于在构建过程中编译Metal着色语言源码的信息，参见创建应用程序过程中创建库。</p><h4 id="从源码创建一个库"><a href="#从源码创建一个库" class="headerlink" title="从源码创建一个库"></a>从源码创建一个库</h4><p>调用下列<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>方法中的一个，从一个包含数个函数的Metal着色语言源码的字符串来创建一个<font color="Fuchsia">MTLLibrary</font>。当库被创建时这些函数编译源码。指定使用的编译器选项，设置MTLCompileOptions对象的属性。</p><ul><li>newLibraryWithSource:options:error:从输入字符串同步编译源码创建<font color="Fuchsia">MTLFunction</font>对象，返回包含他们的一个<font color="Fuchsia">MTLLibrary</font>对象。</li><li>newLibraryWithSource:options:completionHandler:从输入字符串异步编译源码创建<font color="Fuchsia">MTLFunction</font>对象，随后返回包含他们的一个<font color="Fuchsia">MTLLibrary</font>对象。completionHandler是一个当对象创建完成时被调用的代码块。</li></ul><h4 id="从库中获取函数"><a href="#从库中获取函数" class="headerlink" title="从库中获取函数"></a>从库中获取函数</h4><p><font color="Fuchsia">MTLLibrary</font>的newFunctionWithName:方法返回一个带有请求名字的<font color="Fuchsia">MTLFunction</font>对象。如果函数名在库中没有发现使用Metal着色语言函数标识符，那么newFunctionWithName:返回nil。</p><p>清单4-1 使用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>的<font color="DeepSkyBlue">newLibraryWithFile:error:</font>方法通过它的全名来查找一个库文件，使用它的内容来创建一个带有一个或者多个<font color="Fuchsia">MTLFunction</font>对象的<font color="Fuchsia">MTLLibrary</font>对象。加载文件中的任何错误都被返回在error中。接下来<font color="Fuchsia">MTLLibrary</font>的newFunctionWithName:方法创建一个<font color="Fuchsia">MTLFunction</font>对象，这个对象表示了在源码中名叫my_func的函数。返回的函数对象myFunc可以在应用中被使用。</p><p>清单4-1 从库中获取函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSError *errors;</span><br><span class="line">id &lt;MTLLibrary&gt; library = [device newLibraryWithFile:@&quot;myarchive.metallib&quot;</span><br><span class="line">                          error:&amp;errors];</span><br><span class="line">id &lt;MTLFunction&gt; myFunc = [library newFunctionWithName:@&quot;my_func&quot;];</span><br></pre></td></tr></table></figure><h3 id="在运行时决定函数细节"><a href="#在运行时决定函数细节" class="headerlink" title="在运行时决定函数细节"></a>在运行时决定函数细节</h3><p>由于<font color="Fuchsia">MTLFunction</font>对象的实际内容通过一个图像着色器或者计算函数定义，这些可能在<font color="Fuchsia">MTLFunction</font>对象创建前被编译，对于应用其源码可能不是直接可用的。在运行时可以查询下列<font color="Fuchsia">MTLFunction</font>属性:</p><ul><li>name，函数名称字符串</li><li>functionType，表明函数是被声明为顶点，片源还是计算方法。</li><li>vertexAttributes，MTLVertexAttribute对象的一个数组，其描述顶点属性数据在内存中是如何被组织的，它是如何被映射到顶点函数参数的。对于更多细节，参见数据组织顶点描述符。</li></ul><p><font color="Fuchsia">MTLFunction</font>不提供函数参数的访问。一个映射对象(或者MTLRenderPipelineReflection或者MTLComputePipelineReflection，依赖于命令编码器的类型)揭示了在管线状态创建时的着色器细节或计算方法参数获取。创建管线状态和映射对象的细节，参见创建一个渲染管线状态或创建一个计算管线状态。避免获取映射数据如果它没有被使用。</p><p>映射对象包含一组命令编码器支持的各种类型函数的MTLArgument对象。对于<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>，在MTLComputePipelineReflection的arguments属性为一组MTLArgument对象，对应其计算函数的参数。对于<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>，MTLRenderPipelineReflection有两个属性，vertexArguments和fragmentArguments，它们各自对应顶点函数参数和片元函数参数的数组。</p><p>并不是函数的所有参数都表示一个映射对象。映射对象只包含有一个关联资源的参数，但不是用[[ stage_in ]]标识符或者内建的[[ vertex_id ]]或[[ attribute_id ]]标识符声明的参数。</p><p>清单4-2 展示了如何获取一个映射对象(在这个例子中，MTLComputePipelineReflection)和接下来通过MTLArgument在其arguments属性进行迭代。</p><p>清单4-2 通过函数参数迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MTLComputePipelineReflection* reflection;</span><br><span class="line">id &lt;MTLComputePipelineState&gt; computePS = [device</span><br><span class="line">              newComputePipelineStateWithFunction:func</span><br><span class="line">              options:MTLPipelineOptionArgumentInfo</span><br><span class="line">              reflection:&amp;reflection error:&amp;error];</span><br><span class="line">for (MTLArgument *arg in reflection.arguments) &#123;</span><br><span class="line">    //  处理每一个MTLArgument</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MTLArgument属性揭示了着色语言函数参数的细节。</p><ul><li>name属性是简单的参数名。</li><li>active是一个布尔值表明参数是否可以被忽略。</li><li>index在其对应的参数表中是零基准位置。例如，对于[[ buffer(2) ]], index是2.</li><li>access描述任何访问限制，例如，读或写访问标识符。</li><li>type是通过着色语言标识符来表明的，例如，[[ buffer(n) ]], [[ texture(n) ]], [[ sampler(n) ]]或[[ threadgroup(n) ]]。</li></ul><p>type决定其他MTLArgument属性哪些是相关联的。</p><ul><li>如果type是MTLArgumentTypeTexture，那么textureType属性表明整个纹理类型(例如在着色语言中的texture1d_array, texture2d_msh以及texturecube类型)和textureDataType属性表明组件数据类型(例如half，float，int或uint)。</li><li>如果type是MTLArgumentTypeThreadGroupMemory，threadgrouopMemoryAlignment和threadgroupMemoryDataSize属性是相关的。</li><li>如果type是MTLArgumentTypeBuffer，<font color="DarkGray">bufferAlignment</font>，<font color="DarkGray">bufferDataSize</font>，<font color="DarkGray">bufferDataType</font>以及<font color="DarkGray">bufferStructType</font>属性是相关联的。</li></ul><p>如果缓冲参数是一个结构体(也就是说，bufferDataType是MTLDataTypeStruct)，bufferStructType属性包含MTLStructType，其表示结构体，bufferDataSize包含结构体的大小，以字节计算。如果缓冲参数是一个数组(或指向数组的指针)，那么bufferDataType表明元素的数据类型，bufferDataSize包含一个数组元素的大小，以字节计算。</p><p>清单4-3 深度探讨MTLStructType对象检查结构体成员的细节，每一个成员由一个MTLStructMember对象表示。结构体成员可能是一个简单类型，一个数组，或者一个嵌套结构体。如果成员是一个嵌套结构体，那么调用MTLStructMember的structType方法来获取一个MTLStructType对象，这个对象表示结构体，接下来递归深度探讨来分析它。如果成员是一个数组，使用MTLStructMember的arrayType方法来获取一个MTLArrayType对象来表示它。然后检查MTLArrayType的elementType属性。如果elementType是MTLDataTypeStruct，调用elementStructType方法来获取结构体，继续深入探讨进它的成员。如果elementType是MTLDataTypeArray，调用elementArrayType方法来获取字数组并进一步分析它。</p><p>清单4-3 处理结构体参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MTLStructType *structObj = [arg.bufferStructType];</span><br><span class="line">for (MTLStructMember *member in structObj.members) &#123;</span><br><span class="line">    //  process each MTLStructMember</span><br><span class="line">    if (member.dataType == MTLDataTypeStruct) &#123;</span><br><span class="line">       MTLStructType *nestedStruct = member.structType;</span><br><span class="line">       // recursively drill down into the nested struct</span><br><span class="line">    &#125;</span><br><span class="line">    else if (member.dataType == MTLDataTypeArray) &#123;</span><br><span class="line">       MTLStructType *memberArray = member.arrayType;</span><br><span class="line">       // examine the elementType and drill down, if necessary</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">       // member is neither struct nor array</span><br><span class="line">       // analyze it; no need to drill down further</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图形渲染-渲染命令编码器"><a href="#图形渲染-渲染命令编码器" class="headerlink" title="图形渲染:渲染命令编码器"></a>图形渲染:渲染命令编码器</h2><p>这章描述如何创建使用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>和MTLParalledlRenderCommandEncoder对象，他们被用来编码图像渲染指令到命令缓冲。<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>命令描述图像渲染管线，像图表5-1看的。</p><p>图表 5-1 Metal图像渲染管线</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/gfx-pipeline_2x.png" alt="img-w600"></p><p><a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>表示了一个单独的渲染命令编码器。<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>对象使单一渲染通道能够分解成大量离散的<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>对象，它们每个可能分配在不同的线程上。来自不同渲染命令编码器的命令链接在一起并一起一致的执行，可预见的顺序，正如在多线程渲染通道章节中描述的。</p><h3 id="创建并使用渲染命令编码器"><a href="#创建并使用渲染命令编码器" class="headerlink" title="创建并使用渲染命令编码器"></a>创建并使用渲染命令编码器</h3><p>创建，初始化和使用一个渲染命令编码器:</p><ol><li>创建一个<font color="Fuchsia">MTLRenderPassDescriptor</font>对象来定义附件集合，对于渲染通道这些附件担任命令缓冲区中图形命令渲染终点的角色。表示性地，一旦你创建一个<font color="Fuchsia">MTLRenderPassDescriptor</font>对象并你的应用每次重用它渲染帧。</li><li>使用指定渲染管线通过调用<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>的renderCommandEncoderWithDescriptor方法来创建一个<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>对象。参见使用渲染管道描述符来创建一个渲染命令编码器。</li><li>创建一个<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>对象来定义对于一次或多次绘制调用图像渲染管线的状态(包括着色器，混合，多采样和可视化测试)。为了使用这个绘制基元渲染管线状态，调用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的setRenderPipelineState:方法。相关详细信息，参见创建渲染管线状态。</li><li>通过渲染命令编码器设置纹理，缓冲和被使用的采样器，如指定渲染着色器资源中描述的。</li><li>调用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>方法来指定额外的固定功能状态，包括深度和模板状态，在固定功能状态操作中解释。</li><li>最终，调用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>方法来绘制图像基元，如绘制几何基元中描述的。</li></ol><h4 id="创建渲染管道描述符"><a href="#创建渲染管道描述符" class="headerlink" title="创建渲染管道描述符"></a>创建渲染管道描述符</h4><p>MTLResourcePassDescriptor对象表示编码的渲染命令终点，它是一个附件的集合。渲染描述符的属性可能包含色彩像素数据四个附件的一个数组，深度像素数据的一个附件，模板像素数据的一个附件。renderPassDescriptor便利的方法用默认附件状态的颜色，深度和模板附件创建一个<font color="Fuchsia">MTLRenderPassDescriptor</font>对象。visibilityResultBuffer属性指定了一个缓冲，这个缓冲指定一个缓冲区，设备可以更新指示是否任何采样通过了深度和模板测试—相关详细信息，参见固定功能状态操作。</p><p>每个独立的附件，包含纹理，这个纹理将通过一个附件描述符被编写和表现。对于一个附件描述符，必须选择合适关联的纹理像素格式来存储颜色，深度或者模板数据。对于颜色附件描述符，MTLRenderPassColorAttachmentDescriptor，使用一个颜色可渲染的像素格式。对于深度附件描述符，MTLRenderPassDepthAttachmentDescriptor，使用一个深度可渲染的像素格式，例如MTLPixelFormatDepth32Float。对于一个模板缓冲描述符，使用一个模板可渲染的像素格式，例如MTLPixelFormatStencil8。</p><p>在设备上每个像素实际使用纹理内存的数量不总是匹配Metal框架代码的纹理像素格式的大小。因为设备添加了对齐的填料或者其他的目的。参见Metal特性表集章节对于每种像素格式实际使用了多少内存，同样大小的限制和附件的数量。</p><h5 id="加载和存储动作"><a href="#加载和存储动作" class="headerlink" title="加载和存储动作"></a>加载和存储动作</h5><p>附件描述符的loadAction和storeAction属性指定了一个动作，这个动作执行在渲染通道的开始或结束。(<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>，加载和存储动作出现在整个命令边界，而不是每个<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>对象。相关详细信息，参见多线程渲染通道)。</p><p>可能的loadAction值包括:</p><ul><li>MTLLoadActionClear，写相同的值到指定附件描述符的每个像素。关于这个动作的详细信息，参见指定清除加载动作。</li><li>MTLLoadActionLoad，保留现有的纹理内容。</li><li>MTLLoadActionDontCare，允许附件的每个像素获得在渲染通道初始任意值。</li></ul><p>如果你的应用程序将渲染给定帧的附件的所有像素，使用默认加载动作MTLLoadActionDontCare。MTLLoadActionDontCare动作允许GPU避免加载已存在的纹理内容，确保最佳的新能。否则，你可以使用MTLLoadActionClear动作来清除附件以前的内容，或者MTLLoadActionLoad动作来保留他们。MTLLoadActionClear动作也避免了加载已存在的纹理内容，但是它引发了用纯色填充终点的消耗。</p><p>可能的storeAction值包括:</p><ul><li>MTLStoreActionStore，保存渲染通道的最终结果到附件。</li><li>MTLStoreActionMultisampleResovle，解决来自渲染目标多采样数据到单一采样值，通过附件属性resolveTexture来指定他们存储的纹理，保留未定义附件内容。相关详细信息，参见例子:创建一个多采样渲染的渲染管道描述符。</li><li>MTLStoreActionDontCare，在渲染通道完成时以未定义状态保留附件。这可能提高性能，它使避免任何保存渲染结果的必要工作的实现成为可能。</li></ul><p>对于颜色附件，MTLStoreActionStore动作是默认存储动作，由于应用程序几乎总是保存渲染管道末尾附件的最终颜色值。对于深度和模板附件，MTLStoreActionDontCare是默认存储动作，因为那些附件表示性地不需要被保存在渲染通道完成时。</p><h5 id="指定清除加载动作"><a href="#指定清除加载动作" class="headerlink" title="指定清除加载动作"></a>指定清除加载动作</h5><p>如果附件描述符的加载动作属性设置为MTLLoadActionClear，那么清除值被写入渲染通道起始位置指定附件描述符的每个像素。清除值依赖于附件类型。</p><ul><li>MTLRenderPassColorAttachmentDescriptor，clearColor包含一个MTLClearColor值，该值包含四个双精度浮点数RGBA组件并用来清除颜色附件。MTLClearColorMake函数创建了一个来自红，绿，蓝和透明组件的清除颜色值。默认清除颜色值为(0.0, 0.0, 0.0, 1.0),或者不透明黑色。</li><li>MTLRenderPassDepthAttachmentDescriptor，clearDepth包含一个在[0.0, 1.0]之间的双精度浮点数，这个值用于清除深度附件。默认值是1.0。</li><li>MTLRenderPassStencilAttachmentDescriptor，clearStencil包含一个32位无符号整形数，它被用来去清除模板附件。默认值是0。</li></ul><p>例子:用加载和存储动作创建一个渲染通道描述符</p><p>清单5-1 用颜色和深度附件创建一个简单的渲染通道描述符。首先，两个纹理对象被创建，一个是有颜色可渲染的像素格式和另外一个深度像素格式。其次<font color="Fuchsia">MTLRenderPassDescriptor</font>的renderPassDescriptor便利方法创建一个默认的渲染管道描述符。然后通过<font color="Fuchsia">MTLRenderPassDescriptor</font>的属性访问颜色和深度附件。纹理和动作被设置在colorAttachments[0]，其表示了第一个颜色附件(在数组索引0)和深度附件。</p><p>清单5-1 用颜色和深度附件创建一个渲染管道描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MTLTextureDescriptor *colorTexDesc = [MTLTextureDescriptor</span><br><span class="line">           texture2DDescriptorWithPixelFormat:MTLPixelFormatRGBA8Unorm</span><br><span class="line">           width:IMAGE_WIDTH height:IMAGE_HEIGHT mipmapped:NO];</span><br><span class="line">id &lt;MTLTexture&gt; colorTex = [device newTextureWithDescriptor:colorTexDesc];</span><br><span class="line"> </span><br><span class="line">MTLTextureDescriptor *depthTexDesc = [MTLTextureDescriptor</span><br><span class="line">           texture2DDescriptorWithPixelFormat:MTLPixelFormatDepth32Float</span><br><span class="line">           width:IMAGE_WIDTH height:IMAGE_HEIGHT mipmapped:NO];</span><br><span class="line">id &lt;MTLTexture&gt; depthTex = [device newTextureWithDescriptor:depthTexDesc];</span><br><span class="line"> </span><br><span class="line">MTLRenderPassDescriptor *renderPassDesc = [MTLRenderPassDescriptor renderPassDescriptor];</span><br><span class="line">renderPassDesc.colorAttachments[0].texture = colorTex;</span><br><span class="line">renderPassDesc.colorAttachments[0].loadAction = MTLLoadActionClear;</span><br><span class="line">renderPassDesc.colorAttachments[0].storeAction = MTLStoreActionStore;</span><br><span class="line">renderPassDesc.colorAttachments[0].clearColor = MTLClearColorMake(0.0,1.0,0.0,1.0);</span><br><span class="line"> </span><br><span class="line">renderPassDesc.depthAttachment.texture = depthTex;</span><br><span class="line">renderPassDesc.depthAttachment.loadAction = MTLLoadActionClear;</span><br><span class="line">renderPassDesc.depthAttachment.storeAction = MTLStoreActionStore;</span><br><span class="line">renderPassDesc.depthAttachment.clearDepth = 1.0;</span><br></pre></td></tr></table></figure><h5 id="例子：创建一个多采样渲染的渲染管道描述符"><a href="#例子：创建一个多采样渲染的渲染管道描述符" class="headerlink" title="例子：创建一个多采样渲染的渲染管道描述符"></a>例子：创建一个多采样渲染的渲染管道描述符</h5><p>为了使用MTLStoreActionMultisampleResolve动作，你必须设置texture属性为一个多采样类型的纹理，resovleTexture属性将包含多采样解决操作的结果。(如果纹理不支持多采样，那么一个多采样解决动作是未定义的结果。)resolveLevel，resolveSlice和resolveDepthPlane属性可能也被用于多采样解决操作去分别指定纹理映射级别，立方体切片，多采样纹理的深度表面。大多数情况，resolveLevel默认值，resovleSlice和resolveDepthPlain是可用的。在清单5-2，附件被初始化创建并它的loadAction，storeAction，texture和resovleTexture属性被设置支持多采样解决。</p><p>清单5-2 设置多采样解决附件属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MTLTextureDescriptor *colorTexDesc = [MTLTextureDescriptor</span><br><span class="line">           texture2DDescriptorWithPixelFormat:MTLPixelFormatRGBA8Unorm</span><br><span class="line">           width:IMAGE_WIDTH height:IMAGE_HEIGHT mipmapped:NO];</span><br><span class="line">id &lt;MTLTexture&gt; colorTex = [device newTextureWithDescriptor:colorTexDesc];</span><br><span class="line"> </span><br><span class="line">MTLTextureDescriptor *msaaTexDesc = [MTLTextureDescriptor</span><br><span class="line">           texture2DDescriptorWithPixelFormat:MTLPixelFormatRGBA8Unorm</span><br><span class="line">           width:IMAGE_WIDTH height:IMAGE_HEIGHT mipmapped:NO];</span><br><span class="line">msaaTexDesc.textureType = MTLTextureType2DMultisample;</span><br><span class="line">msaaTexDesc.sampleCount = sampleCount;  //  must be &gt; 1</span><br><span class="line">id &lt;MTLTexture&gt; msaaTex = [device newTextureWithDescriptor:msaaTexDesc];</span><br><span class="line"> </span><br><span class="line">MTLRenderPassDescriptor *renderPassDesc = [MTLRenderPassDescriptor renderPassDescriptor];</span><br><span class="line">renderPassDesc.colorAttachments[0].texture = msaaTex;</span><br><span class="line">renderPassDesc.colorAttachments[0].resolveTexture = colorTex;</span><br><span class="line">renderPassDesc.colorAttachments[0].loadAction = MTLLoadActionClear;</span><br><span class="line">renderPassDesc.colorAttachments[0].storeAction = MTLStoreActionMultisampleResolve;</span><br><span class="line">renderPassDesc.colorAttachments[0].clearColor = MTLClearColorMake(0.0,1.0,0.0,1.0);</span><br></pre></td></tr></table></figure><h5 id="使用渲染管道描述符创建渲染命令编码器"><a href="#使用渲染管道描述符创建渲染命令编码器" class="headerlink" title="使用渲染管道描述符创建渲染命令编码器"></a>使用渲染管道描述符创建渲染命令编码器</h5><p>在你创建一个渲染管道描述符后并指定它的属性，使用<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象的<font color="DeepSkyBlue">renderCommandEncoderWithDescriptor:</font>方法来创建一个渲染命令编码器，如清单5-3所示:</p><p>清单5-3 用渲染管道描述符创建渲染命令编码器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id &lt;MTLRenderCommandEncoder&gt; renderCE = [commandBuffer</span><br><span class="line">                    renderCommandEncoderWithDescriptor:renderPassDesc];</span><br></pre></td></tr></table></figure><h3 id="用核心动画显示渲染内容"><a href="#用核心动画显示渲染内容" class="headerlink" title="用核心动画显示渲染内容"></a>用核心动画显示渲染内容</h3><p>核心动画定义了CAMetalLayer类，它为一个使用Metal渲染的层支持视图的专业行为而设计。CAMetalLayer对象表示关于内容(位置和大小)的几何结构信息，它的可视化属性(背景色，边界和阴影)，并且资源使用Metal来表现颜色附件内容。<br>它也封装了内容呈现的时机以便在可用或者在指定时间尽可能快的显示。核心动画的更多信息，参见核心动画编程指南。</p><p>核心动画也定义了显示资源对象的CAMetalDrawable协议。扩展MTLDrawable的CAMetalDrawable协议提供了遵循MTLTexture协议的对象，所以它可以被用作渲染命令的终点。渲染CAMetalLayer对象，你应当获取一个新的CAMetalDrawable对象对于每个渲染通道，获取它提供的MTLTexture对象，并使用哪个纹理来创建颜色附件。不像颜色附件，深度或者模板附件的创建和销毁是代价很高的。如果你需要深度或模板附件，创建他们一次并在帧渲染时重用他们。</p><p>表示性地，你使用<font color="DeepSkyBlue">layerClass</font>方法来指定CAMetalLayer作为你自己自定义的UIView子类的支持层，如清单5-4所示。否则，你可以用它的<font color="DeepSkyBlue">init</font>方法来创建一个CAMetalLayer，已存在的视图中包含这个层。</p><p>清单5-4 使用CAMetalLayer作为UIView子类的支持层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id) layerClass &#123;</span><br><span class="line">    return [CAMetalLayer class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了用Metal渲染层的内容，你必须获取一个来自CAMetalLayer对象可显示的资源(一个<font color="Fuchsia">CAMetalDrawable</font>对象)，然后通过附加它到一个<font color="Fuchsia">MTLRenderPassDescriptor</font>对象源渲染纹理的这个资源。为此，你首先设置<font color="Fuchsia">CAMetalLayer</font>对象的属性，它们描述了其提供的可绘制资源，然后每次在你开始渲染一个新帧时调用它的<font color="DeepSkyBlue">nextDrawable</font>方法。如果<font color="Fuchsia">CAMetalLayer</font>属性不设置，<font color="DeepSkyBlue">nextDrawable</font>方法会调用失败。<font color="Fuchsia">CAMetalLayer</font>的下列属性描述可绘制对象:</p><ul><li><font color="DarkGray">device</font>属性声明了<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象创建资源。</li><li><font color="DarkGray">pixelFormat</font>属性声明纹理像素格式。支持的值时MTLPixelFormatBGRA8Unorm(默认)和MTLPixelFormatBGRA8Unorm_sRGB。</li><li><font color="DarkGray">drawableSize</font>属性声明了设备像素的纹理尺寸。确保你应用以精准的尺寸显示渲染内容(在相同的设备上不需要额外采样阶段)，当计算你的层期望的尺寸时考虑目标屏幕的nativeScale或nativeBounds属性。</li><li><font color="DarkGray">framebufferOnly</font>属性声明是否纹理可以被仅仅用作附件(YES)或者是否它可以被用作纹理采样和像素读/写操作(NO)。如果YES，层对象可以优化纹理显示。对于大多数应用，推荐值为YES。</li><li><font color="DarkGray">presentsWithTransaction</font>属性声明了是否用核心动画事务机制(YES)改变层的渲染资源更新或者被异步更新到普通层(NO，默认值)。</li></ul><p>如果<font color="DeepSkyBlue">nextDrawable</font>方法成功，它返回一个带有下列只读属性的<font color="Fuchsia">CAMetalDrawable</font>对象:</p><ul><li><font color="DarkGray">texture</font>属性持有纹理对象。当创建你的渲染管线(<font color="Fuchsia">MTLRenderPipelineColorAttachmentDescriptor</font>)时使用这个作为一个附件。</li><li>指向<font color="Fuchsia">CAMetalLayer</font>对象的<font color="DarkGray">layer</font>属性负责显示几何体。</li></ul><blockquote><p>重要说明:只有一套小的几何体资源，所以一个长的帧渲染时间可以临时耗尽那些资源并引起<font color="DeepSkyBlue">nextDrawable</font>方法调用它的CPU线程直到这个方法完成。避免昂贵的CPU停转，在调用CAMetalLayer对象的<font color="DeepSkyBlue">nextDrawable</font>方法之前执行不需要可绘制资源的所有每帧操作。</p></blockquote><p>在渲染完成后显示几何体的内容，你必须通过调用可绘制对象的present方法提交它到核心动画。随着负责它渲染的命令缓冲的完成来同步显示几何体，你可以调用<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443029-presentdrawable" target="_blank" rel="noopener">presentDrawable:</a></font>或<font color="DeepSkyBlue">presentDrawable:atTime:</font>便利方法。这些方法使用预定的处理程序(参见注册命令缓冲执行的处理程序块)来调用几何体的<font color="DeepSkyBlue">present</font>方法，它覆盖了大多数场景。<font color="DeepSkyBlue">presentDrawable:atTime:</font>方法提供了当几何体被显示时更进一步的控制。</p><h3 id="创建一个渲染管线状态"><a href="#创建一个渲染管线状态" class="headerlink" title="创建一个渲染管线状态"></a>创建一个渲染管线状态</h3><p>使用一个<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>对象来编码渲染命令，你必须首先指定一个<font color="Fuchsia">MTLRenderPipelineState</font>对象来定义每次绘制调用的图形状态。渲染管线状态对象是一个可以在渲染命令编码器外部被创建的长时间持久化对象，提前缓存和穿过多个渲染命令编码器被重用。当描述同一套图形状态时，重用一个以前创建的渲染管线状态对象可能避免再求值和转化CPU命令指定状态的高耗费操作。</p><p>渲染管线状态是一个不可变对象。创建一个渲染管线状态，首先创建和配置一个可变的描述渲染管线状态属性的<font color="Fuchsia">MTLRenderPipelineDescriptor</font>对象。然后，使用描述符来创建一个<font color="Fuchsia">MTLRenderPipelineState</font>对象。</p><h4 id="创建和配置一个渲染管线描述符"><a href="#创建和配置一个渲染管线描述符" class="headerlink" title="创建和配置一个渲染管线描述符"></a>创建和配置一个渲染管线描述符</h4><p>创建渲染管线状态，首先创建一个<font color="Fuchsia">MTLRenderPipelineDescriptor</font>对象，其有属性来描述在渲染过程中你想使用的图像渲染管线状态，如图表5-2所示。新的<font color="Fuchsia">MTLRenderPipelineDescriptor</font>的<font color="DarkGray">colorAttachment</font>属性包含一组<font color="Fuchsia">MTLRenderPipelineColorAttachmentDescript</font>对象，每个描述符表示一个颜色附件状态，其指定混合操作和那个附件因子，详见配置渲染管线附件描述符的混合。附件描述符也指定了附件的像素格式，它必须匹配渲染管线描述符的像素格式，使用相应的附件索引，或者一个错误的出现。</p><p>图表 5-2 从描述符创建一个渲染描述状态</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/PipelineState_2x.png" alt="img-w360"></p><p>除了配置颜色附件之外，设置<font color="Fuchsia">MTLRenderPipelineDescriptor</font>对象的这些属性</p><ul><li><p>设置<font color="DarkGray">depthAttachmentPixelFormat</font>属性用<font color="Fuchsia">MTLRenderPassDescriptor</font>来匹配<font color="DarkGray">depthAttachment</font>纹理像素格式。</p></li><li><p>设置<font color="DarkGray">stencilAttachmentPixelFormat</font>属性用<font color="Fuchsia">MTLRenderPassDescriptor</font>来匹配<font color="DarkGray">stencilAttachment</font>纹理像素格式。</p></li><li><p>指定在渲染管线状态的顶点或片元着色器，分别设置<font color="DarkGray">vertexFunction</font>或<font color="DarkGray">fragmentFunction</font>属性，设置<font color="DarkGray">fragmentFunction</font>为nil禁用像素光栅化到指定颜色附件，其表示性地使用仅仅深度渲染或对于输出数据从顶点着色器进入一个缓冲对象。</p></li><li><p>如果顶点着色器有一个带有每个顶点输入属性的参数，设置<font color="DarkGray">vertexDescriptor</font>属性来设置描述顶点数据的组成在那个参数，如数据组成顶点描述符所述。</p></li><li><p><font color="DarkGray">reasteriazationEnabled</font>属性的默认值YES对于大多数典型渲染任务是足够的。只使用图形管线的顶点阶段(例如，收集顶点数据转换)，设置这个属性为NO。</p></li><li><p>如果附件支持多采样(就是说，附件是一个<font color="Fuchsia">MTLTextureTypeDMultisample</font>类型纹理)，那么每个像素多采样可以被创建。决定片元如何结合提供的像素覆盖，使用<font color="Fuchsia">MTLRenderPipelineDescriptor</font>的下列属性。</p><ul><li><font color="DarkGray">sampleCount</font>属性决定每个像素采样数量。当<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>被创建，对于所有附件纹理的<font color="DarkGray">sampleCount</font>必须匹配这个<font color="DarkGray">sampleCount</font>属性。如果附件不支持多采样，那么<font color="DarkGray">sampleCount</font>是1，这也是默认值。</li><li>如果<font color="DarkGray">alphaToCoverageEnabled</font>被设置为YES，那么<font color="DarkGray">colorAttachments[0]</font>透明通道片元输出被读并用来决定覆盖面。</li><li>如果<font color="DarkGray">alphaToOneEnabled</font>被设置为YES，那么<font color="DarkGray">colorAttachment[0]</font>透明通道片元被强制设置为1，这是最大的可表示的值。(其他附件不受影响。)</li></ul></li></ul><h4 id="从描述符创建一个渲染管线状态"><a href="#从描述符创建一个渲染管线状态" class="headerlink" title="从描述符创建一个渲染管线状态"></a>从描述符创建一个渲染管线状态</h4><p>在创建一个渲染管线描述符和指定其属性后，用它来创建MTLRenderPipelineState对象。因为创建一个渲染管线状态可能需要图形状态的一个昂贵的估价和指定图形着色器的可能的编译，你可以使用一个代码块或一个异步方法以一种最适合你应用的方式来安排这样的工作。</p><ul><li>同步创建渲染管线状态对象，调用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象的newRenderPipelineStateWithDescriptor:error:或newRenderPipelineStateWithDescriptor:options:reflections:error:方法。这些方法阻塞了当前线程，当Metal评估描述符图像状态信息和编译着色器代码来创建管线状态对象。</li><li>异步创建着色器管线状态对象，调用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象的newRenderPipelineStateWithDescriptor:completionHandler:或newRenderPipelineStateWithDescriptor:options:completionHandler:方法。这些方法立即返回—Metal异步评估描述符的图像状态信息和编译着色器代码来创建管线状态对象，然后调用完成回调提供新的MTLRenderPipelineState对象。</li></ul><p>当你创建一个MTLRenderPipelineState对像时，你也可以选择去创建揭示管线着色器函数及其参数的反射数据。newRenderPipelineStateWithDescriptor:options:reflection:error:和newRenderPipelineStateWithDescriptor:options:completionHandler:方法提供了这个数据。避免获取反射数据如果它将不被使用。更多关于如何分析反射数据的细节，参见运行时决定功能细节。</p><p>在你创建一个MTLRenderPipelineState对象后，调用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的setRenderPipelineState:方法来关联的渲染管线状态和渲染使用的命令编码器。</p><p>清单5-5 演示渲染管线状态被称为pipeline的对象的创建。</p><p>清单5-5 创建一个简单的管线状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MTLRenderPipelineDescriptor *renderPipelineDesc =</span><br><span class="line">                             [[MTLRenderPipelineDescriptor alloc] init];</span><br><span class="line">renderPipelineDesc.vertexFunction = vertFunc;</span><br><span class="line">renderPipelineDesc.fragmentFunction = fragFunc;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatRGBA8Unorm;</span><br><span class="line"> </span><br><span class="line">// Create MTLRenderPipelineState from &lt;font color=Fuchsia&gt;MTLRenderPipelineDescriptor&lt;/font&gt;</span><br><span class="line">NSError *errors = nil;</span><br><span class="line">id &lt;MTLRenderPipelineState&gt; pipeline = [device</span><br><span class="line">         newRenderPipelineStateWithDescriptor:renderPipelineDesc error:&amp;errors];</span><br><span class="line">assert(pipeline &amp;&amp; !errors);</span><br><span class="line"> </span><br><span class="line">// Set the pipeline state for [&lt;font color=Fuchsia&gt;MTLRenderCommandEncoder&lt;/font&gt;](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)</span><br><span class="line">[renderCE setRenderPipelineState:pipeline];</span><br></pre></td></tr></table></figure><p>变量vertFunc和fragFunc是着色器函数，他们被指定作为渲染管线状态描述符的属性被称作renderPipelineDesc。调用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象的newRenderPipelineStateWithDescriptor:error:方法同步地使用管线状态描述符来创建管线状态对象。调用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的setRenderPipelineState:方法指定MTLRenderPipelineState对象和渲染命令编码器一起使用。</p><blockquote><p>注意:因为创建一个MTLRenderPipelineState对象是昂贵的，无论何时你打算使用相同图像状态应该重用它。</p></blockquote><h4 id="配置渲染管线附件描述符混合"><a href="#配置渲染管线附件描述符混合" class="headerlink" title="配置渲染管线附件描述符混合"></a>配置渲染管线附件描述符混合</h4><p>使用一个高可配置的缓和操作的混合来混合通过带有附件(终点)像素值的片元函数(来源)返回的输出。混合操作决定来源和终点的值是如何与混合因子结合起来的。</p><p>配置颜色附件的混合，设置MTLRenderPipelineColorAttachmentDescriptor的下列属性:</p><ul><li>开启混合，设置blendingEnabled为YES。混合默认是关闭的。</li><li>writeMask识别哪个颜色通道被混合。默认值MTLColorWriteMaskAll允许所有颜色通道被混合。</li><li>rgbBlendOperation和alphaBlendOperation分别用一个MTLBlendOperation值分配RGB和透明片元数据的混合操作。两个属性默认值是MTLBlendOperationAdd。</li><li>sourceRGBBlendFactor，sourceAlphaBlendFactor，destinationRGBBlendFactor和destinationAlphaBlendFactor分配来源和终点混合因子。</li></ul><h4 id="理解混合因子和操作"><a href="#理解混合因子和操作" class="headerlink" title="理解混合因子和操作"></a>理解混合因子和操作</h4><p>四个混合因子指向一个常量混合颜色值:MTLBlendFactorBlendColor，MTLBlendFactorOneMinusBlendColor，MTLBlendFactorBlendAlpha和MTLBlendFactorOneMinusBlendAlpha。调用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的setBlendColorRed:green:blue:alpha:方法用这些混合因子来指定常量颜色和透明值，如固定功能状态操作所述。</p><p>一些混合操作结合片元值通过源值乘以MTLBlendFactor值(缩写SBF)，通过终点混合因子(DBF)乘以终点值并结合使用算术MTLBlendOperation表示的值的结果。(如果混合操作是MTLBlendOperationMin或MTLBlendOperationMax，SBF和DBF混合因子被忽略。)例如，MTLBlendOperationAdd对于如果被BlendOperation和alphaBlendOperation属性定义在下列RGB和透明值的添加剂混合操作:</p><ul><li>RGB = (Source.rgb * sourceRGBBlendFactor) + (Dest.rgb * destinationRGBBlendFactor)</li><li>Alpha = (Source.a * sourceAlphaBlendFactor) + (Dest.a * destinationAlphaBlendFactor)</li></ul><p>在默认的混合行为中，来源完全重写终点。这种行为等价于设置sourceRGBBlendFactor和sourceAlphaBlendFactor为MTLBlendFactorOne，destinationRGBBlendFactor和destinationAlphaBlendFactor为MTLBlendFactorZero。用数学表达这种行为:</p><ul><li>RGB = (Source.rgb * 1.0) + (Dest.rgb * 0.0)</li><li>A = (Source.a * 1.0) + (Dest.a * 0.0)</li></ul><p>另一个正常的使用混合操作，源透明定义了保留多少终点颜色，用数学表达为:</p><ul><li>RGB = (Source.rgb * 1.0) + (Dest.rgb * (1 - Source.a))</li><li>A = (Source.a * 1.0) + (Dest.a * (1 - Source.a))</li></ul><h4 id="使用自定义混合配置"><a href="#使用自定义混合配置" class="headerlink" title="使用自定义混合配置"></a>使用自定义混合配置</h4><p>清单5-6显示了自定义混合配置的代码，使用混合操作MTLBlendOperationAdd，源混合因子MTLBlendFactorOne，终点混合因子MTLBlenderOneMinusSourceAlpha。colorAttachments[0]是一个带有指定混合配置属性的MTLRenderPipelineColorAttachmentDescriptor对象。</p><p>清单5-6 指定一个自定义混合配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MTLRenderPipelineDescriptor *renderPipelineDesc = </span><br><span class="line">                             [[MTLRenderPipelineDescriptor alloc] init];</span><br><span class="line">renderPipelineDesc.colorAttachments[0].blendingEnabled = YES; </span><br><span class="line">renderPipelineDesc.colorAttachments[0].rgbBlendOperation = MTLBlendOperationAdd;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].destinationRGBBlendFactor = </span><br><span class="line">       MTLBlendFactorOneMinusSourceAlpha;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = </span><br><span class="line">       MTLBlendFactorOneMinusSourceAlpha;</span><br><span class="line"></span><br><span class="line">NSError *errors = nil;</span><br><span class="line">id &lt;MTLRenderPipelineState&gt; pipeline = [device </span><br><span class="line">         newRenderPipelineStateWithDescriptor:renderPipelineDesc error:&amp;errors];</span><br></pre></td></tr></table></figure><h3 id="指定渲染命令编码器资源"><a href="#指定渲染命令编码器资源" class="headerlink" title="指定渲染命令编码器资源"></a>指定渲染命令编码器资源</h3><p>在这部分讨论的<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>方法指定被用做顶点和片元着色器函数参数的资源，它们被指定通过在MTLRenderPipelineState对象的vertexFunction和fragmentFunction属性。这些方法分配了一个着色器资源(缓冲，纹理和采样器)到相应的参数表索引(atIndex)在渲染命令编码器中，如图表5-3所示。</p><p>图表 5-3 渲染指令编码器的参数表</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/ArgTable-render_2x.png" alt="img-w600"></p><p>下列setVertex*方法分配顶点着色器函数的相应参数的一个或多个资源。</p><ul><li><font color="DeepSkyBlue">setVertexBuffer:offset:atIndex:</font></li><li><font color="DeepSkyBlue">setVertexBuffers:offsets:withRange:</font></li><li><font color="DeepSkyBlue">setVertexTexture:atIndex:</font></li><li><font color="DeepSkyBlue">setVertexTextures:withRange:</font></li><li><font color="DeepSkyBlue">setVertexSamplerState:atIndex:</font></li><li><font color="DeepSkyBlue">setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:</font></li><li><font color="DeepSkyBlue">setVertexSamplerStates:withRange:</font></li><li><font color="DeepSkyBlue">setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:</font></li></ul><p>setFragment*方法同样的分配一个或多个资源对于相应的片元着色器函数的参数。</p><ul><li><font color="DeepSkyBlue">setFragmentBuffer:offset:atIndex:</font></li><li><font color="DeepSkyBlue">setFragmentBuffers:offsets:withRange:</font></li><li><font color="DeepSkyBlue">setFragmentTexture:atIndex:</font></li><li><font color="DeepSkyBlue">setFragmentTextures:withRange:</font></li><li><font color="DeepSkyBlue">setFragmentSamplerState:atIndex:</font></li><li><font color="DeepSkyBlue">setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:</font></li><li><font color="DeepSkyBlue">setFragmentSamplerStates:withRange:</font></li><li><font color="DeepSkyBlue">setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:</font></li></ul><p>缓冲参数表的有31个条目，纹理参数表有31个条目，采样器状态参数表有16个条目。</p><p>属性限定符指定Metal着色语言源码的资源位置必须匹配Metal框架方法的参数表索引。在清单5-7中，各自被定义在顶点着色器中有索引0和1的两个缓冲区(posBuf和texCoordBuf)</p><p>清单5-7 Metal框架:指定顶点函数资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[renderEnc setVertexBuffer:posBuf offset:0 atIndex:0];</span><br><span class="line">[renderEnc setVertexBuffer:texCoordBuf offset:0 atIndex:1];</span><br></pre></td></tr></table></figure><p>清单5-8 Metal着色语言:顶点函数参数匹配框架参数表索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vertex VertexOutput metal_vert(float4 *posData [[ buffer(0) ]],</span><br><span class="line">                               float2 *texCoordData [[ buffer(1) ]])</span><br></pre></td></tr></table></figure><p>相似地，在清单5-9中，缓冲，纹理和采样器(分别的fragmentColorBuf，shadeTex和sampler)，所有索引为0的，被定义在片元着色器。</p><p>清单5-9 Metal框架:指定片元函数资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[renderEnc setFragmentBuffer:fragmentColorBuf offset:0 atIndex:0];</span><br><span class="line">[renderEnc setFragmentTexture:shadeTex atIndex:0];</span><br><span class="line">[renderEnc setFragmentSamplerState:sampler atIndex:0];</span><br></pre></td></tr></table></figure><p>在清单5-10中，函数签名有带有属性限定符<font color="DarkMagenta">buffer(0)</font>， <font color="DarkMagenta">texture(0)</font>和<font color="DarkMagenta">sampler(0)</font>相应的参数。</p><p>清单5-10 Metal着色语言:片元函数参数匹配框架参数表索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fragment float4 metal_frag(VertexOutput in [[stage_in]],</span><br><span class="line">                           float4 *fragColorData [[ buffer(0) ]],</span><br><span class="line">                           texture2d&lt;float&gt; shadeTexValues [[ texture(0) ]],</span><br><span class="line">                           sampler samplerValues [[ sampler(0) ]] )</span><br></pre></td></tr></table></figure><h4 id="数据组织的顶点描述符"><a href="#数据组织的顶点描述符" class="headerlink" title="数据组织的顶点描述符"></a>数据组织的顶点描述符</h4><p>在Metal框架代码中，对于每个管线状态可以有一个MTLVertexDescriptor，它描述了顶点着色函数输入数据的组织和在着色语言和框架代码之间共享资源位置信息。</p><p>在Metal着色语言代码中，每个顶点输入(例如整型活浮点型值的标量或矢量)可以被组织在一个结构体中，它可以被传递进一个用<font color="DarkMagenta">[[ stage_in ]]</font>声明属性限定符声明的参数，正如清单5-11中顶点函数vertexMath例子中看到的VertexInput结构体。每个顶点的输入结构体的各个域有<font color="DarkMagenta">[[ attribute(index) ]]</font>限定符，它指定了顶点属性参数表的索引。</p><p>清单5-11 Metal着色语言:带有属性索引的顶点函数输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct VertexInput &#123;</span><br><span class="line">    float2    position [[ attribute(0) ]];</span><br><span class="line">    float4    color    [[ attribute(1) ]];</span><br><span class="line">    float2    uv1      [[ attribute(2) ]];</span><br><span class="line">    float2    uv2      [[ attribute(3) ]];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct VertexOutput &#123;</span><br><span class="line">    float4 pos [[ position ]];</span><br><span class="line">    float4 color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vertex VertexOutput vertexMath(VertexInput in [[ stage_in ]])</span><br><span class="line">&#123;</span><br><span class="line">  VertexOutput out;</span><br><span class="line">  out.pos = float4(in.position.x, in.position.y, 0.0, 1.0);</span><br><span class="line"></span><br><span class="line">  float sum1 = in.uv1.x + in.uv2.x;</span><br><span class="line">  float sum2 = in.uv1.y + in.uv2.y;</span><br><span class="line">  out.color = in.color + float4(sum1, sum2, 0.0f, 0.0f);</span><br><span class="line">  return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定着色器函数功能输入使用<font color="DarkMagenta">[[ stage_in ]]</font>限定符，描述MTLVertexDescriptor对象，设置它作为MTLRenderPipelineState的vertexDescriptor属性。MTLVertexDescriptor有两个属性:attributes和layouts。</p><p>MTLVertexDescriptor的attributes属性是一个MTLVertexAttributeDescriptorArray对象，它定义了每个顶点属性在被纹理映射到顶点函数参数的缓冲中是如何组织的。attributes属性可以支持存取多个属性(例如顶点坐标，表面法线和纹理顶点)在相同缓冲区内是交叉的。在着色语言代码中成员的顺序没有必要被保存在框架代码的缓冲区中。数组中的每个顶点属性描述符有一下属性，提供一个顶点着色函数信息去定位和加载参数数据:</p><ul><li>bufferIndex，是一个缓冲参数表的索引，指定哪个MTLBuffer被访问。缓冲参数表在渲染命令编码器的指定资源章节中被讨论。</li><li>format，指定在框架代码中的数据应当如何被解释。如果数据类型不是一个精确的类型匹配，它可能被转换或扩展。例如，如果着色语言类型是half4，框架format是MTLVertexFormatFloat2，那么当数据被用作一个顶点函数的参数时，它可能被从浮点数转换到half并且扩展从2到4个元素(用0.0, 1.0在最后两个元素)。</li><li>offset，指定数据从顶点的起点开始被发现的位置。</li></ul><p>图表 5-4 在Metal框架代码中阐明MTLVertexAttributeDescriptorArray，实现一个交叉缓冲区，和在清单5-11中的着色器语言代码中的顶点函数vertexMath的输入一致。</p><p>图表 5-4 带有顶点属性描述符的缓冲区组织</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/vertex-layout_2x.png" alt="img-w600"></p><p>清单5-12 和图表 5-4中显示的交叉缓冲区相对应的Metal框架代码。</p><p>清单5-12 Metal框架:使用一个顶点描述符访问交叉数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">id &lt;&lt;font color=Fuchsia&gt;MTLFunction&lt;/font&gt;&gt; vertexFunc = [library newFunctionWithName:@&quot;vertexMath&quot;];            </span><br><span class="line">&lt;font color=Fuchsia&gt;MTLRenderPipelineDescriptor&lt;/font&gt;* pipelineDesc =      </span><br><span class="line">                             [[&lt;font color=Fuchsia&gt;MTLRenderPipelineDescriptor&lt;/font&gt; alloc] init];</span><br><span class="line">MTLVertexDescriptor* vertexDesc = [[MTLVertexDescriptor alloc] init];</span><br><span class="line"></span><br><span class="line">vertexDesc.attributes[0].format = MTLVertexFormatFloat2;</span><br><span class="line">vertexDesc.attributes[0].bufferIndex = 0;</span><br><span class="line">vertexDesc.attributes[0].offset = 0;</span><br><span class="line">vertexDesc.attributes[1].format = MTLVertexFormatFloat4;</span><br><span class="line">vertexDesc.attributes[1].bufferIndex = 0;</span><br><span class="line">vertexDesc.attributes[1].offset = 2 * sizeof(float);  // 8 bytes</span><br><span class="line">vertexDesc.attributes[2].format = MTLVertexFormatFloat2;</span><br><span class="line">vertexDesc.attributes[2].bufferIndex = 0;</span><br><span class="line">vertexDesc.attributes[2].offset = 8 * sizeof(float);  // 32 bytes</span><br><span class="line">vertexDesc.attributes[3].format = MTLVertexFormatFloat2;</span><br><span class="line">vertexDesc.attributes[3].bufferIndex = 0;</span><br><span class="line">vertexDesc.attributes[3].offset = 6 * sizeof(float);  // 24 bytes</span><br><span class="line">vertexDesc.layouts[0].stride = 10 * sizeof(float);    // 40 bytes</span><br><span class="line">vertexDesc.layouts[0].stepFunction = MTLVertexStepFunctionPerVertex;</span><br><span class="line"></span><br><span class="line">pipelineDesc.vertexDescriptor = vertexDesc;</span><br><span class="line">pipelineDesc.vertexFunction = vertFunc;</span><br></pre></td></tr></table></figure><p>在MTLVertexDescriptor对象的attributes数组中的每个MTLVertexAttributeDescriptor对象和着色函数中VertexInput的索引结构体成员相对应。attributes[1].bufferIndex = 0指定参数表索引是0的缓冲的使用。(在这个例子中，每个MTLVertexAttributeDescriptor有相同的bufferIndex，所以每个指向参数表中的索引为0的相同顶点缓冲。)offset值指定在顶点中数据的位置，所以attributes[1].offset = 2 * sizeof(float)位于来自缓冲区起始位置的相应数据的8个字节的开头。format值被选择匹配着色函数的数据类型，所以attributes[1].format = MTLVertexFormatFloat4指定使用四个浮点数值。</p><p>MTLVertexDescriptor的layouts属性是一个MTLVertexBufferLayoutDescriptorArray。对于在layouts中的每个MTLVertexBufferLayoutDescriptor，属性指定当Metal绘制基元时顶点和属性数据是如何从相应的位于参数表中的MTLBuffer中获取的。(对于更多关于绘制基元的内容，参见绘制几何基元。)MTLVertexBufferLayoutDescriptor的stepFunction属性决定是否去获取每个顶点的属性数据，对于一些数量的实例，或仅此一次。如果stepFunction被设置来获取一些数量实例的属性数据，那么MTLVertexBufferLayoutDescriptor的stepRate属性决定多少实例。stride属性指定两顶点的数据之间的距离，以字节计算。</p><p>图表 5-5 描述MTLVertexBufferLayoutDescriptor对应的diamante在清单5-12中。layout[0]指定如何从缓冲区参数表对应索引0的位置获取顶点数据。layouts[0].stride指定在两个顶点数据之间的40个字节的一个距离。layout[0].stepFunction的值MTLVertexStepFunctionPerVertex，指定绘制时每个顶点获取到的属性数据。如果stepFunction的值时MTLVertexStepFunctionPerInstance，stepRate属性决定了属性数据多久获取一次。例如，如果stepRate是1，数据被获取对于每个实例；如果stepRate是2，对于每两个实例，等等。</p><p>图表 5-5 缓冲区组织用顶点缓冲布局描述符</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/vertex-layout_detailed_2x.png" alt="img-w600"></p><h3 id="执行固定功能渲染命令编码器操作"><a href="#执行固定功能渲染命令编码器操作" class="headerlink" title="执行固定功能渲染命令编码器操作"></a>执行固定功能渲染命令编码器操作</h3><p>使用这些<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>方法设置固定功能图形状态值:</p><ul><li><p>setViewport:指定在屏幕坐标中的区域，它是虚拟3D世界投影的终点。视口是3D，所以它包含深度值；详情请见与视口和像素坐标系统一起工作。</p></li><li><p>setTriangleFillMode:决定是否光栅化三角形和有皱纹的三角形带基元(MTLTriangleFillModeLines)或作为填充三角形(MTLLTriangleFillModeFill)。默认值是MTLTriangleFillModeFill。</p></li><li><p>setCullMode:和setFrontFacingWinding:被一起使用去决定是否和如何挑选被应用。你可以使用挑选在一些几何模型上除去隐藏表面，例如一个用填充三角形渲染的可定向的球体。(表面是可定向的如果它的基元被一致地绘制按照顺时针或逆时针顺序)</p><ul><li>setFrontFacingWinding的值:表明是否一个正面基元有它的顶点按照顺时针(MTLWindingClockWise)被绘制或逆时针(MTLWindingCounterClockwise)顺序。默认值是MTLWindingClockWise。</li><li>setCullMode的值:表明是否去执行选择(MTLCullModeNone，如果选择被禁用)或去选择哪个基元类型(MTLCullModeFront或MTLCullModeBack)。</li></ul></li></ul><p>使用以下<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>方法去编码固定功能状态改变命令:</p><ul><li><p>setScissorRect:指定一个2D剪刀矩形。位于指定剪刀矩形外面的片元被丢弃。</p></li><li><p>setDepthStencilState:设置深度和模板测试状态如深度和模板状态中描述。</p></li><li><p>setStencilReferenceValue:指定模板引用值。</p></li><li><p>setDepthBias:slopeScale:clamp:指定一个对比阴影映射和来自片元着色器的深度值输出的调整。</p></li><li><p>setVisibilityResultMode:offset:决定是否去监控如果任何采样器通过深度和模板测试。如果设置MTLVisibilityResultModeBoolean，那么如果任何采样器通过深度和模板测试，一个非零值被写入一个由<font color="Fuchsia">MTLRenderPassDescriptor</font>的visibilityResultBuffer属性指定的缓冲区，如创建一个渲染通道描述符所述。</p><p>你可以使用这个模式去执行遮挡测试。如果你绘制一个边界盒子并且没有样本通过，那么你可以得出结论，在该边界盒子里面的任何对象被遮挡，因此不需要渲染。</p></li></ul><h4 id="使用视口和像素坐标系统"><a href="#使用视口和像素坐标系统" class="headerlink" title="使用视口和像素坐标系统"></a>使用视口和像素坐标系统</h4><p>Metal定义了其规格化设备坐标(NDC)系统作为中心在(0，0，0.5)的2×2×1立方体。左侧和底部的x和y分别被NDC系统指定为-1。右侧和顶部的x和y分别被NDC系统设置为+1。</p><p>视口指定来自NDC到窗口系统的转换。Metal视口是一个由<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>得setViewport:方法指定的3D转换。窗口原点坐标是在左上角。</p><p>在Metal中，像素中心偏移(0.5，0.5)。例如，原点像素有它的中心在(0.5，0.5)；其右边相邻像素的中心是(1.5，0.5)。这也是真实的纹理。</p><h4 id="执行深度和模板操作"><a href="#执行深度和模板操作" class="headerlink" title="执行深度和模板操作"></a>执行深度和模板操作</h4><p>深度和模板操作是如下指定的片段操作:</p><ol><li>指定一个自定义MTLDepthStencilDescriptor对象包含深度/模板状态的设置。创建一个自定义MTLDepthStencilDescriptor对象可能需要创建一个或两个MTLStencilDescriptor对象，适用于正面和背面基元。</li><li>通过调用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>对象的newDepthStencilStateWithDescriptor:方法来创建一个带有深度/模板状态描述符的MTLDepthStencilState对象.</li><li>设置深度/模板状态，调用支持MTLDepthStencilState的<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的setDepthStencilState:方法。</li><li>如果模板测试在使用，调用setStencilReferenceValue:来制定模板参考值。</li></ol><p>如果深度测试被启用，渲染管线状态必须包含一个深度附件来支持写深度值。执行模板测试，渲染管线状态必须包含一个模板附件。配置附件，参见创建和配置一个渲染管线描述符。</p><p>如果你经常改变深度/模板状态，那么你可能想重用状态描述符对象，修改其属性值需要创建更多的状态对象。</p><blockquote><p>注意: 从着色器函数中的深度格式纹理采样，着色器中实现采样操作不使用MTLSamplerState。</p></blockquote><p>使用如下所示的MTLDepthStencilDescriptor对象的属性来设置深度和模板状态:</p><ul><li>对深度附件开启写深度值，设置depthWriteEnabled为YES。</li><li>depthCompareFunction指定深度测试如何被执行。如果一个片元的深度值在深度测试中失败，该片元被丢弃。例如，通常被用到的MTLComapreFunctionLess函数引起比(以前写入的)像素深度距离观察者更远的片元值在深度测试中失败；换言之，该片段被认为是由早期的深度值闭塞。</li><li>frontFaceStencil和backFaceStencil属性分别指定一个各自的MTLStencilDescriptor对象对于正面和背面基元。对于正面和背面基元使用相同模板状态，你可以分配同一个MTLStencilDescriptor到frontFaceStencil和backFaceStencil属性。显式地禁用模板测试对于一个或两个表面，设置相应的属性为nil，默认值。</li></ul><p>显式地禁用模板状态是没有必要的。Metal基于模板描述符是否被配置到一个有效模板操作来决定是否去开启一个模板测试。</p><p>清单5-13 显示了一个创建的例子和对于MTLDepthStencilState对象的创建使用MTLDepthStencilDescriptor对象，然后使用渲染命令编码器。在这个例子中，正面基元的模板状态从深度/模板状态描述符的frontFaceStencil属性被存取。对于背面基元模板测试被显式地禁用。</p><p>清单5-13 创建和使用一个深度/模板描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MTLDepthStencilDescriptor *dsDesc = [[MTLDepthStencilDescriptor alloc] init];</span><br><span class="line">if (dsDesc == nil)</span><br><span class="line">     exit(1);   //  if the descriptor could not be allocated</span><br><span class="line">dsDesc.depthCompareFunction = MTLCompareFunctionLess;</span><br><span class="line">dsDesc.depthWriteEnabled = YES;</span><br><span class="line"> </span><br><span class="line">dsDesc.frontFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;</span><br><span class="line">dsDesc.frontFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;</span><br><span class="line">dsDesc.frontFaceStencil.depthFailureOperation = MTLStencilOperationIncrementClamp;</span><br><span class="line">dsDesc.frontFaceStencil.depthStencilPassOperation =</span><br><span class="line">                          MTLStencilOperationIncrementClamp;</span><br><span class="line">dsDesc.frontFaceStencil.readMask = 0x1;</span><br><span class="line">dsDesc.frontFaceStencil.writeMask = 0x1;</span><br><span class="line">dsDesc.backFaceStencil = nil;</span><br><span class="line">id &lt;MTLDepthStencilState&gt; dsState = [device</span><br><span class="line">                          newDepthStencilStateWithDescriptor:dsDesc];</span><br><span class="line"> </span><br><span class="line">[renderEnc setDepthStencilState:dsState];</span><br><span class="line">[renderEnc setStencilReferenceValue:0xFF];</span><br></pre></td></tr></table></figure><p>以下属性在MTLStencilDescriptor中定义模板测试:</p><ul><li>readMask是一个位掩码；GPU计算的按位“与”这个掩码与模板参考值与存储的模板值。模板测试时一个在作为结果的掩饰性参考和掩饰性存储值得对比。</li><li>writeMask是一个位掩码，约束通过模板操作被写到模板附件中的模板值。</li><li>stencilCompareFunction指定对于片元模板测试是如何被执行的。在清单5-13中，模板对照函数是MTLCompareFunctionEqual，所以模板测试通过掩饰性参考值是等于掩饰性模板值已经存储在一个片元的位置。</li><li>stencilFailureOperation，depthFailureOperation和depthStencilPassOperation指定存储到模板附件的模板值对于三个不同的测试结果该做什么:分别地，如果模板测试失败，如果模板测试通过但深度测试失败，或者模板和深度测试都成功。在前面的例子中，如果模板测试失败模板值是不变的(MTLStencilOperationKeep)，但是它是增加的如果模板测试通过，除非模板值可能已经是最大值(MTLStencilOperationIncrementClamp)。</li></ul><h3 id="绘制几何基元"><a href="#绘制几何基元" class="headerlink" title="绘制几何基元"></a>绘制几何基元</h3><p>在你已经确定管线状态和固定功能状态后，你可以调用下列<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>方法来绘制几何基元。这些绘制方法引用资源(例如包含顶点坐标，纹理坐标，表面法线及其他数据的缓冲区)与着色器函数和以前用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>确定的其他状态一起执行管线。</p><ul><li>drawPrimitives:vertexStart:vertexCount:instanceCount:渲染大量(instanceCount)使用连续数组元素的顶点数据基元的实例，开始于数组元素的索引vertexStart并结束于数组元素索引vertexStart + vertexCount - 1。</li><li>drawPrimitives:vertexStart:vertexCount:和以前的有一个instanceCount为1的方法相同。</li><li>drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:渲染大量(instanceCount)使用一个在MTLBuffer对象indexBuffer指定的索引列表基元实例。indexCount决定的数量指标。索引表开始于indexBuffer里的数据内indexBufferOffset字节偏移的索引。indexBufferOffset必须是索引大小的倍数，它由indexType决定。</li><li>drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:和以前的有一个instanceCount为1的方法类似。</li></ul><p>对于上述的每个基元渲染方法，第一个输入值用MTLPrimitiveType值中的一个来决定基元类型。其他输入值决定顶点被用来聚集基元。对于所有这些输入方法，instanceStart输入值决定绘制的第一个实例，instanceCount输入值决定绘制多少个实例。</p><p>像先前讨论的，setTriangleFillMode:决定是否三角形被渲染为填满或线框，setCullMode:和setFrontFacingWinding:设置决定是否GPU在渲染期间剔除三角形。对于更多信息，参见固定功能状态操作。</p><p>当渲染一个点基元时，顶点函数的着色器语言代码必须提供[[ point_size ]]属性，或点大小是未定义的。</p><p>当扁平渲染一个三角形基元时，第一个顶点(又称为引发顶点)的属性被整个三角形使用。顶点函数的着色语言代码必须提供<font color="DarkMagenta">[[ flat ]]</font>的插值限定符。</p><p>关于所有Metal着色语言属性和限定符更多细节，参见Metal着色语言指南。</p><h3 id="结束渲染过程"><a href="#结束渲染过程" class="headerlink" title="结束渲染过程"></a>结束渲染过程</h3><p>结束渲染过程，调用在渲染命令编码上的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>函数。在结束以前的命令编码器后，你可以创建一个任何类型新的命令编码器来编码额外的命令进入到命令缓冲区。</p><h3 id="代码例子-绘制一个三角形"><a href="#代码例子-绘制一个三角形" class="headerlink" title="代码例子:绘制一个三角形"></a>代码例子:绘制一个三角形</h3><p>清单5-14阐述的下列步骤描述了一个渲染三角形基本的过程。</p><ol><li><p>创建一个<a href="https://developer.apple.com/documentation/metal/mtlcommandqueue" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandQueue</font></a>并用它创建一个<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>。</p></li><li><p>创建一个<font color="Fuchsia">MTLRenderPassDescriptor</font>，它指定了一个附件集合，这些附件作为命令缓冲区中编码的渲染命令的终点。</p><p>在这个例子中，仅仅第一个颜色附件被建立和使用。(变量currentTexture假定包含一个MTLTexture，它被用作一个颜色附件。)然后<font color="Fuchsia">MTLRenderPassDescriptor</font>被用来创建一个新的<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>。</p></li><li><p>创建两个MTLBuffer对象，posBuf和colBuf，调用newBufferWithBytes:length:options:来拷贝顶点坐标和顶点颜色数据，posData和colData，分别进入缓冲区存储。</p></li><li><p>调用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的<font color="DeepSkyBlue">setVertexBuffer:offset:atIndex:</font>方法两次去指定坐标和颜色。</p><p><font color="DeepSkyBlue">setVertexBuffer:offset:atIndex:</font>方法的输入值atIndex对应顶点函数源码中的属性buffer(atIndex)。</p></li><li><p>创建一个<font color="Fuchsia">MTLRenderPipelineDescriptor</font>并确定在管线描述符中的顶点和片元函数:</p><ul><li>用来自progSrc的源码创建一个<font color="Fuchsia">MTLLibrary</font>，它被假定为一个字符串，该字符串包含Metal着色器源码。</li><li>然后调用<font color="Fuchsia">MTLLibrary</font>的newFunctionWithName:方法来创建<font color="Fuchsia">MTLFunction</font> verFunc表示hello_vertex的函数，创建<font color="Fuchsia">MTLFunction</font> fragFunc表示hello_fragment的函数。</li><li>最终，用这些<font color="Fuchsia">MTLFunction</font>对象设置<font color="Fuchsia">MTLRenderPipelineDescriptor</font>的vertexFunction和fragmentFunction属性。</li></ul></li><li><p>通过调用newRenderPipelineStateWithDescriptor:error:或<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>的一个相似方法从<font color="Fuchsia">MTLRenderPipelineDescriptor</font>创建一个MTLRenderPipelineState。然后使用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的setRenderPipelineState:方法创建渲染管线状态。</p></li><li><p>调用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的drawPrimitives:vertexStart:vertexCount:方法追加命令去执行一个填充三角形(MTLPrimitvieTypeTriangle类型)的渲染。</p></li><li><p>调用<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>方法来结束这个渲染过程的编码。调用<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443003-commit" target="_blank" rel="noopener">commit</a></font>方法来执行设备上的命令。</p></li></ol><p>清单5-14 绘制三角形的Metal代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">id MTLDevice device = MTLCreateSystemDefaultDevice();</span><br><span class="line"> </span><br><span class="line">id MTLCommandQueue commandQueue = [device newCommandQueue];</span><br><span class="line">id MTLCommandBuffer commandBuffer = [commandQueue commandBuffer];</span><br><span class="line"> </span><br><span class="line">MTLRenderPassDescriptor *renderPassDesc</span><br><span class="line">                               = [MTLRenderPassDescriptor renderPassDescriptor];</span><br><span class="line">renderPassDesc.colorAttachments[0].texture = currentTexture;</span><br><span class="line">renderPassDesc.colorAttachments[0].loadAction = MTLLoadActionClear;</span><br><span class="line">renderPassDesc.colorAttachments[0].clearColor = MTLClearColorMake(0.0,1.0,1.0,1.0);</span><br><span class="line">id &lt;MTLRenderCommandEncoder&gt; renderEncoder =</span><br><span class="line">           [commandBuffer renderCommandEncoderWithDescriptor:renderPassDesc];</span><br><span class="line"> </span><br><span class="line">static const float posData[] = &#123;</span><br><span class="line">        0.0f, 0.33f, 0.0f, 1.f,</span><br><span class="line">        -0.33f, -0.33f, 0.0f, 1.f,</span><br><span class="line">        0.33f, -0.33f, 0.0f, 1.f,</span><br><span class="line">&#125;;</span><br><span class="line">static const float colData[] = &#123;</span><br><span class="line">        1.f, 0.f, 0.f, 1.f,</span><br><span class="line">        0.f, 1.f, 0.f, 1.f,</span><br><span class="line">        0.f, 0.f, 1.f, 1.f,</span><br><span class="line">&#125;;</span><br><span class="line">id &lt;MTLBuffer&gt; posBuf = [device newBufferWithBytes:posData</span><br><span class="line">        length:sizeof(posData) options:nil];</span><br><span class="line">id &lt;MTLBuffer&gt; colBuf = [device newBufferWithBytes:colData</span><br><span class="line">        length:sizeof(colData) options:nil];</span><br><span class="line">[renderEncoder setVertexBuffer:posBuf offset:0 atIndex:0];</span><br><span class="line">[renderEncoder setVertexBuffer:colBuf offset:0 atIndex:1];</span><br><span class="line"> </span><br><span class="line">NSError *errors;</span><br><span class="line">id &lt;MTLLibrary&gt; library = [device newLibraryWithSource:progSrc options:nil</span><br><span class="line">                           error:&amp;errors];</span><br><span class="line">id &lt;MTLFunction&gt; vertFunc = [library newFunctionWithName:@&quot;hello_vertex&quot;];</span><br><span class="line">id &lt;MTLFunction&gt; fragFunc = [library newFunctionWithName:@&quot;hello_fragment&quot;];</span><br><span class="line">MTLRenderPipelineDescriptor *renderPipelineDesc</span><br><span class="line">                                   = [[MTLRenderPipelineDescriptor alloc] init];</span><br><span class="line">renderPipelineDesc.vertexFunction = vertFunc;</span><br><span class="line">renderPipelineDesc.fragmentFunction = fragFunc;</span><br><span class="line">renderPipelineDesc.colorAttachments[0].pixelFormat = currentTexture.pixelFormat;</span><br><span class="line">id &lt;MTLRenderPipelineState&gt; pipeline = [device</span><br><span class="line">             newRenderPipelineStateWithDescriptor:renderPipelineDesc error:&amp;errors];</span><br><span class="line">[renderEncoder setRenderPipelineState:pipeline];</span><br><span class="line">[renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle</span><br><span class="line">               vertexStart:0 vertexCount:3];</span><br><span class="line">[renderEncoder endEncoding];</span><br><span class="line">[commandBuffer commit];</span><br></pre></td></tr></table></figure><p>在清单5-14中，一个<font color="Fuchsia">MTLFunction</font>对象表示叫做hello_vertex的着色器函数。<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的<font color="DeepSkyBlue">setVertexBuffer:offset:atIndex:</font>的方法被用来指定顶点资源(在这个实例中，两个buffer对象)作为参数被传递进hello_vertex中。<font color="DeepSkyBlue">setVertexBuffer:offset:atIndex:</font>方法的输入值atIndex对应顶点函数源码中的属性buffer(atIndex)，如清单5-15所示。</p><p>清单5-15 对应的着色器函数声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vertex VertexOutput hello_vertex(</span><br><span class="line">                    const global float4 *pos_data [[ buffer(0) ]],</span><br><span class="line">                    const global float4 *color_data [[ buffer(1) ]])</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用多线程编码单一渲染通道"><a href="#使用多线程编码单一渲染通道" class="headerlink" title="使用多线程编码单一渲染通道"></a>使用多线程编码单一渲染通道</h3><p>在一些情况下，你应用的性能可能被单一渲染通道编码命令的单CPU工作量限制。然而，尝试避免这个瓶颈通过分离的工作量进入到多个CPU线程进行编码的多个渲染通道也可能会影响性能，因为每个渲染通道需要其本身中间附件存储和保存渲染目标内容的加载动作。</p><p>相反地，使用一个<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>对象，它管理多个附属的<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>对象，这些对象共享相同命令缓冲和渲染通道描述符。并行渲染命令编码器保证附件加载和存储动作只发生在整个渲染通道的开始和结尾，而不是每个附属渲染命令编码器的指令集合的开头和结尾。在这种体系结构下，你可以并行、安全以及高效地方式分配每个<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>对象到它自己的线程。</p><p>使用<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象的paralleleRenderCommandEncoderWithDescriptor:方法创建一个并行渲染命令编码器。从你想去执行命令编码的每个CPU线程调用一次<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>对象的renderCommandEncoder方法创建附属命令编码器。所有来自相同并行渲染命令编码器创建的附属命令编码器进行编码相同命令缓冲的命令。按顺序被编码到命令缓冲区的命令，在该命令中，渲染命令编码器被创建。调用<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>的<font color="DeepSkyBlue">endEncoding</font>方法来结束指定渲染命令编码。在所有由并行渲染命令编码器创建的渲染命令编码器结束编码以后，调用<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>的<font color="DeepSkyBlue">endEncoding</font>方法去结束渲染过程。</p><p>清单5-16 展示<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>创建三个<a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLRenderCommandEncoder</font></a>对象:rCE1，rCE2和rCE3。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MTLRenderPassDescriptor *renderPassDesc </span><br><span class="line">                     = [MTLRenderPassDescriptor renderPassDescriptor];</span><br><span class="line">renderPassDesc.colorAttachments[0].texture = currentTexture;</span><br><span class="line">renderPassDesc.colorAttachments[0].loadAction = MTLLoadActionClear;</span><br><span class="line">renderPassDesc.colorAttachments[0].clearColor = MTLClearColorMake(0.0,0.0,0.0,1.0);</span><br><span class="line"></span><br><span class="line">id &lt;MTLParallelRenderCommandEncoder&gt; parallelRCE = [commandBuffer </span><br><span class="line">                     parallelRenderCommandEncoderWithDescriptor:renderPassDesc];</span><br><span class="line">id &lt;MTLRenderCommandEncoder&gt; rCE1 = [parallelRCE renderCommandEncoder];</span><br><span class="line">id &lt;MTLRenderCommandEncoder&gt; rCE2 = [parallelRCE renderCommandEncoder];</span><br><span class="line">id &lt;MTLRenderCommandEncoder&gt; rCE3 = [parallelRCE renderCommandEncoder];</span><br><span class="line"></span><br><span class="line">//  not shown: rCE1, rCE2, and rCE3 call methods to encode graphics commands</span><br><span class="line">//</span><br><span class="line">//  rCE1 commands are processed first, because it was created first</span><br><span class="line">//  even though rCE2 and rCE3 end earlier than rCE1</span><br><span class="line">[rCE2 endEncoding];</span><br><span class="line">[rCE3 endEncoding];</span><br><span class="line">[rCE1 endEncoding];</span><br><span class="line"></span><br><span class="line">//  all [&lt;font color=Fuchsia&gt;MTLRenderCommandEncoder&lt;/font&gt;](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)s must end before [&lt;font color=Fuchsia&gt;MTLParallelRenderCommandEncoder&lt;/font&gt;](https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder)</span><br><span class="line">[parallelRCE endEncoding];</span><br></pre></td></tr></table></figure><p>命令编码器的调用<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>的顺序与命令被编码和追加进<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>的顺序无关。<a href="https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLParallelRenderCommandEncoder</font></a>，<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>总是按附属渲染命令编码器被创建的顺序包含命令，如图表5-6所示。</p><p>图表 5-6 并行渲染通道中渲染命令编码器的排序</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/Parallel-Pass_2x.png" alt=""></p><h2 id="数据并行计算处理-计算命令编码器"><a href="#数据并行计算处理-计算命令编码器" class="headerlink" title="数据并行计算处理:计算命令编码器"></a>数据并行计算处理:计算命令编码器</h2><p>这章解释如何创建和使用一个<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>对象去编码数据并行计算处理状态，命令以及提交他们到设备执行。</p><p>执行一个数据并行计算，主要有下面这些步骤:</p><ol><li>使用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>方法来创建一个计算状态(MTLComputePipelineState)，其包含来自<font color="Fuchsia">MTLFunction</font>对象编译的代码，如创建计算状态中讨论的。<font color="Fuchsia">MTLFunction</font>对象表示Metal着色语言中的编写的一个计算函数，如函数和库中描述的。</li><li>通过计算命令编码器来使用指定的MTLComputePipelineState对象，正如在指定计算状态和计算命令编码器资源中讨论的。</li><li>指定资源和相关对象(MTLBuffer，MTLTexture和可能的MTLSamplerState)可能包含被处理的数据和通过计算状态返回的数据，正如在指定计算状态和计算命令编码器资源中讨论的。也设置他们的参数表指数，以便Metal框架代码可以定位一个在着色器代码中相应的资源。在任何给定时刻，<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>可以被关联到许多资源对象。</li><li>调度指定次数的计算函数，正如执行计算命令中解释的。</li></ol><h3 id="创建计算管线状态"><a href="#创建计算管线状态" class="headerlink" title="创建计算管线状态"></a>创建计算管线状态</h3><p><font color="Fuchsia">MTLFunction</font>对象表示数据并行代码可以通过MTLComputePipelineState对象被执行。<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>对象编码命令，这些命令设置参数和执行计算功能。因为创建一个计算管线状态可能需要一个Metal着色语言代码的昂贵的编译，你可以使用一种最适合你应用设计的块或者异步方法来安排这样的工作。</p><ul><li>同步创建计算管线状态对象，调用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>的<font color="DeepSkyBlue">newComputePipelineStateWithFunction:error:</font>或<font color="DeepSkyBlue">newComputePipelineStateWithFunction:options:reflection:error:</font>方法。当Metal编译着色器代码来创建管线状态对象时这些方法阻塞了当前线程。</li><li>异步创建计算管线状态对象，调用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>的<font color="DeepSkyBlue">newComputePipelineStateWithFunction:completionHandler:</font>或<font color="DeepSkyBlue">newComputePipelineStateWithFunction:options:completionHandler:</font>方法。这些方法立即返回—Metal异步编译着色器代码来创建管线状态对象，然后调用完成回调去提供新的MTLComputePipelineState对象。</li></ul><p>当你创建一个MTLComputePipelineState对象时，你也可以选择去创建反射数据，这些数据揭示了计算函数的细节及其参数。<font color="DeepSkyBlue">newComputePipelineStateWithFunction:options:reflection:error:</font>和<font color="DeepSkyBlue">newComputePipelineStateWithFunction:options:completionHandler:</font>方法提供了这个数据。避免获取反射数据如果它不被使用。更多关于如何分析反射数据的信息，参见决定运行时函数细节。</p><h3 id="指定计算状态和计算命令编码器的资源"><a href="#指定计算状态和计算命令编码器的资源" class="headerlink" title="指定计算状态和计算命令编码器的资源"></a>指定计算状态和计算命令编码器的资源</h3><p><a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>对象的setComputePipelineState:方法指定其状态，包括一个编译的计算渲染函数，使用数据并行计算通道。在任何给定时刻，计算命令编码器可以被关联到仅有的一个计算函数。</p><p>下列<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>方法指定资源(就是说，缓冲，纹理，采样器状态或线程组内存)作为通过MTLComputePipelineState对象表现的计算函数的一个参数。</p><ul><li><font color="DeepSkyBlue">setBuffer:offset:atIndex:</font></li><li><font color="DeepSkyBlue">setBuffers:offsets:withRange:</font></li><li><font color="DeepSkyBlue">setTexture:atIndex:</font></li><li><font color="DeepSkyBlue">setTextures:withRange:</font></li><li><font color="DeepSkyBlue">setSamplerState:atIndex:</font></li><li><font color="DeepSkyBlue">setSamplerState:lodMinClamp:lodMaxClamp:atIndex:</font></li><li><font color="DeepSkyBlue">setSamplerStates:withRange:</font></li><li><font color="DeepSkyBlue">setSamplerStates:lodMinClamps:lodMaxClamps:withRange:</font></li><li><font color="DeepSkyBlue">setThreadgroupMemoryLength:atIndex:</font></li></ul><p>每个方法分配一个或多个资源到对应的参数，如图表6-1所示。</p><p>图标 6-1 计算命令编码器的参数表</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/ArgTable-compute_2x.png" alt="img-w400"></p><p>缓冲、纹理或采样状态参数表的最大条目数的限制被列在实现限制表中。</p><p>整个线程组内存分配的最大限制也被列在实现限制表中。</p><h3 id="执行计算命令"><a href="#执行计算命令" class="headerlink" title="执行计算命令"></a>执行计算命令</h3><p>编码一个执行计算函数的命令，调用<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>的dispatchThreadgroups:threadsPerThreadgroup:方法并指定线程组尺寸和线程组的数量。你可以查询MTLComputePipelineState的threadExecutionWidth和maxTotalThreadPerThreadgroup属性来优化设备计算函数的执行。</p><p>在线程组中的线程总数是threadsPerThreadgroup: threadsPerThreadgroup.width * threadsPerThreadgroup.height * threadsPerThreadgroup.depth组件的乘积。maxTotalThreadsPerThreadgroup属性指定线程最大数量，它可能是一个单一的线程组去在设备上执行这个计算函数。</p><p>调用<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>方法结束计算命令编码器的编码命令。结束以前命令编码器以后，你可以创建一个任意类型的新的命令编码器来编码额外的命令进入到命令缓冲区。</p><h3 id="代码样例-执行数据并行函数"><a href="#代码样例-执行数据并行函数" class="headerlink" title="代码样例:执行数据并行函数"></a>代码样例:执行数据并行函数</h3><p>清单6-1显示了一个样例，这个样例创建和使用<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>对象来执行一个指定数据图像变换的并行计算。(这个例子未展示设备，库，命令队列和资源对象被创建和初始化。)样例创建一个命令缓冲区，然后使用它来创建<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>对象。接下来<font color="Fuchsia">MTLFunction</font>对象被创建，其表示从<font color="Fuchsia">MTLLibrary</font>对象加载的入口点filter_main，如清单6-2所示。函数对象被用来创建一个被叫做filterState的MTLComputePipelineState对象。</p><p>计算函数在图像inputImage上执行一个图像变换和过滤操作，使用outputImage返回结果。首先<font color="DeepSkyBlue">setTexture:atIndex:</font>和<font color="DeepSkyBlue">setBuffer:offset:atIndex:</font>方法分配纹理和缓冲对象到指定参数表的指数。paramsBuffer指定值用来执行图像变换，inputTableData指定滤镜权重。计算函数被执行作为一个各个尺寸的16×16像素大小的2D线程组。<font color="DeepSkyBlue">dispatchThreadgroups:threadsPerThreadgroup:</font>方法排队命令来调度线程执行计算函数，<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>方法终止<a href="https://developer.apple.com/documentation/metal/mtlcomputecommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLComputeCommandEncoder</font></a>。最终，<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>的<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443003-commit" target="_blank" rel="noopener">commit</a></font>方法引起了尽快地去执行命令。</p><p>清单6-1 在计算状态指定和运行一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">id &lt;MTLDevice&gt; device;</span><br><span class="line">id &lt;MTLLibrary&gt; library;</span><br><span class="line">id &lt;MTLCommandQueue&gt; commandQueue;</span><br><span class="line"> </span><br><span class="line">id &lt;MTLTexture&gt; inputImage;</span><br><span class="line">id &lt;MTLTexture&gt; outputImage;</span><br><span class="line">id &lt;MTLTexture&gt; inputTableData;</span><br><span class="line">id &lt;MTLBuffer&gt; paramsBuffer;</span><br><span class="line"> </span><br><span class="line">// ... Create and initialize device, library, queue, resources</span><br><span class="line"> </span><br><span class="line">// Obtain a new command buffer</span><br><span class="line">id &lt;MTLCommandBuffer&gt; commandBuffer = [commandQueue commandBuffer];</span><br><span class="line"> </span><br><span class="line">// Create a compute command encoder</span><br><span class="line">id &lt;MTLComputeCommandEncoder&gt; computeCE = [commandBuffer computeCommandEncoder];</span><br><span class="line"> </span><br><span class="line">NSError *errors;</span><br><span class="line">id &lt;MTLFunction&gt; func = [library newFunctionWithName:@&quot;filter_main&quot;];</span><br><span class="line">id &lt;MTLComputePipelineState&gt; filterState</span><br><span class="line">              = [device newComputePipelineStateWithFunction:func error:&amp;errors];</span><br><span class="line">[computeCE setComputePipelineState:filterState];</span><br><span class="line">[computeCE setTexture:inputImage atIndex:0];</span><br><span class="line">[computeCE setTexture:outputImage atIndex:1];</span><br><span class="line">[computeCE setTexture:inputTableData atIndex:2];</span><br><span class="line">[computeCE setBuffer:paramsBuffer offset:0 atIndex:0];</span><br><span class="line"> </span><br><span class="line">MTLSize threadsPerGroup = &#123;16, 16, 1&#125;;</span><br><span class="line">MTLSize numThreadgroups = &#123;inputImage.width/threadsPerGroup.width,</span><br><span class="line">                           inputImage.height/threadsPerGroup.height, 1&#125;;</span><br><span class="line"> </span><br><span class="line">[computeCE dispatchThreadgroups:numThreadgroups</span><br><span class="line">                                threadsPerThreadgroup:threadsPerGroup];</span><br><span class="line">[computeCE endEncoding];</span><br><span class="line"> </span><br><span class="line">// Commit the command buffer</span><br><span class="line">[commandBuffer commit];</span><br></pre></td></tr></table></figure><p>清单6-2 显示了前面样例的相应着色器代码。(read_and_transform和filter_table函数是用户定义代码的占位符)。</p><p>清单6-2 着色语言计算函数声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kernel void filter_main(</span><br><span class="line">  texture2d&lt;float,access::read&gt;   inputImage   [[ texture(0) ]],</span><br><span class="line">  texture2d&lt;float,access::write&gt;  outputImage  [[ texture(1) ]],</span><br><span class="line">  uint2 gid                                    [[ thread_position_in_grid ]],</span><br><span class="line">  texture2d&lt;float,access::sample&gt; table        [[ texture(2) ]],</span><br><span class="line">  constant Parameters* params                  [[ buffer(0) ]]</span><br><span class="line">  )</span><br><span class="line">&#123;</span><br><span class="line">  float2 p0          = static_cast&lt;float2&gt;(gid);</span><br><span class="line">  float3x3 transform = params-&gt;transform;</span><br><span class="line">  float4   dims      = params-&gt;dims;</span><br><span class="line">  </span><br><span class="line">  float4 v0 = read_and_transform(inputImage, p0, transform);</span><br><span class="line">  float4 v1 = filter_table(v0,table, dims);</span><br><span class="line">  </span><br><span class="line">  outputImage.write(v1,gid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓冲和纹理操作-位块传送命令编码器"><a href="#缓冲和纹理操作-位块传送命令编码器" class="headerlink" title="缓冲和纹理操作:位块传送命令编码器"></a>缓冲和纹理操作:位块传送命令编码器</h2><p><a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>提供了在资源(缓冲和纹理)之间拷贝数据方法。数据拷贝操作对于图像处理和纹理效果可能是必要的，例如迷糊或反射。他们可能被用来访问被离屏渲染的图像数据。</p><p>执行数据拷贝操作，首先通过调用<a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" target="_blank" rel="noopener"><font color="Fuchsia">MTLCommandBuffer</font></a>对象的<font color="DeepSkyBlue">blitCommandEncoder</font>方法创建一个<a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>对象。然后调用下面描述的编码指定到命令缓冲区的<a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>的方法。</p><h3 id="在资源对象之间的GPU内存拷贝数据"><a href="#在资源对象之间的GPU内存拷贝数据" class="headerlink" title="在资源对象之间的GPU内存拷贝数据"></a>在资源对象之间的GPU内存拷贝数据</h3><p>下列<a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>方法在资源对象之间拷贝图像数据:两个缓冲对象之间，两个纹理对象之间，一个缓冲和一个纹理之间。</p><h4 id="两个缓冲之间的拷贝数据"><a href="#两个缓冲之间的拷贝数据" class="headerlink" title="两个缓冲之间的拷贝数据"></a>两个缓冲之间的拷贝数据</h4><p><font color="DeepSkyBlue">copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:</font>方法在两个缓冲之间拷贝数据:从源缓冲到目标缓冲toBuffer。如果源和目标是相同的缓冲，被拷贝重叠的范围，结果是未定义的。</p><h4 id="缓冲到纹理的拷贝数据"><a href="#缓冲到纹理的拷贝数据" class="headerlink" title="缓冲到纹理的拷贝数据"></a>缓冲到纹理的拷贝数据</h4><p><font color="DeepSkyBlue">copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:</font>方法从源缓冲到目标纹理toTexture拷贝图像数据。</p><h4 id="两个纹理之间的拷贝数据"><a href="#两个纹理之间的拷贝数据" class="headerlink" title="两个纹理之间的拷贝数据"></a>两个纹理之间的拷贝数据</h4><p><font color="DeepSkyBlue">copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:</font>方法拷贝两个纹理图像数据范围:从单一立方体切片和源纹理映射级别到纹理终点toTexture。</p><h4 id="纹理到缓冲的数据拷贝"><a href="#纹理到缓冲的数据拷贝" class="headerlink" title="纹理到缓冲的数据拷贝"></a>纹理到缓冲的数据拷贝</h4><p><font color="DeepSkyBlue">copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:</font>方法拷贝图像数据范围从单一立方体切片和源纹理映射级别到缓冲终点toBuffer。</p><h3 id="产生纹理映射"><a href="#产生纹理映射" class="headerlink" title="产生纹理映射"></a>产生纹理映射</h3><p><a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>的generateMipmapsForTexture:方法对于给定纹理自动产生纹理映射，从基本层次纹理图像开始。<font color="DeepSkyBlue">generateMipmapsForTexture:</font>创建所有纹理映射级别到达最高级别的缩放图像。</p><h3 id="填充缓冲内容"><a href="#填充缓冲内容" class="headerlink" title="填充缓冲内容"></a>填充缓冲内容</h3><p><a href="https://developer.apple.com/documentation/metal/mtlblitcommandencoder" target="_blank" rel="noopener"><font color="Fuchsia">MTLBlitCommandEncoder</font></a>的<font color="DeepSkyBlue">fillBuffer:range:value:</font>方法在给定缓冲指定的range上每个字节存储8位常量。</p><h3 id="结束位块传送命令编码器"><a href="#结束位块传送命令编码器" class="headerlink" title="结束位块传送命令编码器"></a>结束位块传送命令编码器</h3><p>调用<font color="DeepSkyBlue"><a href="https://developer.apple.com/documentation/metal/mtlcommandencoder/1458038-endencoding" target="_blank" rel="noopener">endEncoding</a></font>来结束位块传送命令编码器的命令编码。在结束前一个命令编码器后，你可以创建一个任意类型的新的命令编码器来编码额外命令进入命令缓冲区。</p><h2 id="Metal工具"><a href="#Metal工具" class="headerlink" title="Metal工具"></a>Metal工具</h2><p>这章列出了可用的工具来帮助你自定义和改善你开发的工作流。</p><h3 id="在应用构建过程期间创建库"><a href="#在应用构建过程期间创建库" class="headerlink" title="在应用构建过程期间创建库"></a>在应用构建过程期间创建库</h3><p>在应用构建过程期间编译着色语言源文件和构建库(.metallib文件)比运行时编译着色器源码能实现更好的应用性能。你可以用Xcode构建一个库或者通过使用命令行工具。</p><h4 id="使用Xcode构建一个库"><a href="#使用Xcode构建一个库" class="headerlink" title="使用Xcode构建一个库"></a>使用Xcode构建一个库</h4><p>任何在你工程中的着色器源文件自动被使用去产生默认的库，你可以用<a href="https://developer.apple.com/documentation/metal/mtldevice" target="_blank" rel="noopener"><font color="Fuchsia">MTLDevice</font></a>的<font color="DeepSkyBlue">newDefaultLibrary</font>方法从Metal框架代码存取。</p><h4 id="使用命令行工具去构建一个库"><a href="#使用命令行工具去构建一个库" class="headerlink" title="使用命令行工具去构建一个库"></a>使用命令行工具去构建一个库</h4><p>图表8-1展示了产生Metal着色器源码编译器工具链的命令行工具。当你工程中包含.metal文件时，Xcode调用这些工具来构建一个库文件，这个文件你可以在应用运行时存取。</p><p>不使用Xcode编译着色器源码进入一个库:</p><ol><li>使用metal工具来编译每个.metal文件进入单独的.air文件，它存储了着色语言代码的中间表示(IR)。</li><li>可选择地，使用metal-ar工具来把若干个.air文件归档到一起成为一个.metalar文件。(metal-ar和Unix ar类似。)</li><li>使用metallib工具来构建一个Metal的.metallib库文件从IR .air文件或从归档的.metalar文件。</li></ol><p>图表 8-1 使用命令行工具构建一个库文件</p><p><img src="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/library_2x.png" alt="img-w600"></p><p>清单8-1 展示了编译和构建一个.metal文件成为一个.metallib文件需要的最少命令行。</p><p>清单8-1 用命令行工具构建一个库文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk macosx metal MyLibrary.metal -o MyLibrary.air</span><br><span class="line">xcrun -sdk macosx metallib MyLibrary.air -o MyLibrary.metallib</span><br></pre></td></tr></table></figure><p>在框架代码中使用结果库，调用<font color="DeepSkyBlue">newLibraryWithFile:error:</font>方法，如清单8-2所示。</p><p>清单8-2 在你的应用中使用一个库文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSError *libraryError = NULL;</span><br><span class="line">NSString *libraryFile = [[NSBundle mainBundle] pathForResource:@&quot;MyLibrary&quot; ofType:@&quot;metallib&quot;];</span><br><span class="line">id &lt;&lt;font color=Fuchsia&gt;MTLLibrary&lt;/font&gt;&gt; myLibrary = [_device newLibraryWithFile:libraryFile error:&amp;libraryError];</span><br><span class="line">if (!myLibrary) &#123;</span><br><span class="line">    NSLog(@&quot;Library error: %@&quot;, libraryError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;[Metal基础概念] 简明的描述Metal的主要特性。&lt;/li&gt;
&lt;li&gt;[命令组成和执行模型] 解释如何创建和提交命令到GPU执行。&lt;/li&gt;
&lt;li&gt;[资源对象:缓冲和纹理] 讨论设备内存管理，包括表现GPU内存分配的缓冲和纹理对象。&lt;/li&gt;
&lt;li&gt;[函数和库] 描述Metal着色语言代码如何被呈现在一个Metal应用中，Metal着色语言代码在GPU上如何被加载和执行的。&lt;/li&gt;
&lt;li&gt;[图像渲染:渲染命令编码器] 描述如何渲染3D图像，包括如何穿过多个线程来分配图形操作。&lt;/li&gt;
&lt;li&gt;[数据并行计算处理:计算命令编码器] 阐述如何执行数据并行处理。&lt;/li&gt;
&lt;li&gt;[缓冲和纹理操作:位命令编码器] 描述如何在纹理和缓冲之间拷贝数据。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Metal" scheme="https://zhaolilong.com/tags/Metal/"/>
    
      <category term="图形学" scheme="https://zhaolilong.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>理解ARKit</title>
    <link href="https://zhaolilong.com/2018/06/03/%E7%90%86%E8%A7%A3ARKit/"/>
    <id>https://zhaolilong.com/2018/06/03/理解ARKit/</id>
    <published>2018-06-03T05:46:41.000Z</published>
    <updated>2020-03-10T01:56:09.669Z</updated>
    
    <content type="html"><![CDATA[<p>近些年最流行的手游之一是Pokemon Go(精灵宝可梦Go), 它展示通过iPhone相机查看覆盖在真实地点的宝可梦角色。将iPhone摄像头对准公园长椅或灌木丛，你可以看到一个宝可梦卡通角色，好像它真的在那。</p><p>这种在实际物理对象上显示虚拟对象的技术被称为增强现实（AR）。增强现实背后的想法是让您将真实世界的物体与出现在iPhone屏幕上的虚拟物体相结合。</p><a id="more"></a><p>增强现实的一个用途是将iPhone指向街道，以便您可以看到周边地区的街道名称和企业名称。另一个用途是向您展示带箭头的步行路线，向您展示如何在大型公共场所（如机场航站楼或博物馆）进行导航。</p><p>以前，创建增强现实应用需要编写数学方程式来跟踪真实世界物体和虚拟物体在真实世界中的位置。幸运地，苹果已经通过一个新的叫做ARKit的软件框架使得增强现实更简单地去创建。通过使用ARKit和其他框架，例如SceneKit，你可以简单快捷地创建增强现实应用。</p><blockquote><p><strong>注意</strong> 你仅可以测试和运行ARKit应用在iPhone6s或者更高，或者一台iPad Pro上。</p></blockquote><h2 id="ARKit如何工作"><a href="#ARKit如何工作" class="headerlink" title="ARKit如何工作"></a>ARKit如何工作</h2><p>在最简单的层面上，ARKit通过识别称为特征点的周围区域来工作。一旦ARKit了解iOS设备摄像头查看的物理对象，它就可以将虚拟对象叠加在摄像头显示的实际图像的顶部。</p><p>查看实例中的ARKit示例，创建一个新的iOS项目。但是，请确保您单击了增强现实应用程序项目，如图1所示。然后点击下一步。</p><p><img src="https://i.loli.net/2018/06/10/5b1cc34f55d74.jpg" alt=""></p><p><strong>图 1</strong> 增强现实应用模板</p><p>当Xcode对于你的项目要求一个产品名称，输入ARTest。确保Content Technology弹出菜单显示SceneKit。（Content Technology的其他两个选项是Metal和SpriteKit。SpriteKit为2D图像而设计，然而Metal专为喜欢创建自己的代码来创建图形的高级用户而设计。在大多数情况下，你将使用SceneKit来显示3D图像。）</p><p>当你点击Finish按钮时，Xcode创建了一个标准的iOS项目，它包含一个AppDelegate.swift文件，一个ViewController.swift文件，和一个Main.storyboard用户界面文件。</p><p>点击ViewController.swift文件，你将看到已经为你编写好创建增强现实应用的代码。注意ViewController.swift包含三个重要的语句：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br></pre></td></tr></table></figure><p>UIKit创建一个iOS应用。使用SceneKit可以显示三维物体。ARKit可让您将增强现实添加到您的应用中。</p><p>接下来，注意ViewController累采用ARSCNViewDelegate：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>该协议允许您将SceneKit图像显示为覆盖真实世界对象的增强现实对象。然后，注意ViewController.swift文件已经包含一个单独的名为sceneView的IBOutlet：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">var</span> sceneView : <span class="type">ARSCNView</span></span><br></pre></td></tr></table></figure><p>如果你点击了Main.storyboard文件，你会看到一个ARKit SceneKit View已经在用户界面中，如图2所示。此ARSCNView在相机背景上显示3D SceneKit图像。</p><p><img src="https://i.loli.net/2018/06/10/5b1cc84dc3ca5.jpg" alt=""></p><p><strong>图 2</strong> 一个ARKit SceneKit View已经出现在用户界面上</p><p>在ViewController.swift文件中，请查看viewWillAppear函数，您将看到两行代码可帮助在应用程序中创建增强现实。第一行代码创建了一个叫做configuration的常量，它代表一个ARWorldTrackingConfiguration对象。该对象跟踪iOS设备的方向和位置，以及检测真实世界的表面。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingConfiguration</span>()</span><br></pre></td></tr></table></figure><p>第二行实际显示叠加在相机显示的视图上的增强现实图像：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneView.session.run(configuration)</span><br></pre></td></tr></table></figure><p>现在来看ViewController.swift文件中的viewDidLoad方法。首先，在ViewController.swift文件中有一行定义了其delegate（代理）。其次，有一行显示了在屏幕底部的每秒帧数（fps）和时间数据。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneView.showStatistics = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果你看Navigator面板，你将会看到art.scnassets文件夹。如果你展开这个文件夹，你将会看到它包含了两个文件：ship.scn和texture.png。ship.scn文件包含了一个三维的对象，你可以通过修改来改变其外观。texture。png文件包含了出现在ship.scn模型中的图像，如图3.</p><p><img src="https://i.loli.net/2018/06/10/5b1ccb2f458d4.jpg" alt=""></p><p><strong>图 3</strong> 查看Xcode中的ship.scn文件</p><blockquote><p><strong>注意</strong> .scn文件代表了一个SceneKit文件格式。大多数3D数字图像程序可以保存文件为一个.dae（数字资产交换）文件格式。如果你添加一个.dae文件到Xcode中，你可以转换它成为一个.scn文件格式，通过添加一个.dae文件到Navigator面板，然后选择File ➤ Export，保存文件为一个.scn文件。如果你想创建.dae文件，你可以使用免费，开源的Blender程序（<a href="">www.blender.org</a>）。你也同样可以在互联网上找到免费的公共域的.dae文件。</p></blockquote><p>虚拟对象由一个模型（在这种情况下，ship.scn文件）和一个纹理（texture.png）组成，并应用于该模型。如果你点击texture.png文件，你将看到出现在ship.scn文件中的颜色和图像。</p><p>点击ship.scn文件，点击Xcode窗口中的飞机图像。点击Show the Materials Inspector图标（或者选择View ➤ Utilities ➤ Show the Materials Inspector)。这将显示“材质检查器”窗格，该窗格允许您修改模型的外观。</p><p>在Properties中点击Diffuse弹出菜单，你可以看到texture.png被选择如果4所示。点击黑或者白来移除纹理，以便于你可以看到如何从模型中移除texture.png文件来改变ship.scn文件的外观。</p><p><img src="https://i.loli.net/2018/06/10/5b1cce952bed5.jpg" alt=""></p><p><strong>图 4</strong> “漫反射“弹出菜单定义ship.scn文件的外观</p><p>确保Diffuse弹出菜单再次先吃了texture.png.通过USB线连接一台iOS设备到你的Mac电脑并将您的iOS设备相机指向任何地方。ship.scn文件的虚拟镜像现在应该出现在摄像机查看的真实世界对象上，如图5所示。</p><p><img src="https://i.loli.net/2018/06/10/5b1d081d2fb1b.jpg" alt=""></p><p><strong>图5</strong> 在iPhone上运行ARTest项目</p><p>当你四处移动iOS设备时，你应当看到了ship.scn的不同角度图像好像它是你面前的一个真实物体一样。注意屏幕底部显示的关于增强显示图像的统计，比如它的帧率（fps）。</p><p>回到Xcode，选择Product ➤ Stop或者点击停止图标来停止运行中的ARTest项目。在此刻，你已经看到了增强现实如何工作的一个简单的演示。通过添加不同纹理文件或者使用不同的图片替换ship.scn文件，你可以显示通过iOS设备摄像头看到的自定义图像。</p><p>返回并且编辑ViewController.swift文件。首先，注释掉定义ship.scn文件的两行，然后加载该场景：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let scene = SCNScene(named: "art.scnassets/ship.scn")!</span></span><br><span class="line"><span class="comment">// sceneView.scene = scene</span></span><br></pre></td></tr></table></figure><p>现在添加下面的行来显示覆盖在相机图像上的特征点和世界原点：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneView.debugOptions = [<span class="type">ARSCNDebugOpitions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br></pre></td></tr></table></figure><p>特征点显示为突出显示ARKit识别的表面区域的黄色点。世界原点显示为x轴，y轴，z轴，其中x轴向右，y轴向上，并且z轴指向用户的屏幕外。</p><blockquote><p><strong>注意</strong> ARKit在清晰的照明条件下工作得最好，多个物体可见，因此它可以检测桌子，地板和墙壁的表面区域。较差的照明条件会阻碍ARKit识别表面区域并将摄像机指向空白墙壁或地板的能力。</p></blockquote><p>你的整个viewDidLoad方法应该看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置视图的代理</span></span><br><span class="line">    sceneView.<span class="type">Delegate</span> = <span class="keyword">self</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示统计例如fps和时间信息</span></span><br><span class="line">    sceneView.showStatistics = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个新的场景</span></span><br><span class="line">    <span class="comment">// let scene = SCNScene(named:"art.scnassets/ship.scn")!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置视图的场景</span></span><br><span class="line">    <span class="comment">// sceneView.scene = scen</span></span><br><span class="line">    </span><br><span class="line">    sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你运行这个ARTest项目的修改版本时，你将在附近区域看到原点显示以及黄点，表示特征点，如图6所示。</p><p><img src="https://i.loli.net/2018/06/10/5b1d0c2c95bcb.jpg" alt=""></p><p><strong>图 6</strong> debugOptions行显示原点和特征点</p><h2 id="绘制增强现实物体"><a href="#绘制增强现实物体" class="headerlink" title="绘制增强现实物体"></a>绘制增强现实物体</h2><p>通过用你自己的图像替换ship.scn文件，你可以显示任何你想作为一个增强现实的物体。然而，你也可以现实简单的几何体。一些你可以绘制的可用模型包括：</p><ul><li>SCNBox - 绘制一个盒子</li><li>SCNCapsule - 绘制一个圆柱体，其两端用半球盖住</li><li>SCNCone - 绘制一个圆锥体</li><li>SCNCylinder - 绘制一个圆柱体</li><li>SCNFloor - 绘制一个可以选择反映场景的无限平面</li><li>SCNPlane - 绘制一个指定宽高的矩形平面</li><li>SCNPyramid - 绘制一个角锥体</li><li>SCNSphere - 绘制一个球体</li><li>SCNTorus - 绘制一个圆环状的物体</li><li>SCNTube - 沿其中心轴绘制一个带有孔的圆柱体<br>显示几何模型时，您需要定义三个特征：</li><li>物体的物理尺寸例如宽高</li><li>物体的外观例如颜色</li><li>物体相对于世界原点的位置</li></ul><p>一旦你定义一个物体的大小，外观，和位置，您需要将其放置在相机显示的视图上。为了做到这点，你需要去定义一个节点。要查看它是如何工作的，我们需要将以下代码添加到ViewController.swift文件中现有的viewDidLoad函数中：</p><p>在sceneView.debugOptions行的下面，添加以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">node.geometry = <span class="type">SCNPyramid</span>(width: <span class="number">0.1</span>, height: <span class="number">0.2</span>, length: <span class="number">0.1</span>)</span><br><span class="line">node.geometry?.firstMaterial?.diffuse.contents = <span class="type">UIColor</span>.cyan</span><br><span class="line">node.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, -<span class="number">0.2</span>, <span class="number">0</span>)</span><br><span class="line">sceneView.scene.rootNode.addChildNode(node)</span><br></pre></td></tr></table></figure><p>第一行创建一个节点，它定义几何模型将会出现在哪里。<br>第二行定义了一个有宽，高和长的角锥体。<br>第三行定义了模型的颜色，它是青色。<br>第四行定义了角锥体相对于世界原点的位置。在这种情况下，金字塔底部出现在原点下面-0.2处。<br>第五行将节点添加到场景中，以便青色金字塔直接出现在世界原点的下方如图7所示。</p><p><img src="https://i.loli.net/2018/06/10/5b1d10f979470.jpg" alt=""></p><p><strong>图7</strong> 显示一个角锥体作为增强现实物体</p><p>通过更改node.position的值以及角锥体的宽度，高度和长度来进行实验。还要将其颜色从青色更改为红色或黄色。选择不同的模型，如SCNBox，SCNTub或SCNCone，而不是显示角锥体，</p><h2 id="重置世界原点"><a href="#重置世界原点" class="headerlink" title="重置世界原点"></a>重置世界原点</h2><p>我们创建ARTest项目使用增强现实应用模板，但是我们可以通过添加ARKit和SceneKit框架轻松地为任何项目提供增强现实功能。创建一个新的项目并创建一个新的单视图应用。给它一个ARRest的名字。</p><p>当你第一次运行任何AR应用时，它会在您的iPhone或iPad的当前位置定义世界原点。如果稍后退出，您会看到屏幕上显示的原点（请参见图6）。不幸地，世界原点将仍然固定直到你再次运行应用。</p><p>为了修复这个问题，你将创建的下一个项目将显示一个重置按钮，该按钮可让你将iPhone / iPad移动到新位置并在新位置重新定义原点。这样，你可以重新定义世界原点位置，而无需重新启动应用程序。</p><p>点击ViewController.swift文件并添加SceneKit和ARKit框架像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br></pre></td></tr></table></figure><p>像这样采用ARSCNViewDelegate修改ViewController类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>点击Info.plist文件并添加一个Privacy – Camera Usage Description的键。如果你没有做到这一点，您的应用将无法访问相机，并且无法运行。</p><p>点击Main.storyboard文件并添加一个ARKit SceneKit View到用户界面如图8所示。</p><p><img src="https://i.loli.net/2018/06/10/5b1d3ef4a9b00.jpg" alt=""></p><p><strong>图 8</strong> ARKit SceneKit View现实增强现实物体</p><p>将UIButton拖放到ARKit SceneKit下面的屏幕底部查看以便延伸视图的宽度。给这个按钮一个“复位”的标题，如图9所示。然后选择Editor ➤ Resolve Auto Layout Issue ➤ Reset to Suggested Constraints。</p><p><img src="https://i.loli.net/2018/06/10/5b1d3faa7c584.jpg" alt=""></p><p><strong>图 9</strong> 在用户界面上放置一个UIButton</p><p>打开Assistant Editor并按住Control从ARSCNView拖拽到创建的名为sceneView的IBOutlet:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">var</span> sceneView : <span class="type">ARSCNView</span>!</span><br></pre></td></tr></table></figure><p>现在，从UIButton拖动Control来创建一个名为resetAR的IBAction方法，并添加如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">resetAR</span><span class="params">(<span class="number">_</span> sender : UIButton)</span></span> &#123;</span><br><span class="line">    sceneView.session.pause()</span><br><span class="line">    sceneView.session.run(configuration, options : [.resetTracking, .removeExistingAnchors])</span><br></pre></td></tr></table></figure><p>整个ViewController.swift文件应当看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> sceneView: <span class="type">ARSCNView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个session配置</span></span><br><span class="line">    <span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingConfiguration</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        sceneView.delegate = <span class="keyword">self</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 显示统计例如fps和时间信息</span></span><br><span class="line">        sceneView.showsStatistics = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 显示原点和特征点</span></span><br><span class="line">        sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//运行视图的会话</span></span><br><span class="line">        sceneView.session.run(configuration)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillDisappear(animated)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 暂停视图的会话</span></span><br><span class="line">        sceneView.session.pause()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">resetAR</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">        sceneView.session.pause()</span><br><span class="line">        sceneView.session.run(configuration, options: [.resetTracking, .removeExistingAnchors])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你运行这个应用时，稍后退一步，你会看到世界的起源显示在你面前。移至新位置并点击重置按钮，然后向后退出。 您现在应该看到在新位置定义的世界原点。</p><h2 id="绘制自定义模型"><a href="#绘制自定义模型" class="headerlink" title="绘制自定义模型"></a>绘制自定义模型</h2><p>ARKit提供了可以创建的常见几何模型，例如圆柱体，锥体，金字塔，盒子和球体。如果这些几何模型都不符合您的需求，您可以通过定义一个起点并添加线条来创建一个模型来绘制自己的图形。绘制线来定义模型创建了所谓的贝塞尔路径。</p><p>创建贝塞尔路径的四个主要步骤包括：</p><ul><li>定义贝塞尔路径</li><li>定义绘制起点</li><li>绘制一条或多条线</li><li>根据您定义的Bezier路径定义SCNShape</li></ul><p>为了创建一个贝塞尔路径，你需要定义一个BezierPath对象像这样:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">UIBezierPath</span>()</span><br></pre></td></tr></table></figure><p>一旦你已经创建了一个贝塞尔路径，你需要定义它的起点像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>现在我们需要绘制一条或者多条线使用addLine方法，它定义了终点像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">0.2</span>, y: <span class="number">0.2</span>))</span><br></pre></td></tr></table></figure><p>最终我们需要将贝塞尔曲线变成一个图形：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shape = <span class="type">SCNShape</span>(path: path, extrusionDepth: <span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><p>一旦我们有一个图形，我们可以显示它作为一个增强现实物体，通过定义它作为一个带有颜色和位置的节点。然后我们可以最终添加节点到增强现实视图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">node.geometry = shape</span><br><span class="line">node.geometry?.firstMaterial?.diffuse.contents = <span class="type">UIColor</span>.yellow</span><br><span class="line">node.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">0.4</span>)</span><br><span class="line">sceneView.scene.rootNode.addChildNode(node)</span><br></pre></td></tr></table></figure><p>在你的ARReset项目中修改ViewController.swift文件，它的全部内容看起来像下面这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> sceneView: <span class="type">ARSCNView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个会话配置</span></span><br><span class="line">    <span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingConfiguration</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        sceneView.delegate = <span class="keyword">self</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 显示统计例如帧率和时间信息</span></span><br><span class="line">        sceneView.showStatistics = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 显示原点和特征点</span></span><br><span class="line">        sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>()</span><br><span class="line">        path.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>))</span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">0.2</span>, y: <span class="number">0.2</span>))</span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">0.4</span>, y: -<span class="number">0.2</span>))</span><br><span class="line">        <span class="keyword">let</span> shape = <span class="type">SCNShape</span>(path: path, extrusionDepth: <span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">        node.geometry = shape</span><br><span class="line">        node.geometry?.firstMaterial?.diffuse.contents = <span class="type">UIColor</span>.yellow</span><br><span class="line">        node.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">0.4</span>)</span><br><span class="line">        sceneView.scene.rootNode.addChildNode(node)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 运行视图的会话</span></span><br><span class="line">        sceneView.session.run(configuration)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillDisappear(animated)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 暂停视图会话</span></span><br><span class="line">        sceneView.session.pause()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// 处置任何可以重新创建的资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">resetAR</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">        sceneView.session.pause()</span><br><span class="line">        sceneView.session.run(configuration, options: [.resetTracking, .removeExistingAnchors])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你运行这个修改过的ARReset项目在连接到你的Mac的一台iOS设备上，你应当看到一个黄色的三角形超过了世界原点如图10所示。</p><p><img src="https://i.loli.net/2018/06/13/5b2056ffc51ad.jpg" alt=""></p><p><strong>图 10</strong> 使用贝塞尔曲线绘制一个自定义图形</p><h2 id="修改模型外观"><a href="#修改模型外观" class="headerlink" title="修改模型外观"></a>修改模型外观</h2><p>到现在为止，我们仅仅创建了一个图形和应用颜色到它上面，但是有其他方式修改模型的外观。修改一个模型的外观一些方式包括改变光照，透明度，或者文理。光照使得模型看起来不同，这取决于光照的类型和光源的位置。透明度定义了模型是否显示为实心或透明。纹理在模型的两侧应用图形图像，例如使模型看起来像用砖块或沙子制成。通过修改模型的外观，可以使该模型在视觉上更有趣。</p><p>要试验修改模型的外观，请创建一个新的增强现实应用项目并将其命名为ARAppearance。确保Content Technology使用SceneKit。我们要修改对象外观的第一种方法是使用显示在该模型上的图形图像。</p><p>在互联网上搜索“公共领域纹理图像”，你会发现许多图像，你可以自由下载和使用。纹理图像通常显示一个规则图案，如砖，水，田地，或如图11所示的材料，如木头或石头。</p><p><img src="https://i.loli.net/2018/06/14/5b21aa8771c7f.jpg" alt=""></p><p><strong>图 11</strong> 搜索公共领域的纹理图像</p><p>下载一个纹理图片并确保他被存储为png或者jpg文件格式。然后拖拽它到Navigator面板如图12所示。</p><p><img src="https://i.loli.net/2018/06/14/5b21aabac5519.jpg" alt=""></p><p><strong>图 12</strong> 放置一张文理图片文件在Navigator面板</p><p>修改ViewController.swift文件显示如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">import</span> ARKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">ARSCNViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> sceneView: <span class="type">ARSCNView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Set the view's delegate</span></span><br><span class="line">        sceneView.delegate = <span class="keyword">self</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Show statistics such as fps and timing information</span></span><br><span class="line">        sceneView.showsStatistics = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> box = <span class="type">SCNBox</span>(width: <span class="number">0.1</span>, height: <span class="number">0.1</span>, length: <span class="number">0.2</span>, chamferRadius: <span class="number">0.01</span>);</span><br><span class="line">        <span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">        <span class="keyword">let</span> material = <span class="type">SCNMaterial</span>()</span><br><span class="line">        material.diffuse.contents = <span class="type">UIImage</span>(named: <span class="string">"stone.jpg"</span>)</span><br><span class="line">        box.materials = [material]</span><br><span class="line">        </span><br><span class="line">        node.geometry = box</span><br><span class="line">        node.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">0.3</span>)</span><br><span class="line">        </span><br><span class="line">        sceneView.scene.rootNode.addChildNode(node)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Create a new scene</span></span><br><span class="line">        <span class="keyword">let</span> scene = <span class="type">SCNScene</span>(named: <span class="string">"art.scnassets/ship.scn"</span>)!</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Set the scene to the view</span></span><br><span class="line">        sceneView.scene = scene</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Create a session configuration</span></span><br><span class="line">        <span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingConfiguration</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the view's session</span></span><br><span class="line">        sceneView.session.run(configuration)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillDisappear(animated)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Pause the view's session</span></span><br><span class="line">        sceneView.session.pause()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Release any cached data, images, etc that aren't in use.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - ARSCNViewDelegate</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // Override to create and configure nodes for anchors added to the view's session.</span></span><br><span class="line"><span class="comment">    func renderer(_ renderer: SCNSceneRenderer, nodeFor anchor: ARAnchor) -&gt; SCNNode? &#123;</span></span><br><span class="line"><span class="comment">        let node = SCNNode()</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">        return node</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: ARSession, didFailWithError error: Error)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Present an error message to the user</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sessionWasInterrupted</span><span class="params">(<span class="number">_</span> session: ARSession)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Inform the user that the session has been interrupted, for example, by presenting an overlay</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sessionInterruptionEnded</span><span class="params">(<span class="number">_</span> session: ARSession)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Reset tracking and/or remove existing anchors if consistent tracking is required</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这份代码定义了一个SCNBox的几何模型，同时也定义了一个SCNMaterial的数组。那是因为一个模型可以有多个材质。然后代码定义了图形文件叫做”stone.jpg”作为它的第一材质，创建一个石头图像在模型周围如图13所示：</p><p><img src="https://i.loli.net/2018/06/14/5b21b9b7477dc.jpg" alt=""></p><p><strong>图 13</strong> 一块石头图像以包围盒子模型的材料形式出现</p><p>另外一种修改模型外观的方式是改变它的透明度，使用一个0（不可见）到1（纯色）。添加一行代码来定义一个透明度值，所以你整个viewDidLoad方法看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Set the view's delegate</span></span><br><span class="line">    sceneView.delegate = <span class="keyword">self</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Show statistics such as fps and timing information</span></span><br><span class="line">    sceneView.showsStatistics = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> box = <span class="type">SCNBox</span>(width: <span class="number">0.1</span>, height: <span class="number">0.1</span>, length: <span class="number">0.2</span>, chamferRadius: <span class="number">0.01</span>);</span><br><span class="line">    <span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">    <span class="keyword">let</span> material = <span class="type">SCNMaterial</span>()</span><br><span class="line">    material.diffuse.contents = <span class="type">UIImage</span>(named: <span class="string">"stone.jpg"</span>)</span><br><span class="line">    material.transparency = <span class="number">0.7</span></span><br><span class="line">    box.materials = [material]</span><br><span class="line">    </span><br><span class="line">    node.geometry = box</span><br><span class="line">    node.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">0.3</span>)</span><br><span class="line">    </span><br><span class="line">    sceneView.scene.rootNode.addChildNode(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>上面的代码用材质数组定义了两个特性。首先，它显示了“stone.jpg”图像在盒子周围。其次，它定义了一个0.7的透明度，所以盒子如果14所示出现半透明。![](https://i.loli.net/2018/06/14/5b21b9b7477dc.jpg)</code></pre><p><strong>图 14</strong> 改变透明度使得图形看起来减少纯色</p><p>另外应用纹理和定义一个透明度层次，另外一种去改变模型外观的方式是通过光照。光照让你创建一个光源，它照亮附近的模型。依赖你选择的光照和光照位置，你可以在一个图形上创建不同类型可视效果。</p><p>创建一个光源，你需要做以下这些：</p><ul><li>定义一个SCNLight对象</li><li>定义SCNLight类型</li><li>分配SCNLight对象到一个SCNNode上</li><li>定义SCNNode位置</li><li>添加SCNNode到场景</li></ul><p>定义一个SCNLight对象，你只需要像这样创建一个常量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spotLight = <span class="type">SCNLight</span>()</span><br></pre></td></tr></table></figure><p>现在定义下列光照类型中的一个：</p><ul><li>ambient</li><li>directional</li><li>IES</li><li>probe</li><li>spot</li></ul><p>每种光照类型以不同的方式突出模型，所以让我们通过直射光类型来开始实验：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spotLight.type = .directional</span><br></pre></td></tr></table></figure><p>既然你已经定义了一个光照类型，你需要像这样创建一个SCNNode：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spotNode = <span class="type">SCNNode</span>()</span><br><span class="line">spotNode.light = spotLight</span><br></pre></td></tr></table></figure><p>第一行创建一个SCNNode对象，第二行定义了它的光源作为一个聚光灯（SCNLight）我们前面创建的对象。</p><p>最终，我们可以防止一个SNNode对象基于世界原点。那意味着你需要定义一个X，Y和Z值像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spotNode.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上述代码放置光源在原点上面0.2米的位置，所以光照耀下来在我们将要创建的盒子上。</p><p>最后一步是添加这个光源节点到增强现实场景上：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneView.scene.rootNode.addChildNode(spotNode)</span><br></pre></td></tr></table></figure><p>整个viewDidLoad函数应该看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Set the view's delegate</span></span><br><span class="line">    sceneView.delegate = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Show statistics such as fps and timing information</span></span><br><span class="line">    sceneView.showStatistics = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    sceneView.debugOptions = [<span class="type">ARSCNDebugOptions</span>.showWorldOrigin, <span class="type">ARSCNDebugOptions</span>.showFeaturePoints]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> box = <span class="type">SCNBox</span>(width: <span class="number">0.1</span>, height: <span class="number">0.1</span>, length: <span class="number">0.1</span>, chamferRadius: <span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">    <span class="keyword">let</span> material = <span class="type">SCNMaterial</span>()</span><br><span class="line">    <span class="comment">// material.diffuse.contents = UIImage(named: "stone.jpg")</span></span><br><span class="line">    <span class="comment">// material.transparency = 0.7</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> spotLight = <span class="type">SCNLight</span>()</span><br><span class="line">    spotLight.type = .directional</span><br><span class="line">    <span class="keyword">let</span> spotNode = <span class="type">SCNNode</span>()</span><br><span class="line">    spotNode.light = spotLight</span><br><span class="line">    spotNode.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    material.diffuse.contents = <span class="type">UIColor</span>.orange</span><br><span class="line">    box.materials = [material]</span><br><span class="line">    </span><br><span class="line">    node.geometry = box</span><br><span class="line">    node.position = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">0.3</span>)</span><br><span class="line">    </span><br><span class="line">    sceneView.scene.rootNode.addChildNode(node)</span><br><span class="line">    sceneView.scene.rootNode.addChildNode(spotNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你运行这个项目，它将创建一个橙色的盒子放置在原点后面0.3米的地方。然后光源将出现在原点上面0.2米的地方照耀下来到这个橙色的盒子上。因为光照类型是directional，它仅仅照亮了盒子的表面如果15所示。</p><pre><code>![](https://i.loli.net/2018/06/14/5b21b9b7477dc.jpg)</code></pre><p><strong>图 15</strong> 定向光聚焦在橙色盒子前面</p><p>查看不同类型光如何改变模型外观，改变光源类型从directional到omni像这样：<br>// spotLight.type = .directional // 只照亮盒子前面<br>spotLight.type = .omni //照亮盒子的顶部和前面</p><p>现在如果你运行这个项目，omni光照类型照亮盒子的前面和顶部如果16所示：</p><pre><code>![](https://i.loli.net/2018/06/14/5b21b9b7477dc.jpg)</code></pre><p><strong>图 16</strong> omni光照类型照亮橙色盒子前面和顶部</p><p>苹果的文档定义了不同光照类型应有的表现，所以用改变光照类型和光源位置来实验。通过改变光源位置，你可以照亮模型的不同区域。通过简单的改变光照类型，你可以用不同的方式照亮一个物体如图17所示。</p><pre><code>![](https://i.loli.net/2018/06/14/5b21b9b7477dc.jpg)</code></pre><p><strong>图 16</strong> 不同光照类型在照亮模型上起不同的作用</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这个章节，你已经学习了使用ARKit创建增强现实物体的基础。你已经学会了如果放置一个增强现实物体在一个场景和如何改变一个物体外观，通过改变它们的颜色，透明度和纹理。另外，你也学习了如何绘制你自己的物体和使用一个光源照亮一个物体。</p><p>增强现实给予你的应用在一个真实场景中覆盖真实物体的能力。在下一章中，你将学习如何用增强现实对象去交互，以便于你可以控制和操作他们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近些年最流行的手游之一是Pokemon Go(精灵宝可梦Go), 它展示通过iPhone相机查看覆盖在真实地点的宝可梦角色。将iPhone摄像头对准公园长椅或灌木丛，你可以看到一个宝可梦卡通角色，好像它真的在那。&lt;/p&gt;
&lt;p&gt;这种在实际物理对象上显示虚拟对象的技术被称为增强现实（AR）。增强现实背后的想法是让您将真实世界的物体与出现在iPhone屏幕上的虚拟物体相结合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AR" scheme="https://zhaolilong.com/tags/AR/"/>
    
      <category term="增强现实" scheme="https://zhaolilong.com/tags/%E5%A2%9E%E5%BC%BA%E7%8E%B0%E5%AE%9E/"/>
    
  </entry>
  
</feed>
